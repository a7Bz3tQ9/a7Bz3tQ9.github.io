### 前置知识

#### 同余

- 若 $d\mid \gcd(a,b,m)$，则 $a\equiv b\pmod m\Rightarrow \frac a d\equiv \frac b d\pmod{\frac m d}$。

    > 证明：$m\mid (a-b)\Rightarrow \frac m d\mid (\frac a d-\frac b d)$。

- 对于 $\gcd(u,v)=1$，若 $a\bmod u=x$ 且 $a\bmod v=x$，则 $a\bmod (uv)=x$。

    > 证明：设 $a=ut_1+x=vt_2+x$，则 $ut_1=vt_2$，则 $v\mid ut_1$。
    >
    > 由于 $u\perp v$，故 $v\mid t_1$，$\frac {t_1} v\in\mathbb Z$。
    >
    > $a=u(v\frac{t_1}{v})+x$，得证。

- 对于 $b\mid a$，$\frac a b\bmod m=\frac{a\bmod (bm)}{b}$。

- $a\equiv b\pmod m\Rightarrow \gcd(a,m)=\gcd(b,m)$。

    > 证明：$\gcd(a,m)=\gcd(a\bmod m,m)$，$\gcd(b,m)=\gcd(b\bmod m,m)$。

    推论：对于 $a\equiv b\pmod m$，若 $d\mid a$ 且 $d\mid m$，则 $d\mid b$。

#### 裴蜀定理

关于 $x,y$ 的方程 $ax+by=c$ 有整数解当且仅当 $c$ 是 $\gcd(a,b)$ 的倍数。

> - 必要性：设 $x_0,y_0$ 为一组解。设 $d=\gcd(a,b),a'=\large\frac{a}{d},\normalsize b'=\large\frac{b}{d}$，那么 $ax_0+by_0=a'dx_0+b'dy_0=d(a'x_0+b'y_0)$ 也应为 $d$ 的倍数。
> - 充分性：用 exgcd 求出 $ax+by=\gcd(a,b)$ 的一组解，将其乘上 $\large\frac{c}{\gcd(a,b)}$ 即可。

可以扩展到多元：$a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=c$，有整数解当且仅当 $\gcd(a_1,a_2,\cdots,a_n)\mid c$。

换句话说，$\sum a_ix_i=\{c\mid c=k\times\gcd(a_1,a_2,\cdots,a_n),k\in\mathbb N\}$。

应用：因为 $ax+by$ 在 $a\perp b$ 时取遍所有整数，而固定 $x$，$ax+by=c$ 有解 $\Leftrightarrow ax\equiv c\pmod b$，所以若 $a\perp b$，则 $ax\bmod b$ 取遍 $0\sim b-1$。

例题：[P4495 [HAOI2018]奇怪的背包](https://www.luogu.com.cn/problem/P4495)，ARC152C。

#### 扩展欧几里得（exgcd）

用于求 $ax+by=\gcd(a,b)$ 的一组特解。

- 若 $b=0$，$\gcd(a,b)=a$，原方程变为 $ax=a$。$x=1,y=0$ 即可。
- 否则若 $b\neq 0$，递归求解 $bx+(a\bmod b)y=\gcd(b,a\bmod b)$ 的解 $x_0,y_0$。根据求 $\gcd$ 的过程可知 $\gcd(a,b)=\gcd(b,a\bmod b)$，故 $bx_0+(a\bmod b)y_0=\gcd(a,b)$，而 $a\bmod b=a-\lfloor\large\frac{a}{b}\normalsize\rfloor \times b$，故 $bx_0+(a-\lfloor\large\frac{a}{b}\normalsize\rfloor \times b)y_0=\gcd(a,b)$，整理得 $ay_0+b(x_0-\lfloor\large\frac a b \normalsize\rfloor\times y_0)=\gcd(a,b)$。故方程 $ax+by=\gcd(a,b)$ 的一组解为 $x=y_0,y=x_0-\lfloor\large\frac a b\normalsize \rfloor\times y_0$。递归即可。

复杂度 $\mathcal O(\log(\max(a,b)))$。

值域分析：$ax+by=\gcd(a,b)$ 的解有无数个，显然其中有的解会爆 long long。但可以证明，exgcd 求出的一组可行解必有 $|x|\leq b,|y|\leq a$。注意 exgcd 得到的 $x,y$ 可能是负数。

```cpp
void exgcd(int a,int b,int &x,int &y){
	if(!b){x=1,y=0;return;}
	exgcd(b,a%b,y,x),y-=(a/b)*x; 
}
```

- 特解转通解：假设已知一组特解 $x_0,y_0$。$a(x_0+\Delta x)+b(y_0+\Delta y)=c$，与 $ax_0+by_0=c$ 相减，得到 $a\Delta x+b\Delta y=0$，即 $\Delta x=\frac{-b\Delta y}{a}\Rightarrow\frac{a}{\gcd(a,b)}\mid \Delta y$，$\Delta y=\frac{-a\Delta x}{b}\Rightarrow \frac{b}{\gcd(a,b)}\mid \Delta x$。设 $\Delta x=k\frac{b}{\gcd(a,b)}$，那么 $\Delta y=\frac{-a\Delta x}{b}=-k\frac{a}{\gcd(a,b)}$，因此通解为 $x=x_0+k\frac{b}{\gcd(a,b)},y=y_0-k\frac{a}{\gcd(a,b)}\,(k\in \mathbb{Z})$。

- $ax+by=c$ 的通解：根据裴蜀定理，有解当且仅当 $\gcd(a,b)\mid c$。先 exgcd 求出 $ax'+by'=\gcd(a,b)$ 的一组解，得到一组解 $x_0=x'\frac{c}{\gcd(a,b)},y_0=y'\frac{c}{\gcd(a,b)}$。所以通解为 $x=x'\frac{c}{\gcd(a,b)}+k\frac{b}{\gcd(a,b)},y=y'\frac{c}{\gcd(a,b)}-k\frac{a}{\gcd(a,b)}\,(k\in \mathbb{Z})$。求得 $x_0$，该方程的最小非负整数解就是 `(x%(b/d)+b/d)%(b/d)`（`d=gcd(a,b)`），这样求得了一组 $0\leq x<\frac b d$ 的解。

    求正整数解（$x,y$ 均为正整数的解）的数量，以及正整数解中 $x_{\min},x_{\max},y_{\min},y_{\max}$：记 $d_x=\frac{b}{\gcd(a,b)},d_y=\frac{a}{\gcd(a,b)}$：
    $$
    \begin{cases}
    x_0+kd_x>0\Rightarrow k>-\frac{x_0}{d_x}\\
    y_0-kd_y>0\Rightarrow k<\frac{y_0}{d_y}\\
    \end{cases}
    \Rightarrow
    \lceil\frac{-x_0+1}{d_x}\rceil\leq k\leq \lfloor\frac{y_0-1}{d_y}\rfloor
    $$
    记 $l=\lfloor\frac{-x_0+1}{d_x}\rfloor,r=\lfloor\frac{y_0-1}{d_y}\rfloor$。若 $l>r$ 则无正整数解；否则，有 $r-l+1$ 组正整数解，$x_{\min}=x_0+ld_x$，$x_{\max}=x_0+rd_x$，$y_{\min}=y_0-rd_y$，$y_{\max}=y_0-ld_y$。

    同时，对于 $l>r$，若 $\gcd(a,b)\not\mid c$ 则无整数解，否则所有整数解中 $x$ 的最小正整数值（$x$ 为正整数的整数解中 $x$ 的最小值）就是 $x_0+ld_x$（因为就是 $x_0+kd_x>0$ 且 $k$ 最小），同理所有整数解中 $y$ 的最小正整数值就是 $y_0-rd_y$。

    注意要开 `long long` / `__int128`，根据 $a,b$ 的数量级决定。

    由于 C++ 整数除法是向 $0$ 取整，求 $l,r$ 时为减少特判，可以转为 `double`。向下取整不要强转 `int`，比如 `(int)(-1.1)=-1` 比 $-1.1$ 还大。（P5656）

#### 一元一次同余方程

形如 $ax\equiv c\pmod m$ 的同余方程。写成 $ax+my=c$，根据裴蜀定理，有解当且仅当 $\gcd(a,m)\mid c$。exgcd 求出一组特解 $x_0$，根据上面说的特解转通解，通解为 $x=x_0+\frac{m}{\gcd(a,m)}k\pmod m$，有 $\frac{m}{\frac{m}{\gcd(a,m)}}=\gcd(a,m)$ 组解，只要算 $k\in[0,\gcd(a,m))$。

#### 逆元

定义 $a$ 模 $m$ 的逆元 $a^{-1}$ 为满足 $aa^{-1}\equiv 1\pmod m$ 的 $a^{-1}$，且 $a^{-1}\in[0,m)$。

这样 $\large\frac{x}{a}\normalsize\equiv xa^{-1}\pmod m$，因为 $xaa^{-1}\equiv x\pmod m$。

- $a^{-1}$ 存在当且仅当 $\gcd(a,m)=1$。

    证明：$aa^{-1}\equiv 1\pmod m$，等价于存在 $a'$ 使得 $aa^{-1}+my=1$，根据裴蜀定理，这当且仅当 $\gcd(a,m)\mid 1$，所以 $\gcd(a,m)=1$。

- 逆元如果存在，那么一定唯一。

    证明：假设 $\exists x,y\in[0,m)$ 满足 $ax\equiv ay\equiv 1\pmod m$，那么 $x\equiv x\times (ay)\equiv (ax)\times y\pmod m$，即 $x\equiv y\pmod m$，而 $x,y\in[0,m)$，矛盾。

求法：

1. 费马小定理：对于质数 $p$，$a^{p-1}\equiv 1\pmod p$，故 $aa^{p-2}\equiv 1\pmod p$，即 $a^{-1}\equiv a^{p-2}\pmod p$。适用于 $p$ 是质数的情况。
2. exgcd：设 $aa^{-1}=km+1$，那么 $aa^{-1}-km=1$，相当于解方程 $ax+my=1$，由于 $\gcd(a,m)=1$，这等价于 $ax+my=\gcd(a,m)$，exgcd 然后提取 $x$ 的值即可。注意 exgcd 不是基于剩余系的，求出的 $x$ 可能是负数，需通过取模操作将其处理到 $[0,m)$ 之内。
3. 线性求逆元。设 $inv_i$ 为 $i$ 在模 $m$ 下的逆元。设 $m=ki+r\,(r<i)$，于是 $r\equiv -ki\pmod m$，两边同时乘上 $i^{-1}r^{-1}$ 可得 $i^{-1}\equiv -kr^{-1}\pmod m$，而由于 $r<i$，根据 $inv_r$ 递推求解即可，$inv_i\equiv -\lfloor\large\frac{m}{i}\normalsize\rfloor\times inv_{m\ \bmod\ i}\pmod m$。

#### 欧拉定理

欧拉定理：对于 $\gcd(a,m)=1$，有 $a^{\varphi(m)}\equiv 1\pmod m$。

费马小定理：当 $m$ 为质数时，$a^{m-1}\equiv 1\pmod m$。

证明略。注意 $a^i\bmod m$ 的循环节长度不是 $\varphi(m)$，即最小的满足 $a^x\equiv 1\pmod m,x>0$ 的 $x$ 不是 $\varphi(m)$。但是 $x$ 必定是 $\varphi(m)$ 的约数，在原根那里会提到。

#### 扩展欧拉定理

$$
a^x\equiv \begin{cases}
a^{x\ \bmod\ \varphi(m)}&\gcd(a,x)=1
\\a^x&x\leq\varphi(m)
\\a^{x\ \bmod\ \varphi(m)+\varphi(m)}&x>\varphi(m)\end{cases} \pmod m
$$

也就是说，$a^x\bmod m$ 的值，前 $\varphi(m)$ 个还不一定进入循环节，后面每 $\varphi(m)$ 个一循环（注意：这边的 $\varphi(m)$ 也未必是最短循环节长度，要求最短的可以 BSGS）。

比如 $14^i\bmod 44$ 的值：$1,14,20,4,16,36,20,4,16,36,\cdots$，前几个未进入循环节，后面就每 $4$ 个一循环了。

- 证明：设 $a=p_1^{k_1}p_2^{k_2} p_3^{k_3}\cdots p_t^{k_t}$，只需对每个 $p_i$ 证出 $(p_i^{k_i})^x\equiv (p_i^{k_i})^{x\ \bmod\  \varphi(m)+\varphi(m)}\pmod {p_i^{k_i}}$，然后 CRT 即可。

    考虑某个质因子 $p$，设 $m=s\cdot p^k,\gcd(s,p)=1$。根据欧拉定理有 $p^{\varphi(s)}\equiv 1\pmod s$。而根据 $\gcd(s,p^k)=1$ 可知 $\varphi(m)=\varphi(s)\varphi(p^k)$，故 $\varphi(s)\mid \varphi(m)$。故 $p^{\varphi(m)}\equiv 1\pmod s$。

    根据同余的性质，同余号左右两边同乘 $p^k$ 可得 $p^{\varphi(m)+k}\equiv p^k\pmod{s\cdot p^k}$。而 $s\cdot p^k=m$，故 $p^{\varphi(m)+k}\equiv p^k\pmod m$。考虑某个 $c\geq k$，显然有 $p^c=p^{c-k}\cdot p^k\equiv p^{c-k}\cdot p^{k+\varphi(m)}=p^{c+\varphi(m)}$。于是 $\forall c\geq k,p^c\equiv p^{c+\varphi(m)}\pmod m$。而显然 $k\leq \varphi(m)$，故 $p^x\equiv p^{x\ \bmod\ \varphi(m)+\varphi(m)}$。两边同时 $k$ 次方可得 $(p^k)^x\equiv (p^k)^{x\ \bmod \ \varphi(m)+\varphi(m)}\pmod p$，得证。

主要用来降幂，维护指数 $\bmod\varphi$ 和递归过程中指数是否 $\geq \varphi$ 过。例题：[P3747 [六省联考 2017] 相逢是问候](https://www.luogu.com.cn/problem/P3747)，[P3934 [Ynoi2016] 炸脖龙 I](https://www.luogu.com.cn/problem/P3934)。

#### 二项式定理

考虑 $n$ 个 $(a+b)$ 乘起来，每一项要么选 $a$ 要么选 $b$，$a^ib^{n-i}$ 相当于在 $n$ 个括号中有 $i$ 个选择 $a$，$n-i$ 个选择 $b$，所以 $a^ib^{n-i}$ 前的系数为 $\large\binom n i$。
$$
(a+b)^n=\sum_{i=0}^n\binom n i a^ib^{n-i}
$$
$1$ 的幂在求和的过程中可能会被隐藏起来。有些时候可以考虑补上 $1$ 的幂凑个二项式定理。如 $\sum_{i=0}^n\large\binom n i\normalsize=\sum_{i=0}^n\large\binom n i\normalsize 1^i1^{n-i}=(1+1)^n=2^n$，$\sum_{i=0}^n (-1)^i\large\binom n i\normalsize=\sum_{i=0}^n\large\binom n i\normalsize(-1)^i 1^{n-i}=0^n=[n=0]$。

**多项式系数：**$\large\binom{n}{n_1,n_2,\cdots,n_m}\normalsize=\large\frac{n!}{n_1!n_2!\cdots n_m!}$。也就是 $n$ 个不同的球放到 $m$ 个不同的盒子里，使得第一个盒子含 $n_1$ 个球，第二个盒子含 $n_2$ 个球，……，第 $m$ 个盒子含 $n_m$ 个球 的方案数。

每个球可以放到任意一个盒子里，$\large\sum\binom{n}{n_1,n_2,\cdots,n_m}\normalsize=m^n$。

递推式 $\large\binom{n}{n_1,n_2,\cdots,n_m}=\binom{n-1}{n_1-1,n_2,\cdots,n_m}+\binom{n-1}{n_1,n_2-1,\cdots,n_m}+\cdots+\binom{n-1}{n_1,n_2,\cdots,n_m-1}$。

**多元二项式定理**：

$$
(x_1+x_2+\cdots+x_m)^n=\sum_{n_1+\cdots+n_m=n,\ n_i\geq 0}\binom{n}{n_1,n_2,\cdots,n_m}x_1^{n_1}x_2^{n_2}\cdots x_m^{n_m}
$$

### 欧拉函数

定义 $\varphi(n)$ 为 $n$ 以内与 $n$ 互质的数的个数。特别地，$\varphi(1)=1$。

对于质数 $p$，$\varphi(p)=p-1$，$\varphi(p^k)=p^k-p^{k-1}=(p-1)\times p^k$（与 $p^k$ 不互质的都是 $p$ 的倍数，而 $[1,p^k]$ 中共有 $p^{k-1}$ 个 $p$ 的倍数）。

设 $n=p_1^{k_1}\cdot p_2^{k_2}\cdots p_m^{k_m}$，则 $\varphi(n)=n\times \prod_{i=1}^m(1-\large\frac{1}{p_i}\normalsize)$。

> 考虑用一个“筛”的思想，先将 $[1,n]$ 中所有数标记为与 $n$ 互质，然后枚举每个 $p_i$，每次筛完剩下 $(1-\large\frac{1}{p_i}\normalsize)$ 的数（因为 $p_i$ 是互质的，前面的筛完后剩下的数中模 $p_i$ 余 $0,1,2,\cdots,p_i-1$ 的数的个数都是相等的。具体地，比如第一轮筛掉的数是 $p_i,2p_i,\cdots,n$，考虑 $p_i,2p_i,\cdots,p_jp_i$ 它们模 $p_j$ 的余数是互不相同的，可以用反证法简单证明），每个与 $n$ 含公共因子的数会在第一次被筛的时候筛去。

可以利用 $\varphi(n)=n\times \prod \large\frac{p_i-1}{p_i}$ 这个性质 $\mathcal O(\sqrt n)$ 直接计算 $\varphi(n)$，一般用于处理 $10^9$ 级别的数据。

```cpp
int phi(int n){
	int x=n,ans=n;
	for(int i=2;i*i<=n;i++) if(x%i==0){
		ans=ans/i*(i-1);
		while(x%i==0) x/=i;
	}
	if(x>1) ans=ans/x*(x-1);
	return ans;
}
```

$\varphi(n)$ 是积性函数但不是完全积性函数，即 $\forall \gcd(x,y)=1,\varphi(xy)=\varphi(x)\varphi(y)$。

> 设 $x$ 的质因数为 $p_1,p_2,\cdots,p_{\alpha}$，$y$ 的质因数为 $q_1,q_2,\cdots,q_{\beta}$，由于 $\gcd(x,y)=1$，$p_i\neq q_j$，故 $xy$ 中恰好包含了 $p_1,p_2,\cdots,p_{\alpha},q_1,q_2,\cdots,q_{\beta}$ 这 $\alpha+\beta$ 个质因数。
>
> 于是 $\varphi(xy)=xy\times\prod\limits_{i=1}^{\alpha}\large\frac{p_i-1}{p_i}\normalsize\times\prod\limits_{i=1}^{\beta}\large\frac{q_i-1}{q_i}\normalsize=(x\times\prod\limits_{i=1}^{\alpha}\large\frac{p_i-1}{p_i}\normalsize)\times(y\times\prod\limits_{i=1}^{\beta}\large\frac{q_i-1}{q_i}\normalsize)=\varphi(x)\varphi(y)$。
>
> 而 $\varphi(4)=2,\varphi(6)=2,\varphi(24)=8\neq \varphi(4)\times \varphi(6)$，故 $\varphi(n)$ 为积性函数但不是完全积性函数。
>
> 事实上，用这个性质可以很容易证明上面那个等式：$\varphi(n)=\prod \varphi(p_i^{k_i})=\prod p_i^{k_i-1}\times (p_i-1)=\prod p_i^{k_i}\times \large\frac{p_i-1}{p_i}\normalsize=n\prod (1-\frac{1}{p_i})$。

对于正整数 $x,y$，若 $x\mid y$，则 $\varphi(xy)=x\varphi(y)$。

> 与上一个类似，$\varphi(xy)=xy\times\prod\limits_{i=1}^{\beta}\large\frac{q_i-1}{q_i}\normalsize=x\times(y\times\prod\limits_{i=1}^{\beta}\large\frac{q_i-1}{q_i}\normalsize)=x\varphi(y)$。

利用这两个性质可以线性筛求 $\varphi(n)$。

```cpp
vis[0]=vis[1]=1,phi[1]=1;
for(int i=2;i<=n;i++){
	if(!vis[i]) p[++cnt]=i,phi[i]=i-1;	//对于质数 p，phi[p]=p-1
	for(int j=1;j<=cnt&&i*p[j]<=n;j++){
		vis[i*p[j]]=1;
		if(i%p[j]==0){phi[i*p[j]]=phi[i]*p[j];break;}	//对于 x|y，phi(xy)=xphi(y)
		phi[i*p[j]]=phi[i]*phi[p[j]];	//对于 gcd(x,y)=1，phi(xy)=phi(x)phi(y)
	}
}
```

$\forall n>2$，$\varphi(n)$ 为偶数。

> 对于 $m\leq n,\gcd(m,n)=1$，必有 $\gcd(n-m,n)=1$（否则假设 $n=ak,n-m=bk\,(k>1)$，则 $m=(a-b)k$，$\gcd(m,n)=k>1$ 矛盾）。而对于奇数 $n$，不存在整数 $m$ 使得 $n-m=m$，对于 $n>2$ 的偶数，虽然 $n-\large\frac n 2\normalsize=\large\frac n 2$，但 $\gcd(\large\frac n 2 \normalsize,n)>1$。故所有 $\leq n$ 与 $n$ 互质的数都可以两两配对（$m$ 和 $n-m$ 配对，$\gcd(m,n)=\gcd(n-m,n)=1$）。

$\sum_{d\mid n}\varphi(d)=n$。也就是 $\varphi*1=\text{Id}$。

> 有个很妙的证法。
>
> 列举出 $\large\frac 1 n\normalsize,\large\frac 2 n\normalsize,\large\frac 3 n\normalsize,\cdots,\large\frac n n\normalsize$，然后化简。当且仅当 $d\mid n,\gcd(a,d)=1$ 时，分数 $\large\frac{a}{d}$ 出现在其中。
>
> 那么，以 $d$ 为分母的分数有 $\varphi(d)$ 个，$d$ 可以取遍 $n$ 的所有因数。又因为共有 $n$ 个分数，所以 $\sum_{d\mid n}\varphi(d)=n$。

$\varphi(ab)=\frac{\varphi(a)\varphi(b)\gcd(a,b)}{\varphi(\gcd(a,b))}$。看到形如 $\varphi(a_i\times a_j)$ 可以考虑这个式子（CF809E）。

> 因为 $\varphi(x)=x\prod_{p_i\mid x} \frac{p_i-1}{p_i}$。

### 同底光速幂

用来去掉快速幂的 $\log$。

计算 $a^n\bmod p$（假设 $n<p$）。然后结合快速幂和 BSGS 的思想，令 $n=kB+r\,(r<B)$，预处理 $a^0,a^1,\cdots,a^{B-1}$ 和 $a^B,\cdots,a^{\lceil\frac p B\rceil B}$，则答案就是 $a^{kB}\times a^r$。

取 $B=\lceil\sqrt p\rceil$，时间复杂度 $\mathcal O(\sqrt{p})-\mathcal O(1)$，底数 $a$ 要相同。

### CRT & exCRT

#### 中国剩余定理（CRT）

求最小的满足以下方程的最小非负整数 $x$。其中 $m_i$ **两两互质**。

注意 $m_i$ 两两互质并非 $m_i$ 都是质数。
$$
\begin{cases}x\equiv a_1\pmod{m_1}\\x\equiv a_2\pmod{m_2}\\\dots\\x\equiv a_n\pmod{m_n}\end{cases}
$$
在 $[0,\prod m_i)$ 中有且仅有一个满足条件的 $x$，且显然是最小整数解。

考虑设 $x_i=\large\frac{\prod m}{m_i}\normalsize,t_i=x_i^{-1}\pmod {m_i}$，再记 $X=\sum a_ix_it_i$，那么 $X$ 就是满足同余方程组的解。如果要求最小解那就输出 $x\bmod (\prod m_i)$ 即可。

> 当 $i\neq j$ 时，$x_i=\large\frac{\prod m}{m_i}\normalsize$ 为 $m_j$ 的倍数，则有 $a_ix_it_i\equiv 0\pmod {m_j}$。
>
> 否则 $i=j$，又因为 $x_it_i\equiv 1\pmod {m_j}$，所以 $a_ix_it_i\equiv a_i\pmod {m_j}$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=20;
int n,x,y,a[N],m[N],mul=1,ans;
void exgcd(int a,int b,int &x,int &y){
	if(!b){x=1,y=0;return;}
	exgcd(b,a%b,y,x),y-=(a/b)*x; 
}
int inv(int a,int mod){
	return exgcd(a,mod,x,y),(x+mod)%mod;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&m[i],&a[i]),mul*=m[i];
	for(int i=1;i<=n;i++){
		int t=inv(mul/m[i],m[i]);
		ans=(ans+a[i]*mul/m[i]%mul*t%mul)%mul;
	}
	printf("%lld\n",ans);
	return 0;
}
```

#### 扩展中国剩余定理（exCRT）

学会 exCRT 就不用记 CRT 的结论了，好写好想（

$m_i$ 不互质。将同余方程两两合并：$\begin{cases}x\equiv a_1\pmod{m_1}\\x\equiv a_2\pmod{m_2}\end{cases}\Rightarrow x\equiv a\pmod{\text{lcm}(m_1,m_2)}$。

设 $x=k_1m_1+a_1=k_2m_2+a_2$，那么 $k_1\underline{m_1}-k_2\underline{m_2}=\underline{a_2-a_1}$。已知 $m_1,m_2,a_2-a_1$，exgcd 求 $k_1,k_2$ 即可（或无解）。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n;
ll a[N],m[N],x,y,ans;
void exgcd(ll a,ll b,ll &x,ll &y){
	if(!b){x=1,y=0;return;}
	exgcd(b,a%b,y,x),y-=(a/b)*x; 
}
ll exCRT(){
	ll M=m[1],X=a[1];
	for(int i=2;i<=n;i++){	//合并 x=X(mod M), x=a[i](mod m[i]) 
		ll b=m[i],c=a[i]-X,d=__gcd(M,m[i]);
		exgcd(M,m[i],x,y); 
		if(c%d) return -1;
		x=((__int128)x*c/d%(b/d)+(b/d))%(b/d),X+=x*M,M*=m[i]/d,X=(X+M)%M;
	} 
	return X;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&m[i],&a[i]); 
	printf("%lld\n",exCRT());
	return 0;
}
```

用简化版的 exCRT 写 CRT：

有些地方会直接写 `inv`，因为求 $k_1m_1-k_2m_2=a_2-a_1$ 一组解的 $k_1$，等价于求一个 $k_1m_1\equiv a_2-a_1\pmod{m_2}$ 的 $k_1$，意义上等价于求 $m_1$ 在模 $m_2$ 意义下的逆元。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,a[N],m[N];
ll x,y;
void exgcd(ll a,int b,ll &x,ll &y){
	if(!b){x=1,y=0;return;}
	exgcd(b,a%b,y,x),y-=(a/b)*x; 
}
int inv(ll a,int p){
	return exgcd(a,p,x,y),(x+p)%p;
}
signed main(){
	scanf("%d",&n);
	ll M=1,X=0;
	for(int i=1,k;i<=n;i++)
		scanf("%d%d",&m[i],&a[i]),
		k=1ll*(a[i]-X%m[i]+m[i])*inv(M,m[i])%m[i],X+=k*M,M*=m[i];
	printf("%lld\n",X);
	return 0;
}
```

### BSGS & exBSGS

#### 大步小步算法（BSGS）

求关于 $x$ 的方程 $a^x\equiv b\pmod p$ 的最小非负整数解，其中 $a\perp p$。

设阈值 $B$ 且 $x=kB-r\,(0\leq r<B)$：
$$
a^{kB-r}\equiv b\pmod p\Rightarrow a^{kB}\equiv a^r\times b\pmod p
$$
枚举 $r\in[0,B)$ 预处理所有 pair $((a^r\times b)\bmod p,r)$ 塞入哈希表。再枚举 $k\in[1,\frac p B]$ 判哈希表中是否存在 $(a^B)^k$，$x=kB-r$。实现时可以改为枚举 $r\in[1,B]$ 减少特判。

取 $B=\lceil\sqrt p\rceil$，时间复杂度 $\mathcal O(\sqrt p)$。一般 $B$ 取 ceil 不是 floor 是因为 $k$ 要枚举到 $\lceil\frac{p}{B}\rceil$，取 ceil 直接写枚举到 $B$ 即可，取 floor 可能要枚举到 $B+1$。

```cpp
//Luogu P3846
#include<bits/stdc++.h>
using namespace std;
int a,b,p,ans;
map<int,int>mp;
int BSGS(int a,int b,int p){
	a%=p,b%=p,mp.clear();
	int B=sqrt(p)+1,pw=1;
	for(int i=1;i<=B;i++) mp[1ll*(pw=1ll*pw*a%p)*b%p]=i;
	for(int i=1,x=1;i<=B;i++)
		if(mp.count(x=1ll*x*pw%p)) return i*B-mp[x];
	return -1;
} 
signed main(){
	scanf("%d%d%d",&p,&a,&b);
	ans=BSGS(a,b,p); 
	if(~ans) printf("%d\n",ans);
	else puts("no solution");
	return 0; 
}
```

例题：[ZR#913. 【附加赛0808】exBSBSGSGS](http://zhengruioi.com/problem/913)。

求 $x^a\equiv b\pmod p$（$p$ 是质数）：[P5605 小 A 与两位神仙](https://www.luogu.com.cn/problem/P5605)。

#### 扩展大步小步算法（exBSGS）

$a^x\equiv b\pmod p$ 的最小非负整数解，不一定 $a\perp p$。

思路：转化为 $a\perp p$。

设 $d_1=\gcd(a,p)$，那么 $a^{x-1}(\frac {a}{d_1}d_1)\equiv b\pmod{\frac{p}{d_1}d_1}$，若 $d_1\not\mid b$ 则无解，否则：
$$
a^{x-1}\frac{a}{d_1}\equiv \frac{b}{d_1}\pmod {\frac{p}{d_1}}
$$
若 $a\not\perp \frac{p}{d_1}$ 就一直递归下去（因为 $a^{x-1}\equiv \frac{b}{d_1}\times (\frac{a}{d_1})^{-1}\pmod{\frac{p}{d_1}}$），直至 $a\perp\frac{p}{d_1d_2\cdots d_k}$，设 $D=\prod_{i=1}^k d_i$：
$$
a^{x-k}\frac{a^k}{D}\equiv\frac{b}{D}\pmod{\frac{p}{D}}
$$
算出 $x-k$ 再加上 $k$ 即可。

（注意 $\frac{a}{d_1}\perp \frac{p}{d_1}$，但不一定 $a\perp\frac{p}{d_1}$，比如 $a=2,p=4$）

注意答案可能 $<k$（指的是可能还没到 $a\perp\frac{p}{D}$ 但已经有解了），若某时刻 $\frac{a^{k'}}{D}\equiv \frac b D\pmod{\frac p D}$，则答案为此时的 $k'$。即在每一次递归前特判形如 $a^{x'}\times ad\equiv b\pmod p$ 满足 $ad\equiv b\pmod p$ 时 $x'=0$，否则 $x'$ 一定 $\geq 1$，可以将 $k'$ 加 $1$ 继续递归。

```cpp
//Luogu P4195
#include<bits/stdc++.h>
using namespace std;
int a,b,p,ans;
map<int,int>mp;
int BSGS(int a,int b,int p,int ad){
	a%=p,b%=p,mp.clear();
	int B=sqrt(p)+1,pw=1;
	for(int i=1;i<=B;i++) mp[1ll*(pw=1ll*pw*a%p)*b%p]=i;
	for(int i=1,x=ad;i<=B;i++)	//x=1 -> x=ad
		if(mp.count(x=1ll*x*pw%p)) return i*B-mp[x];
	return -1;
} 
int exBSGS(int a,int b,int p){
	a%=p,b%=p;
	if(b==1) return 0;	//!!!
	int k=0,d,ad=1,ans;
	while((d=__gcd(a,p))>1){
		if(b%d) return -1;
		k++,b/=d,p/=d,ad=1ll*ad*a/d%p;	//!!! 改 ad 要写 p/=d 后面
		if(ad==b) return k;
	}
	return ~(ans=BSGS(a,b,p,ad))?ans+k:-1;
}
signed main(){
	while(~scanf("%d%d%d",&a,&p,&b)){
		if(!a&&!b&&!p) break;
		ans=exBSGS(a,b,p);
		if(~ans) printf("%d\n",ans);
		else puts("No Solution");
	}
	return 0; 
}
```

### Lucas & exLucas

#### Lucas 定理

我们知道，当 $p$ 为质数且比较大时，可以预处理阶乘逆元 $\mathcal O(1)$ 计算组合数。但 $p$ 较小时，$i\geq p,i!\equiv 0\pmod p$ 不存在逆元。这时可以用到 Lucas 定理。

$$
\dbinom n m\equiv \dbinom{n \bmod p}{m \bmod p}\times \dbinom{\lfloor\frac n p\rfloor}{\lfloor\frac m p\rfloor} \pmod p
$$

即把 $n$ 和 $m$ 表示成 $p$ 进制数，对 $p$ 进制下的每一位分别计算组合数，最后再乘起来。

```cpp
int lucas(int n,int m,int p){
	return !m?1:lucas(n/p,m/p,p)*C(n%p,m%p,p)%p;	//C 为暴力计算组合数 
}
```

证明：（注意 $p$ 是质数的大前提）

- 根据 $\binom p i\bmod p=[i=0\lor i=p]$（因为 $\binom p i=\frac{p!}{i!(p-i)!}$，分子质因数分解中 $p$ 的次数恰好为 $1$，只有 $i=0$ 或 $p$ 时 $i!(p-i)!$ 的质因子分解中含有 $p$）以及二项式定理，可得 $(a+b)^p\equiv a^p+b^p\pmod p$。

    根据 $(1+x)^p\equiv 1+x^p\pmod p$：

    $$
    (1+x)^n=(1+x)^{p\lfloor n/p\rfloor}(1+x)^{n\%p}\equiv (1+x^p)^{\lfloor n/p\rfloor}(1+x)^{n\%p}\pmod p
    $$

    $\binom n m=[x^m](1+x)^n$，而 $(1+x^p)^{\lfloor n/p\rfloor}$ 得到的所有指数都是 $p$ 的倍数，$(1+x)^{n\%p}$ 得到的所有指数都 $<p$，所以 $x^m$ 只能是前面选 $\lfloor \frac m p\rfloor$ 个 $x^p$ 后面选 $m\%p$ 个 $x$，$[x^m](1+x)^n=[y^{\lfloor m/p\rfloor}](1+y)^{\lfloor n/p\rfloor}\times [z^{m\%p}](1+z)%{n\%p}$，得证。

实际上，通过 $(1+x)^p\equiv 1+x^p\pmod p$ 数学归纳，可以得到 $(1+x)^{p^i}\equiv 1+x^{p^i}\pmod p$，这也是 ZR#1834 结论的由来。

#### 扩展 Lucas 定理（exLucas）

模数不一定是质数。

设模数 $=\sum p_i^{k_i}$，对每个 $p_i^{k_i}$ 分别处理，再 CRT 合并。

对于 $\frac{n!}{m!(n-m)!}\mod p^k$，问题在于 $m!$ 在模 $p^k$ 意义下没有逆元，先使 $m!$ 与 $p$ 互质：

$$
\frac{\frac{n!}{p^x}}{\frac{m!}{p^y}{\frac{(n-m)!}{p^z}}}p^{x-y-z}\bmod p^k\,(x=\sum_{i\geq 1}\lfloor\frac{n}{p^i}\rfloor)
$$

转化为求 $f(n)=\frac{n!}{p^x}$：

$$
n!=\prod_{p\mid i,i=1}^ni\prod_{p\not\mid i,i=1}^n i=p^{\lfloor\frac n p\rfloor}(\lfloor\frac n p\rfloor)!\prod_{p\not\mid i,i=1}^ni\\
\Rightarrow f(n)=f(\lfloor\frac n p\rfloor)\prod_{p\not\mid i,i=1}^ni=f(\lfloor\frac n p\rfloor)(\prod_{p\not\mid i,i=1}^{p^k}i)^{\lfloor\frac{n}{p^k}\rfloor}\prod_{p\not\mid i,i=1}^{n\bmod p^k}i
$$

最后一步是因为，$\prod_{i=1,p\not\mid i}^{p^k}i\equiv \prod_{i=1,p\not\mid i}^{p^k}(i+p^k)\pmod{p^k}$，所以可以提前预处理出 $p^k$ 以内 $\prod_{p\not\mid i}i$ 的前缀积，拆成 $\lfloor\frac{n}{p^k}\rfloor$ 个整段 + 零头。

预处理复杂度大概 $\mathcal O(\sum p_i^{k_i})$，单次查询复杂度 $\mathcal O(\omega(mod)\log n)$。

扩展：威尔逊定理的扩展形式是，$(\prod_{p\not\mid i,i=1}^{p^k}i)\bmod p^k=\begin{cases}1&(p=2\land k\geq 3)\\-1&(\text{otherwise})\end{cases}$，因此求 $(\prod_{p\not\mid i,i=1}^{p^k}i)^{\lfloor\frac{n}{p^k}\rfloor}$ 不需要快速幂，其 $\equiv 1$ 的条件是 $(p\neq 2\lor (p=2\land k\leq 2))\land(2\not\mid\lfloor\frac{n}{p_k}\rfloor)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
ll n,m;
int mod,p,pk,M=1,ans,x,y,pre[N],flg;
void exgcd(ll a,int b,int &x,int &y){
	if(!b){x=1,y=0;return;}
	exgcd(b,a%b,y,x),y-=(a/b)*x; 
}
int inv(int a,int p){return exgcd(a,p,x,y),(x+p)%p;}
int num(ll n){
	int ans=0;
	while(n) ans+=n/p,n/=p;
	return ans;
}
int f(ll n){
	if(n<p) return pre[n];
	return 1ll*f(n/p)*(flg&&n/pk&1?pk-1:1)*pre[n%pk]%pk;
}
int calc(){
	pre[0]=1,flg=(p^2)||pk<=4;
	for(int i=1;i<pk;i++) pre[i]=1ll*pre[i-1]*(i%p?i:1)%pk;
	int ans=1ll*f(n)*inv(1ll*f(m)*f(n-m)%pk,pk)%pk;
	for(int i=1,pw=num(n)-num(m)-num(n-m);i<=pw;i++)
		ans=1ll*ans*p%pk;
	return ans;
}
signed main(){
	scanf("%lld%lld%d",&n,&m,&mod);
	for(int i=2;i<=mod;i++){
		if(i*i>mod) i=mod;
		if(mod%i==0){
			p=i,pk=1;
			while(mod%i==0) mod/=i,pk*=i;
			ans+=1ll*(calc()-ans%pk+pk)*inv(M,pk)%pk*M,M*=pk;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

例题：P3726 [AH2017/HNOI2017]抛硬币。

### 原根与阶

#### 阶

设 $\gcd(a,m)=1$，定义 $a$ 在模 $m$ 意义下的阶为满足 $a^x\equiv 1\pmod m$ 的最小整数 $x$，记作 $\text{ord}_ma$。

- 根据欧拉定理，$a^{\varphi(m)}\equiv 1\pmod m$。故 $\text{ord}_m x\leq \varphi(m)$，且 $\text{ord}_mx$ 一定存在（当然前提条件是 $\gcd(a,m)=1$，否则没有阶，在 BSGS 的地方证过了）。

- $a^x\equiv 1\pmod m\Leftrightarrow\text{ord}_ma\mid x$。由此可推出 $\text{ord}_ma\mid \varphi(m)$。

    证明：反证法。设 $\text{ord}_ma$ 为 $y$，假设存在 $y\nmid x$ 使得 $a^x\equiv 1\pmod m$。显然 $a^{ky}\equiv 1\pmod m$（$k$ 为正整数），设 $x=ky+r\,(0<r<y)$，则 $a^x=a^{ky+r}\equiv 1\pmod m$，则 $a^r\equiv 1\pmod m$，又因为 $r<y$，与 $\text{ord}_m a$ 为最小的 $x$ 满足 $a^x\equiv 1\pmod m$ 矛盾。故得证。
  
- 设 $\text{ord}_ma=x$，则 $a^0,a^1,\cdots,a^{x-1}$ 对模 $m$ 两两不同余。

    证明：反证法。假设存在 $0\leq i<j<x$ 使得 $a^i\equiv a^j\pmod m$。由于$\gcd(a,m)=1$，$\large\frac{a^j}{a^i}\normalsize=a^{j-i}\equiv 1\pmod m$，而 $0<j-i<x$，这与 $\text{ord}_m a=x$ 的定义矛盾。故得证。

#### 原根

$\gcd(g,m)=1$，若 $\text{ord}_m g=\varphi(m)$，则称 $g$ 为 $m$ 的原根。

它还有一个等价的定义：$g^1,g^2,\cdots,g^{\varphi(m)}$ 模 $m$ 两两不同余。必要性根据阶的最后一个结论得证，充分性就是 $\forall x\in[1,\varphi(m)),g^x\not\equiv g^{\varphi(m)}=1$，由阶的定义可知 $\text{ord}_m g=\varphi(m)$。

**存在性：**只有 $1,2,4,p^a,2p^a$ 存在原根，其中 $p$ 是奇质数，$a$ 是任意正整数。

**判定 $a$ 是否为 $m$ 的原根：**首先要有 $\gcd(a,m)=1$，并且由于 $\text{ord}_m a\mid \varphi(m)$，所以可以枚举 $\varphi(m)$ 的约数 $d$，检验是否 $\exists a^d\equiv 1\pmod m$。更进一步，只需枚举质因子 $p$，检验 $a^{\large\frac{\varphi(m)}p}\equiv 1\pmod m$ 即可，因为它们涵盖了所有 $d$ 的倍数。

**求原根：**

- 求一个原根：原根密度较大，大约是 $n^{0.25}$，可以直接枚举或随机。
- 求所有原根：首先枚举找到 $m$ 最小的原根 $g$，$m$ 的原根都可以表示为 $g^k\bmod m,k\in[1,\varphi(m)],\gcd(k,\varphi(m))=1$ 的形式。

```cpp
//Luogu P6091 
#include<bits/stdc++.h> 
using namespace std;
const int N=2e6+5;
int t,n=1e6,d,x,cnt,p[N],phi[N],g,tot,tmp,ans[N];
bool vis[N],f[N];
vector<int>v;
int qpow(int x,int n,int mod){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans;
} 
bool ok(int a){	//判断 a 是否为 n 的原根 
	if(qpow(a,x,n)!=1) return 0;
	for(int p:v) if(qpow(a,x/p,n)==1) return 0;	//看  phi(m)/p 是否满足条件 
	return 1;
}
signed main(){
	scanf("%d",&t),vis[0]=vis[1]=1,phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]) p[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*p[j]<=n;j++){
			vis[i*p[j]]=1;
			if(i%p[j]==0){phi[i*p[j]]=phi[i]*p[j];break;}
			phi[i*p[j]]=phi[i]*phi[p[j]]; 
		}
	}
	f[1]=f[2]=f[4]=1;	//f[i]=1 表示 i 存在原根 
	for(int i=2;i<=cnt;i++){ 
		for(int j=1;1ll*j*p[i]<=n;j*=p[i]) f[j*p[i]]=1; 
		for(int j=2;1ll*j*p[i]<=n;j*=p[i]) f[j*p[i]]=1; 
	} 
	while(t--){
		scanf("%d%d",&n,&d);
		if(!f[n]){puts("0"),puts("");continue;}
		v.clear(),x=phi[n],g=tot=0,tmp=1;
		for(int i=2;i*i<=x;i++) if(x%i==0){	//求出 phi(m) 的质因子 
			v.push_back(i);
			while(x%i==0) x/=i;
		}
		if(x>1) v.push_back(x); x=phi[n];
		for(int i=1;i<=n;i++) if(ok(i)){g=i;break;}	 //找到 n 最小的原根 
		for(int i=1;i<=x;i++){
			tmp=1ll*tmp*g%n;
			if(__gcd(i,x)==1) ans[++tot]=tmp;
		}
		sort(ans+1,ans+1+tot),printf("%d\n",tot);
		for(int i=1;i<=tot/d;i++) printf("%d ",ans[i*d]); puts("");
	}
	return 0;
}
```

### 二次剩余

若存在整数 $x$ 使得 $x^2\equiv n\pmod p$，称 $n$ 为模 $p$ 意义下的二次剩余，否则称 $n$ 为模 $p$ 意义下的二次非剩余。这里只讨论 $p$ 为奇质数的情况。

结论：

- 在 $[1,p)$ 内，恰有 $\large\frac{p-1}{2}$ 个模 $p$ 的二次剩余，$\large\frac{p-1}{2}$ 个模 $p$ 的二次非剩余。若 $n$ 是模 $p$ 的二次剩余，则 $x^2\equiv n\pmod p$ 的解数为 $2$。

- 对于给定的正整数 $n$，可以用 **欧拉判别法** 判断关于 $x$ 的方程 $x^2\equiv n\pmod p$ 是否有解：有解当且仅当 $n^{\large\frac{p-1}{2}\normalsize}\equiv 1\pmod p$；相反，无解当且仅当 $n^{\large\frac{p-1}{2}\normalsize}\equiv -1\pmod p$。

#### Cipolla 算法

求解关于 $x$ 的方程 $x^2\equiv n\pmod p$。通俗来讲就是模意义开根。

1. 找到 $a$ 使得 $a^2-n$ 是模 $p$ 意义下的二次非剩余，即 $(a^2-n)^{\large\frac{p-1}{2}}\equiv -1\pmod p$（期望步数为 $2$）。
2. 令 $w=\sqrt{a^2-n}$，那么解有两个：$\pm (a+w)^{\large\frac{p+1}{2}}$。

> - $w^p\equiv -w\pmod p$。
>
>   证明：$w^p\equiv ww^{p-1}\equiv w(w^2)^{\large\frac{p-1}{2}}\equiv w(a^2-n)^{\large\frac{p-1}{2}}\equiv -w\pmod p$。
>
> - $(a+b)^p\equiv a^p+b^p\pmod p$。
>
>   证明：用二项式定理展开，$(a+b)^p=\large\sum\normalsize_{i=0}^p \large\binom p i\normalsize a^{p-i}b^i=\large\sum\normalsize_{i=0}^p \large\frac{p!}{(p-i)!i!}\normalsize a^{p-i}b^i$。发现对于 $\large\binom p i$，只有当 $i=0$ 或 $i=p$ 时不含 $p$ 这个因子，其他的都被模掉了（因为对于 $i\in[1,p)$，$i!$ 和 $(p-i)!$ 均不含因子 $p$，无法抵消）。
>
> 那么对于解 $x_0=(a+w)^{\large\frac{p+1}{2}}$，$x_0^2=(a+w)^{p+1}=(a+w)^p(a+w)=(a^p+w^p)(a+w)$，然后根据费马小定理，$a^p\equiv a\pmod p$，以及 $w^p\equiv -w\pmod p$，可知 $x_0^2=(a-w)(a+w)=a^2-w^2=a^2-(a^2-n)=n$。

诶，$a^2-n$ 不是二次非剩余吗，$\sqrt{a^2-n}$ 是哪里来的啊？这其实相当于扩展了数集的定义。类似于复数中的 $i^2=-1$，这里定义 $w^2=a^2-n$，$(a+bw)(c+dw)=(ac+bd(a^2-n))+(ad+bc)w$，可通过手写复数类 + 快速幂来实现计算 $(a+\sqrt{a^2-n})^{\large\frac{p+1}{2}}$（可以证明虚部一定为 $0$）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,p,a,w;
struct num{
	int x,y;
	friend num operator*(num a,num b){
		return {(int)(1ll*a.x*b.x%p+1ll*a.y*b.y%p*w%p)%p,(int)(1ll*a.x*b.y%p+1ll*a.y*b.x%p)%p};
	}
}x,ans;
int mul(int x,int n,int mod){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans;
}
signed main(){
	scanf("%d",&t);
	while(t--){ 
		scanf("%d%d",&n,&p);
		if(!n){puts("0");continue;}
		if(mul(n,(p-1)/2,p)==p-1){puts("Hola!");continue;} 
		while(1){
			a=rand()%p,w=(1ll*a*a%p-n+p)%p;
			if(mul(w,(p-1)/2,p)==p-1) break;
		}
		ans={1,0},x={a,1},m=(p+1)/2;
		for(;m;m>>=1,x=x*x) if(m&1) ans=ans*x;
		printf("%d %d\n",min(ans.x,p-ans.x),max(ans.x,p-ans.x));
	} 
	return 0;
} 
```

还有一些别的东西：勒让德符号、二次互反律。之后来补。
