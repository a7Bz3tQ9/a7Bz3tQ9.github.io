??? info "old"
	![image.png](https://s2.loli.net/2025/12/17/ueOzNEWicj2rwQg.png)
    ![image.png](https://s2.loli.net/2025/12/17/xHr6TbGkRnzpM28.png)
    ![image.png](https://s2.loli.net/2025/12/17/uFjGy3mdvpM4Swr.png)
    ![image.png](https://s2.loli.net/2025/12/17/lkVqZ9YEBRKPo6T.png)
    ![image.png](https://s2.loli.net/2025/12/17/fn8Ey1hMCDGt9p6.png)
    ![image.png](https://s2.loli.net/2025/12/17/jmfCILXsNoJd5n3.png)
    ![image.png](https://s2.loli.net/2025/12/17/wuBGo95Ll7NzXYs.png)
    ![image.png](https://s2.loli.net/2025/12/17/JE5aBcQeTt24gnZ.png)
    ![image.png](https://s2.loli.net/2025/12/17/TFd7oqACbfmty2a.png)
    ![image.png](https://s2.loli.net/2025/12/17/F8XLg4HdJxl6Ubc.png)
    ![image.png](https://s2.loli.net/2025/12/17/DK5oZ8fk216Up4P.png)
    ![image.png](https://s2.loli.net/2025/12/17/yL76e2AtaEIqiMW.png)
    ![image.png](https://s2.loli.net/2025/12/17/R2IkqWCBKGD51rb.png)
    ![image.png](https://s2.loli.net/2025/12/17/S16DYkQlU7pgIti.png)
    ![image.png](https://s2.loli.net/2025/12/17/fizZUR8OBYtmlbw.png)
    ![image.png](https://s2.loli.net/2025/12/17/hO8felqDNRr2MnI.png)
    ![image.png](https://s2.loli.net/2025/12/17/4xdXIr5U3OhPk2Z.png)
    ![image.png](https://s2.loli.net/2025/12/17/oA3haZLvKBfEGUC.png)
    ![image.png](https://s2.loli.net/2025/12/17/xSZcKNthnIbyPQV.png)
    ![image.png](https://s2.loli.net/2025/12/17/IHdQksOFAMYG6K1.png)
    ![image.png](https://s2.loli.net/2025/12/17/obc3DiHIXstOY4m.png)
    ![image.png](https://s2.loli.net/2025/12/17/qXMF1L62sTnvuVD.png)
    ![image.png](https://s2.loli.net/2025/12/17/zIqdWfXmYnCjk1G.png)
    ![image.png](https://s2.loli.net/2025/12/17/d6CK2sGLYuIJNrU.png)
    ![image.png](https://s2.loli.net/2025/12/17/IbnEgJNCcRs95XA.png)
    ![image.png](https://s2.loli.net/2025/12/17/StPIXKJL9x8pmwE.png)
    ![image.png](https://s2.loli.net/2025/12/17/I2ufAnZPc8hXgm6.png)
    ![image.png](https://s2.loli.net/2025/12/17/hK6xRekrJHpawVd.png)
    ![image.png](https://s2.loli.net/2025/12/17/t4VwCZv793Xod5L.png)

### 组合数

#### 定义

$\large\binom n m$ 表示从大小为 $n$ 的集合中选出一个大小为 $m$ 的子集的方案数。

$\large\binom n m\normalsize=\large\frac{n!}{m!(n-m)!}$。考虑任意打乱这个集合，钦定前 $m$ 个数被选出来，共有 $n!$ 种可能的情况。但这样会重复计算，即如果在此基础上打乱前 $m$ 个数或后 $n-m$ 个数，还能产生同种选取方案，故每种方案会被重复计算 $m!(n-m)!$ 次。

$\large\binom n m\normalsize=\large\frac{n(n-1)(n-2)\times \cdots\times (n-m+1)}{m(m-1)(m-2)\times \cdots \times 2\times 1}\normalsize=\large\frac{n^{\underline m}}{m!}$。

递推式 $\large\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}$，考虑最后一个元素选/不选。

#### 组合恒等式

首先有几个显然的恒等式：

1. $\large\binom{n}{m}\normalsize=\large\binom{n}{n-m}$

2. $\large\sum_{i=0}^n\binom{n}{i}\normalsize=2^n$（每个数选/不选）

3. $\large\sum_{i=0}^n\binom{n}{i}\normalsize[2\mid i]=\large\sum_{i=0}^n\binom{n}{i}\normalsize[2\nmid i]=2^{n-1}$（取奇数/偶数个，相当于前 $n−1$ 个任意选，最后一个根据前 $n−1$ 个的选择方案确定下来）

4. $\large\sum_{i=0}^k\binom{n}{i}\binom{m}{k-i}=\binom{n+m}{k}$

    > 一个小套路是，下指标变动尝试范德蒙德卷积，上指标变动尝试生成函数。生成函数可以推出 $\large\sum_{i=0}^n \binom i k\binom{n-i}{m-k}=\binom{n+1}{m+1}$。

    变形：$\large\sum_{i=0}^n \binom n i\binom m i=\binom{n+m}{n}$（将 $\large\binom m i$ 转化成 $\large\binom m{m-i}$，然后用上一个式子）

    > 小技巧：首先上指标需要是定值，然后，1. 若下指标的和是定值，直接范德蒙德卷积；2. 若下指标的差是定值，反转下指再范德蒙德卷积。

    $\large\sum_{i=0}^n \binom n i^2=\binom{2n}n$（上一个式子 $n=m$ 的形式）

5. 吸收恒等式：$\large \binom{n}{m}=\frac{n}{m}\binom{n-1}{m-1}$（$n$ 个里选 $m$ 个，再从中选一个代表元素，等价于先选一个代表元素，再从另外 $n−1$ 个里选择 $m−1$ 个）

    推广：$\large\binom n m \times \binom m k=\binom n k\times \binom{n-k}{m-k}$（$n$ 个里选出 $m$ 个，再在这 $m$ 个里选出 $k$ 个，等价于先选 $k$ 个，再在剩下的里选 $m-k$ 个）。

6. $\large\sum_{k=0}^n \normalsize k\large\binom n k\normalsize=n 2^{n-1}$：$\large \sum_{k=0}^n \normalsize k\large\binom n k=\sum_{k=0}^n \normalsize k\large\frac n k\binom{n-1}{k-1}=\normalsize n\large\sum_{k=0}^{n-1}\binom{n-1}{i}=\normalsize n2^{n-1}$

借助杨辉三角：

- $\large\sum_{i=0}^m \binom{n+i}{i}=\binom{n+m+1}{m}$：从杨辉三角 $(n,0)$ 开始，沿右下方向走 $m$ 步走到 $(n+m,m)$，经过的位置上的数之和等于结尾位置左下方的数 $(n+m+1,m)$。

    另一种理解方式：等式左边为从 $(0,0)$ 只向右或向上走，走到 $(n,i)$ 的方案数（$n+i$ 步中选 $i$ 步向上走）；右边为从 $(0,0)$ 只向右或向上走，走到 $(n+1,m)$ 的方案数。而每一种走到 $(n,i)$ 的方案，都唯一对应一种走到 $(n+1,m)$ 的方案 $(n,i)\to (n+1,i)\to (n+1,m)$（不能往上走，不然就会算到走到 $(n,j),j>i$ 的方案里）。

- $\large\sum_{i=0}^m\binom{n+i}{n}=\binom{n+m+1}{n+1}$：从杨辉三角 $(n,n)$ 开始，沿左下方向走 $m$ 步走到 $(n+m,n)$，经过的位置上的数之和等于结尾位置右下方的数 $(n+m+1,n+1)$。

    同样能以另一种方式理解。容易发现这个式子只是上一个式子的变形。

- $\large\sum_{i=m}^n\binom i m=\binom{n+1}{m+1}$：根据上上一个等式，$\large \sum_{i=0}^{n-m}\binom{m+i}{m}=\binom{m+n-m+1}{n-m}=\binom{n+1}{n-m}=\binom{n+1}{m+1}$。

    也可以组合意义解释：从 $n+1$ 个物品中选 $m+1$ 个物品，枚举最后一个物品。

    组合数上指标求和：$\large\sum_{i=l}^r\binom i m=\binom{r+1}{m+1}-\binom{l}{m+1}$。
  

斐波那契数列：$\large\sum_{i=0}^n \binom{n-i}i\normalsize =F_{n+1}$。

#### B2

叒一道例题，[AGC001E] BBQ Hard 加强版

> 给出 $a_{1\sim n},b_{1\sim n}$，求：
> 
> $$
> \sum_{i=1}^n\sum_{j=1}^n\binom{a_i+a_j+b_i+b_j}{a_i+a_j}
> $$
> 
> $\sum (a_i+b_i)\leq 2\times 10^7=M$。

**做法 1：**网格图走路角度 + 根号分治。

$\large\binom{a_i+b_i+a_j+b_j}{a_i+a_j}$ 可以看成只能向上或向右走，$(0,0)\to (a_i+a_j,b_i+b_j)$ 的方案数，即 $(-a_i,-b_i)\to (a_j,b_j)$ 的方案数。相当于有 $n$ 个起点，$n$ 个终点，求从任意一个起点走到任意一个终点的方案数。

称 $a_i+b_i<B$ 的为小点，其余的为大点。

- 起点是小点且终点是小点：

    初始时枚举所有，让 $f_{-a_i,-b_i}$ 加 $1$；然后转移 $f_{x,y}\gets f_{x-1,y}+f_{x,y-1}$，答案为 $\sum f_{a_i,b_i}$。复杂度 $\mathcal O(B^2)$。

- 起点是大点且终点是大点：

    暴力两两枚举算组合数，$\mathcal O((\frac M B)^2)$。

- 起点是小点且终点是大点：

    枚举一个大的终点，算所有小的起点到它的方案数之和。

    摆在平面上，起点在第三象限，终点在第一象限。注意到起点到终点一定恰好经过 $y=-x$ 上一个点（显然 $x\in[-B,B]$），我们在这个点上统计。

    枚举 $y=-x$ 上一个点 $(x,-x)$，所有小的起点到它的方案数就是 $f_{x,-y}$，它到大的终点的方案数组合数算，两者相乘。

    $\mathcal O(\frac M BB)$。

- 起点是大点且终点是小点：同理。

令 $B=\sqrt M$，时间复杂度 $\mathcal O(M)$。

**做法 2：**范德蒙德卷积 $\sum_{k=0}^m\binom{n_1}{k}\binom{n_2}{m-k}=\binom{n_1+n_2}{m}$ 逆用（将 $i,j$ 拆开的另一种方式）。

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n\binom{a_i+a_j+b_i+b_j}{a_i+a_j}\\
=&\sum_{i=1}^n\sum_{j=1}^n\sum_{x=-a_i}^{a_j}\binom{a_i+b_i}{a_i+x}\binom{a_j+b_j}{a_j-x}\\
=&\sum_x\sum_{i=1}^n\sum_{j=1}^n\binom{a_i+b_i}{a_i+x}\binom{a_j+b_j}{a_j-x}\\
=&\sum_x\left(\sum_{i=1}^n\binom{a_i+b_i}{a_i+x}\times \sum_{j=1}^n\binom{a_j+b_j}{a_j-x}\right)
\end{aligned}
$$

$\binom{a_i+b_i}{a_i+x}$ 有效，需要 $0\leq a_i+x\leq a_i+b_i$，故 $x\in[-a_i,b_i]$。同理，$0\leq a_j-x\leq a_j+b_j$，故 $x\in[-b_j,a_j]$。而 $\sum(a_i+b_i)\leq M$，所以有效的 $(x,i),(x,j)$ 对数是 $\mathcal O(M)$ 的。

只枚举有效的 $i,j$，时间复杂度 $\mathcal O(M)$。

### 错排

> 求有多少排列 $p_{1\sim n}$，使得 $\forall x\in[1,n],p_x\neq x$。

钦定 $i$ 个位置不满足的方案数为 $\binom n i (n-i)!$，二项式反演得：

$$
ans=\sum_{i=0}^n(-1)^i\times \binom n i (n-i)!=n!\sum_{i=0}^n\frac{(-1)^i}{i!}
$$

故 $a_n=a_{n-1}\times n+(-1)^n$，且 $a_1=0$。将其中一个 $a_{n-1}$ 改写成 $a_{n-2}\times (n-1)+(-1)^{n-1}$，可得：

$$
a_n=(n-1)(a_{n-1}+a_{n-2})
$$

意义：考虑新的数 $n$ 来的时候，若前 $n-1$ 个已经错排，任意交换一个即符合；若有 $n-2$ 个已经错排，和另一个放置正确的交换也符合，而放置正确的数有 $n-1$ 种情况。

### 容斥原理

> $n$ 个不同的数，$[1,m]$ 有多少数是 $n$ 个数中至少一个数的倍数。$n\leq 20$。

$$
ans=\sum_{S\neq\varnothing}\lfloor\frac{m}{\text{lcm}(S)}\rfloor(-1)^{|S|-1}
$$

原理：考虑 $x\in[1,m]$ 的贡献。设 $S'$ 表示 $n$ 个数中有哪些 $x$ 的因数，那么在枚举 $S\subseteq S'$ 时都会考虑到 $x$。

$$
\sum_{S\subseteq S',S\neq\varnothing}(-1)^{|S|-1}=\sum_{i=1}^{|S'|}\binom{|S'|}{i}(-1)^{i-1}=-(\sum_{i=0}^{|S'|}\binom{|S'|}{i}(-1)^i-1)=-0^{|S'|}+1
=
\begin{cases}
0&(|S'|=0)\\
1&(|S'|>0)
\end{cases}
$$

#### ZOJ3638 Fruit Ninja

2023.3.3

> 求有多少 $a_{1\sim n}$，满足 $\sum_{i=1}^na_i=m$ 以及两类形如 $a_i<v_i$ 和 $a_i>v_i$ 的限制。答案对 $10^9+7$ 取模。
>
> $0\leq n\leq 16$，$1\leq m\leq 10^7$。

没有限制：插板法，$\binom{m+n-1}{n-1}$。

加上第二类限制：$\binom{m-\sum v_i+n-1}{n-1}$。

加上第一类限制：容斥，钦定一个子集不满足限制，“不满足” $<$ 就是 $\geq$ 了。

### 二项式定理

$$
(a+b)^n=\sum_{i=0}^n\binom n i a^ib^{n-i}
$$

考虑 $a^ib^{n-i}$ 一项前的系数，相当于在 $n$ 个括号中有 $i$ 个选择 $a$，另外 $n-i$ 个选择 $b$，选法数为 $\large\binom n i$。

注意 $1$ 的幂在求和过程中可能会被隐藏起来。

#### CF660E Different Subsets For All Tuples（\*2300）

> 求所有长度为 $n$、每个数 $\in[1,m]$ 的数列（则共有 $m^n$ 种可能的序列），本质不同的子序列个数之和（包括空序列）。对 $10^9+7$ 取模。
>
> $1\leq n,m\leq 10^6$。

空序列的贡献 $m^n$ 可以单独计算。然后对于每个序列，我们在它第一次出现的时候计算它的贡献。

枚举这个子序列的长度 $len$，以及在原序列第一次出现的位置中，第一位的位置与值 $p_1,v_1$。由于是第一次出现，$1,2,\cdots,p_1-1$ 位上的值都不应为 $v_1$，共有 $(m-1)^{p_1-1}$ 种选择，而 $v_1$ 有 $m$ 种可能的值，所以贡献为 $m\times (m-1)^{p_1-1}$。同理再枚举 $p_2\,(p_1<p_2)$ 和 $v_2$，贡献为 $m\times (m-1)^{p_2-p_1}$，以此类推。$p_{len}\sim n$ 随便填，贡献为 $m^{n-p_{len}}$。总贡献为 $(m-1)^{p_{len}-len}\times m^{n-p_{len}+len}$。

这个式子只与 $p_{len}$ 和 $len$ 有关，所以我们可以枚举 $p_{len}$ 和 $len$，那么合法的 $p_1,p_2,\cdots,p_{len-1}$ 有 $\large\binom{p_{len}-1}{len-1}$ 种。用 $i$ 代替 $len$，$j$ 代替 $p_{len}$：

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=i}^n\binom{j-1}{i-1} (m-1)^{j-i} m^{n-j+i}
\\=&\sum_{j=1}^nm^{n-j}\sum_{i=1}^j\binom{j-1}{i-1}(m-1)^{j-i}m^{i}
\\=&\sum_{j=1}^nm^{n-j}\sum_{i=0}^{j-1}\binom{j-1}{i}(m-1)^{j-i-1}m^{i+1}
\\=&\sum_{j=1}^nm^{n-j+1}\sum_{i=0}^{j-1}\binom{j-1}{i}(m-1)^{j-i-1}m^{i}
\\=&\sum_{j=1}^nm^{n-j+1}(2m-1)^{j-1}
\end{aligned}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,ans;
int qpow(int x,int n){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans; 
} 
signed main(){
	scanf("%d%d",&n,&m),ans=qpow(m,n);
	for(int i=1;i<=n;i++)
		ans=(ans+1ll*qpow(m,n-i+1)*qpow(2*m-1,i-1)%mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

### 二项式反演

#### 主要形式

$$
f(n)=\sum_{i=0}^n (-1)^i\binom{n}{i}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n (-1)^i \binom{n}{i}f(i)
$$

> **证明：**将 $f(n)$ 代入 $g(n)$ 得：
> 
> $$
> g(n)=\sum_{i=0}^n(-1)^i\binom n i\sum_{j=0}^i(-1)^j\binom i j g(j)
> =\sum_{j=0}^n (-1)^jg(j)\sum_{i=j}^n(-1)^i\binom n i\binom i j
> $$
> 
> 根据 $\large\binom n i\binom i j=\binom n j\binom{n-j}{i-j}$ 得：
> 
> $$
> =\sum_{j=0}^n (-1)^jg(j)\sum_{i=j}^n(-1)^i\binom n j\binom {n-j}{i-j}
> =\sum_{j=0}^n (-1)^jg(j)\binom n j\sum_{i=j}^n(-1)^i\binom {n-j}{i-j}
> $$
> 
> 枚举 $i$ 改为枚举 $i-j$，这样里面的 $(-1)^j$ 就和外面的 $(-1)^j$ 抵掉了，然后里面乘个 $1^{n-j-i}$，就变成了一个二项式定理的形式：
> 
> $$
> \begin{aligned}
> &=\sum_{j=0}^n (-1)^jg(j)\binom n j\sum_{i=0}^{n-j}(-1)^i(-1)^j\binom {n-j}{i}
> \\&=\sum_{j=0}^n g(j)\binom n j\sum_{i=0}^{n-j}\binom {n-j}{i} (-1)^i1^{n-j-i}
> \\&=\sum_{j=0}^n g(j)\binom n j(1-1)^{n-j}=\sum_{j=0}^n g(j)\binom n j0^{n-j}
> \\&=\sum_{j=0}^ng(j)\binom n j\times [j=n]=g(n)
> \end{aligned}
> $$

#### 变形

$$
f(n)=\sum_{i=0}^n \binom{n}{i}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n \binom{n}{i}(-1)^{n-i}f(i)
$$

> **证明：**令 $h(n)=(-1)^ng(n)$，则 $f(n)=\sum_{i=0}^n (-1)^i\binom{n}{i}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n (-1)^i \binom{n}{i}f(i)$ 就变成了：
> 
> $$
> f(n)=\sum_{i=0}^n\binom n i h(i)\Leftrightarrow \frac{h(n)}{(-1)^n}=g(n)=\sum_{i=0}^n (-1)^i\binom n i f(i)
> $$

**组合意义：**设 $f(n)$ 表示至多满足 $n$ 个性质的方案数，$g(n)$ 表示恰好满足 $n$ 个性质的方案数。

然后是一个最常用的公式：

$$
f(n)=\sum_{i=n}^m\binom i n g(i)\Leftrightarrow g(n)=\sum_{i=n}^m (-1)^{i-n}\binom i n f(i)
$$

> **证明：**与主要形式类似。
> 
> $$
> \begin{aligned}
> f(n)&=\sum_{i=n}^m\binom i n\sum_{j=i}^m (-1)^{j-i}\binom j i f(j)=\sum_{i=n}^m\sum_{j=i}^m(-1)^{j-i}\binom i n\binom j if(j)
> \\&=\sum_{i=n}^m\sum_{j=i}^m (-1)^{j-i}\binom j n\binom{j-n}{i-n}f(j)=\sum_{j=n}^m \binom j n f(j)\sum_{i=n}^j(-1)^{j-i}\binom{j-n}{j-i}
> \\&=\sum_{j=n}^m\binom j n f(j)\sum_{i=0}^{j-n}(-1)^i1^{j-n-i}\binom{j-n}{i}
> \\&=\sum_{j=n}^m\binom j nf(j)(1-1)^{j-n}=\sum_{j=n}^m\binom j nf(j)0^{j-n}
> \\&=\sum_{j=n}^m\binom j nf(j)[j=n]=\binom n n f(n)=f(n)
> \end{aligned}
> $$
>

**组合意义：**记 $f(n)$ 表示“钦定选 $n$ 个，剩下的任意”，$g(n)$ 表示“恰好选 $n$ 个”，则对于任意 $i\geq n$，$g(i)$ 在 $f(n)$ 中被计算了 $\binom{i}{n}$ 次（$i$ 个里选 $n$ 个钦定），故 $f(n)=\sum_{i=n}^m \binom{i}{n}g(i)$，其中 $m$ 是数目上界。

**注意：**切勿将 $f(n)$ 来理解为普通的后缀和，因为 $f(n)$ 包含重复的方案，一个方案可以有多种钦定情况。

#### A1

> $n$ 个格子排成一排，用 $m$ 种颜色染色，要求相邻格子不能染上相同颜色，且每种颜色都必须用到的方案数。
>
> $n\leq 10^9$，$m\leq 10^5$。

容斥：强制 $i$ 种颜色没有用到，$ans=\sum_{i=0}^m(-1)^i\binom m i(m-i)(m-i-1)^{n-1}$。

二项式反演：设 $f_i$ 表示钦定 $i$ 种颜色没有用到，$g_i$ 表示恰好 $i$ 种颜色没有用到，那么 $f_i=(m-i)(m-i-1)^{n-1}$。$f_i=\sum_{j\geq i}\binom j ig_j$，$g_i=\sum_{j\geq i}(-1)^{j-i}\binom j i f_j$，所以 $ans=g_0=\sum_{j=0}^m(-1)^j (m-j)(m-j-1)^{n-1}$。

#### A2

容斥系数的计算。不一定是 $1,-1$！

> A1 用 $\geq i$ 种颜色方案数。

$ans$ 肯定是 $\sum_{j=0}^m v_j\binom m j g_j$ 的形式，其中 $v_j$ 表示容斥系数，$g_j$ 表示选择 $j$ 种颜色染色的方案数（但不一定每种都用到）。对于颜色集合 $S'$，我们希望 $|S'|\geq i$ 的每种染色方案贡献 $1$ 次，$|S'|<i$ 的贡献 $0$ 次。最后要求 $v$。

$S'$ 会在 $S'\subseteq S$ 的 $g_{|S|}$ 中考虑到。枚举 $j=|S|$，那么 $S'$ 的 **每种染色方案** 被算了：

$$
w_{|S'|}=\sum_{S'\subseteq S}v_{|S|}=\sum_{j=|S'|}^m\binom{m-|S'|}{j-|S'|}v_j
$$

那么：

$$
v_{|S'|}=w_{|S'|}-\sum_{j=|S'|+1}^m\binom{m-|S'|}{j-|S'}=[|S'|\geq i]-\sum_{j=|S'|+1}^m\binom{m-|S'|}{j-|S'|}v_j
$$

暴力 DP 一下算出容斥系数，再代入 $ans$ 即可。

### 子集反演

自己补的内容。

$$
f_S=\sum_{T\subseteq S}g_T\Leftrightarrow g_S=\sum_{T\subseteq S}(-1)^{|S|-|T|}f_T
$$

这对应二项式反演的 $f_n=\sum_{i=0}^n \binom{n}{i}g_i\Leftrightarrow g_n=\sum_{i=0}^n \binom{n}{i}(-1)^{n-i}f_i$。

$$
f_S=\sum_{S\subseteq T}g_T\Leftrightarrow g_S=\sum_{S\subseteq T}(-1)^{|T|-|S|}f_T
$$

这对应二项式反演的 $f_n=\sum_{i=n}^m\binom i n g_i\Leftrightarrow g_n=\sum_{i=n}^m\binom i n (-1)^{i-n}f_i$。

跟子集有关的计数，有时可以考虑子集反演。

### 下降幂与斯特林数

#### 下降幂

定义下降幂 $x^{\underline a}=x(x-1)(x-2)\cdots(x-a+2)(x-a+1)=\large\frac{x!}{(x-a)!}\normalsize=\large\binom x a\normalsize a!$。

一个性质，原理是 $\large\binom n i\binom i j=\binom n j\binom{n-j}{i-j}$：

$$
\displaystyle\binom{n}{i} i^{\underline j}=\binom{n-j}{i-j} n^{\underline j}
$$

一个很神奇的定理就是下降幂也符合二项式定理：

$$
(x+y)^{\underline n}=\sum_{i=0}^n\binom{n}{i}x^{\underline i}y^{\underline{n-i}}
$$

上升幂 $x^{\overline a}=x(x+1)(x+2)\cdots(x+a-1)=\large\frac{(x+a-1)!}{(x-1)!}$。

显然，$x^{\underline a},x^{\overline a}$ 均为关于 $x$ 的 $a$ 次多项式。

#### 第二类斯特林数

将 $n$ 个不同的数划分为 $m$ 个非空集合，方案数记作 $S(n,m)$ 或 $\begin{Bmatrix}n\\m\end{Bmatrix}$。

递推式 $\displaystyle S(n,m)=S(n-1,m-1)+S(n-1,m)\times m$：考虑最后一个数是新开一个集合或插入之前的一个集合。

$S(n,m)=\sum_{i=1}^n S(n-i,m-1)\times \large\binom{n-1}{i-1}$：枚举 $1$ 所在集合的大小 $i$。

1. $m^n=\sum_{i=0}^m\begin{Bmatrix}n\\i\end{Bmatrix}\times i!\times\binom{m}{i}$

    左边表示 $n$ 个球放入 $m$ 个不同的盒子的方案数。右边枚举有 $i$ 个盒子非空，方案数为 $\large\binom m i$，再将 $n$ 个球放入这 $i$ 个盒子，方案数 $S(n,i)$，由于盒子不同，最后还需乘上 $i!$。两者是等价的。

    由此可推出 $x^n=\displaystyle\sum\limits_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix} x^{\underline i}$，因为 $x^{\underline i}=i!\times \dbinom x i$。这个式子可以实现 **用下降幂来表示普通幂**。

    （$i$ 的上界为 $n,x,\min(n,x)$ 都是对的，因为 $i>x$ 或 $i>n$ 时对答案的贡献为 $0$）

2. 通项公式：$\begin{Bmatrix}n\\k\end{Bmatrix}=\dfrac{1}{k!}\displaystyle\sum\limits_{i=0}^k (-1)^{k-i}i^n \dbinom{k}{i}$

    对上个式子进行二项式反演，$\displaystyle F(n)=\sum_{i=0}^n G(i)\binom{n}{i}\Leftrightarrow G(n)=\sum_{i=0}^n F(i)(-1)^{n-i}\binom{n}{i}$，有 $x^n=\displaystyle\sum\limits_{i=0}^x\begin{Bmatrix}n\\i\end{Bmatrix}i!\binom{x}{i}\Leftrightarrow\begin{Bmatrix}n\\k\end{Bmatrix}=\frac{1}{k!}\sum_{i=0}^k i^n (-1)^{k-i}\binom{k}{i}$。

    同样也可以容斥。枚举非空盒子的个数 $i$，方案数 $\large\binom k i$，$n$ 个球放到 $i$ 个不同的盒子里方案数 $i^n$，由于盒子相同最后要除以 $k!$。

3. $\sum_{n=k}\begin{Bmatrix}n\\k\end{Bmatrix}\times \frac{x^n}{n!}=\frac{1}{k!}(e^x-1)^k$

    一个盒子放法的 EGF 就是 $e^x-1$（盒子非空，EGF $x^i$ 前的系数表示放 $i$ 个球的方案数），$k$ 个盒子放法的 EGF 就是 $(e^x-1)^k$，而由于盒子与盒子之间无区别，所有还要乘上 $\large\frac{1}{k!}$。

3. $\displaystyle\sum_{i=0}^ni^k=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\times j!\times\binom{n+1}{j+1}$

    也是 1 的一个推广。

    $$\sum_{i=0}^ni^k=\sum_{i=0}^n\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix} j!\binom{i}{j}=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^n\binom{i}{j}=\sum\limits_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix} j!\dbinom{n+1}{j+1}$$

#### 第一类斯特林数

将 $n$ 个不同的数划分为 $m$ 个非空圆排列，方案数记作 $s(n,m)$ 或 $\begin{bmatrix}n\\m\end{bmatrix}$。

递推式 $s(n,m)=s(n-1,m-1)+s(n-1,m)\times (n-1)$：考虑最后一个数是新开一个圆排列还是放入之前的圆排列（它可以插在任意元素的左边）。

$s(n,m)=\sum_{i=1}^n s(n-i,m-1)\times (i-1)!\times\large\binom{n-1}{i-1}$：枚举 $1$ 所在圆排列的大小 $i$，$i$ 个数组成一个圆排列的方案数为 $(i-1)!$。

1. $\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}=n!$

    每个 $1\sim n$ 的排列，与一个由 $n$ 个元素组成的置换一一对应。

2. $x^{\overline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}x^i$

    考虑使用数学归纳法，$n=1$ 时命题显然成立。

    假设命题对 $n=k$ 成立，即 $x^{\overline k}=\sum_{i=0}^k\begin{bmatrix} k\\i\end{bmatrix}x^i$，下证命题对 $n=k+1$ 时成立。
    
    $$
    \begin{aligned}
    x^{\overline{k+1}}&=x^{\overline k}\times (x+k)=(\sum_{i=0}^k\begin{bmatrix}k\\i\end{bmatrix}x^i)\times (x+k)=\sum_{i=0}^k \begin{bmatrix}k\\i\end{bmatrix}x^{i+1}+\sum_{i=0}^k\begin{bmatrix}k\\i\end{bmatrix}x^ik\\
    &=\sum_{i=0}^{k+1}(\begin{bmatrix}k\\i-1\end{bmatrix}+k\times \begin{bmatrix}k\\i\end{bmatrix})x^i=\sum_{i=0}^{k+1}\begin{bmatrix}k+1\\i\end{bmatrix}x^i
    \end{aligned}
    $$
    
    故命题对 $n=k+1$ 成立；故原命题成立。

3. $x^{\underline{n}}=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}x^i$

    证明和 2 差不多。
    
    $$
    \begin{aligned}
    x^{\underline{k+1}}&=x^{\underline k}\times (x-k)=(\sum_{i=0}^k (-1)^{k-i}\begin{bmatrix}k\\i\end{bmatrix}x^i)\times (x-k)
    \\&=\sum_{i=1}^{k+1}((-1)^{k-(i-1)}\begin{bmatrix}k\\i-1\end{bmatrix}-(-1)^{k-i}\begin{bmatrix}k\\i\end{bmatrix}k)x^i\\
    &=\sum_{i=1}^{k+1}(-1)^{(k+1)-i}(\begin{bmatrix}k\\i-1\end{bmatrix}+\begin{bmatrix}k\\i\end{bmatrix}k)x^i=\sum_{i=1}^{k+1}(-1)^{(k+1)-i}\begin{bmatrix}k\\i\end{bmatrix}x^i
    \end{aligned}
    $$
    
   该式可实现 **用普通幂来表示下降幂**。
   
4. $\sum_{n=k}\begin{bmatrix}n\\k\end{bmatrix}\times \frac{x^n}{n!}=\frac{1}{k!}\times \text{ln}(\frac{1}{1-x})^k$

    一个圆排列的 EGF 就是 $\sum_{i=1}^{\infty}(i-1)!\times \frac{x^i}{i!}=\sum_{i=1}^{\infty}\frac{x^i}{i}=\ln(\frac{1}{1-x})$（EGF $x^i$ 前的系数表示放 $i$ 个数的方案数），$k$ 个圆排列的 EGF 就是 $\ln(\frac{1}{x-1})^k$，而由于圆排列之间无区分，所以还要乘上 $\frac{1}{k!}$。

#### 普通幂与阶乘幂转化

四个公式，其中下降幂与普通幂转化的两个公式较常用：

- $x^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}x^{\underline{i}}$
- $x^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}(-1)^{n-i}x^{\overline{i}}$
- $x^{\overline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}x^i$
- $x^{\underline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i$

普通幂表示阶乘幂时用第一类，阶乘幂表示普通幂时用第二类。简单来说，若将等号左右两边叫做一区和二区，那么下划线在哪个区就用第几类斯特林数。

大幂（$x^{\overline n}>x^n>x^{\underline n}$）表示小幂时加 $(-1)^{n-i}$，小幂表示大幂时不加。

还有一些第一类斯特林数与第二类斯特林数结合的公式，应用不是很广泛：

- $\displaystyle\begin{bmatrix}n+1\\m+1\end{bmatrix}=\sum_{k=m}^n\begin{bmatrix}n\\k\end{bmatrix}\binom k m$

    $LHS$ 是 $n+1$ 个数分为 $m+1$ 个环排列。

    考虑把 $n+1$ 所在的环拆掉，将 $n+1$ 删除，剩余一条链，将其离散化成一个排列，根据排列中的置换环，将这些元素重新连接。原本有的环是白色，新产生的环染成黑色。这样 $n+1$ 所在环删掉 $n+1$ 能唯一映射到黑色的环们，反过来，如果给出黑色的环们，容易将其还原回排列，用 $n+1$ 把该排列重新连成环，所以黑色的环们与 $n+1$ 所在环构成双射。

    $RHS$：枚举删除 $n+1$ 后，白色环 + 黑色环一共有 $k$ 个，从中选出 $m$ 个为白色。

    ![](https://img2023.cnblogs.com/blog/1859218/202310/1859218-20231026132733306-1030421146.png)

- $\displaystyle\begin{Bmatrix}n+1\\m+1\end{Bmatrix}=\sum_{k=m}^n\binom n k\begin{Bmatrix}k\\m\end{Bmatrix}$

    $n+1$ 个元素分为 $m+1$ 个集合 $\Leftrightarrow$ 枚举 $n+1$ 与多少个数分在同一集合，剩余元素再分为 $m$ 个集合。

- $\binom n m=\sum_{k=m}^n\begin{Bmatrix}n+1\\k+1\end{Bmatrix}\begin{bmatrix}k\\m\end{bmatrix}(-1)^{m-k}$

#### CF932E Team Work（\*2400）

> 给出 $n,k$，求：
> $$
> \sum_{i=1}^n\binom n i\times i^k\pmod{10^9+7}
> $$
> $1\leq n\leq 10^9$，$1\leq k\leq 5000$。

第二类斯特林数常用来解决自然数 $k$ 次幂的问题。

一般碰到自然数 $k$ 次幂与组合数结合在一起的情况，直接拆 $k$ 次幂。

$$
\begin{aligned}
ans
&=\sum_{i=1}^n\binom n i\sum_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}j!\binom i j
=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^n\binom n i\binom i j
=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^n\binom n j\binom{n-j}{i-j}\\
&=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom n j\sum_{i=0}^{n-j}\binom{n-j}{i}=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom n j2^{n-j}
\end{aligned}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5,mod=1e9+7;
int n,k,s[N][N],ans;
int qpow(int x,int n){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans; 
} 
signed main(){
	scanf("%d%d",&n,&k),s[0][0]=1;
	for(int i=1;i<=k;i++)
		for(int j=1;j<=i;j++) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j%mod)%mod;
	for(int i=1,fac=1,c=1;i<=min(n,k);i++){
		fac=1ll*fac*i%mod,c=1ll*c*(n-i+1)%mod*qpow(i,mod-2)%mod;
		ans=(ans+1ll*s[k][i]*fac%mod*c%mod*qpow(2,n-i)%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```

#### P6620 [省选联考 2020 A 卷] 组合数问题

> 给出 $n,x,p,m$，$f(k)=a_0+a_1k+a_2k^2+\cdots+a_mk^m$，求：
> $$
> \sum_{k=0}^n f(k)\times x^k\times \binom n k\pmod p
> $$
> $1\leq n,x,p\leq 10^9$，$0\leq a_i\leq 10^9$，$0\leq m\leq \min(n,1000)$，$p$ 不一定是质数。

注意到普通幂与组合数不太搭，而下降幂与组合数都是基于阶乘运算的，且 $m$ 较小，于是考虑暴力求解第二类斯特林数，用普通幂转下降幂的技巧 $x^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}x^{\underline i}$，将 $f(k)$ 转化为 $b_0k^{\underline 0}+b_1k^{\underline 1}+\cdots+b_mk^{\underline m}$。

接下来就很套路了……

$$
\begin{aligned}
ans&=\sum_{k=0}^n\sum_{i=0}^m b_ik^{\underline i}x^k\binom n k
=\sum_{i=0}^m b_i\sum_{k=0}^n\binom k ii!x^k\binom n k
=\sum_{i=0}^m b_ii!\sum_{k=0}^n\binom n i\binom{n-i}{k-i}x^k\\
&=\sum_{i=0}^m b_ii!\binom n i\sum_{k=0}^{n-i}\binom{n-i}{k}x^{i+k}
=\sum_{i=0}^m b_ii!x^i\binom n i\sum_{k=0}^{n-i}\binom{n-i}{k}x^k\\
&=\sum_{i=0}^m b_ii!x^i\binom n i(1+x)^{n-i}=\sum_{i=0}^m b_ix^in^{\underline i}(1+x)^{n-i}
\end{aligned}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n,x,mod,m,a[N],b[N],s[N][N],ans;
int qpow(int x,int n){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans; 
}
signed main(){
	scanf("%d%d%d%d",&n,&x,&mod,&m),s[0][0]=1;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=i;j++) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j%mod)%mod;
	for(int i=0;i<=m;i++){
		scanf("%d",&a[i]);
		for(int j=0;j<=i;j++)
			b[j]=(b[j]+1ll*a[i]*s[i][j]%mod)%mod; 
	} 
	for(int i=0,pw=1,v=1;i<=m;i++){
		ans=(ans+1ll*b[i]*v%mod*pw%mod*qpow(1+x,n-i)%mod)%mod;
		v=1ll*v*(n-(i+1)+1)%mod,pw=1ll*pw*x%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```

总结出来的小套路：看到多项式与组合数结合的题，可以考虑将普通多项式转为下降幂多项式，而对于两个组合数相乘我们有恒等式 $\large\binom n m\binom m k\normalsize=\large\binom n k\binom{n-k}{m-k}$，这样可以将原式中待枚举的量 $m$ 从两个组合数转移到一个组合数 $\large\binom{n-k}{m-k}$ 中，进而可以用二项式定理等公式化简。

#### P4827 [国家集训队] Crash 的文明世界

> 给出一棵 $n$ 个节点的树，对于每个点 $x$，求 $\sum_{i\neq x}dis(i,x)^k$。
>
> $1\leq n\leq 5\times 10^4$，$1\leq k\leq 150$。

$$
ans_x=\sum_{i=1}^n dis(i,x)^k=\sum_{i=1}^n\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\binom{dis(i,x)}{j}j!=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=1}^n\binom{dis(i,x)}{j}
$$

发现瓶颈在于 $\sum_{i=1}^n\binom{dis(i,x)}{j}$，如果组合数能 $\mathcal O(1)$ 转移那就做完了。

设 $f_{i,j}$ 表示 $\sum_{x\in\text{subtree}(i)}\binom{dis(i,x)}{j}$，根据组合递推公式有 $f_{u,j}=\sum_{v\in son_u}f_{v,j}+f_{v,j-1}$。这样就可以 $\mathcal O(1)$ 转移了，再套个换根 DP 即可通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5,M=160,mod=1e4+7;
int n,k,x,y,s[M][M],f[N][M],g[N][M],tmp[M];
vector<int>v[N];
void dfs(int x,int fa){
	f[x][0]=1;
	for(int y:v[x]) if(y!=fa){
		dfs(y,x);
		for(int j=0;j<=k;j++) (f[x][j]+=f[y][j]+(j?f[y][j-1]:0))%=mod; 
	}
}
void dfs2(int x,int fa){
	for(int i=0;i<=k;i++) g[x][i]=f[x][i];
	if(fa){
		for(int i=0;i<=k;i++)
			tmp[i]=(g[fa][i]-f[x][i]+mod-(i?f[x][i-1]:0)+mod)%mod;
		for(int i=0;i<=k;i++)
			g[x][i]=(g[x][i]+tmp[i]+tmp[i-1])%mod;
	}
	for(int y:v[x])
		if(y!=fa) dfs2(y,x);
}
signed main(){
	scanf("%d%d",&n,&k),s[0][0]=1;
	for(int i=1;i<=k;i++)
		for(int j=1;j<=i;j++) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j%mod)%mod;
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),v[x].push_back(y),v[y].push_back(x);
	dfs(1,0),dfs2(1,0);
	for(int i=1;i<=n;i++){
		int ans=0,fac=1;
		for(int j=0;j<=k;j++,fac=1ll*fac*j%mod)
			ans=(ans+1ll*s[k][j]*fac%mod*g[i][j]%mod)%mod;
		printf("%d\n",ans);
	} 
	return 0;
}
```

#### CF1278F Cards（\*2600）

> 有 $n$ 个互相独立的随机变量 $x_i$，每个都有 $\large\frac 1 m$ 的概率为 $1$，剩下概率为 $0$，求 $(\sum_{i=1}^n x_i)^k$ 的期望，对 $998244353$ 取模。
>
> $1\leq n,m<998244353$，$1\leq k\leq 5\times 10^3$.

记 $p=\large\frac 1 m$。枚举有 $i$ 个随机到 $1$。

$$
\begin{aligned}
ans&=\sum_{i=0}^n \binom n i p^i(1-p)^{n-i}i^k=\sum_{i=0}^n\binom n i p^i(1-p)^{n-i}\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\binom i j j!\\
&=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^n\binom n i\binom i jp^i(1-p)^{n-i}=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^n\binom n j\binom{n-j}{i-j} p^i(1-p)^{n-i}\\
&=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom n j\sum_{i=0}^{n-j}\binom{n-j}{i}p^{i+j}(1-p)^{n-i-j}\\
&=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom n jp^j\sum_{i=0}^{n-j}\binom{n-j}{i}p^i(1-p)^{n-j-i}\\
&=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom n jp^j(p+1-p)^{n-j}
=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}n^{\underline j}p^j
\end{aligned}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5,mod=998244353;
int n,m,k,p,s[N][N],v[N],ans;
int qpow(int x,int n){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod)
		if(n&1) ans=1ll*ans*x%mod;
	return ans;
}
signed main(){
	scanf("%d%d%d",&n,&m,&k),p=qpow(m,mod-2),s[0][0]=1;
    for(int i=1;i<=k;i++)
        for(int j=1;j<=i;j++) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j%mod)%mod;
	for(int i=0,v=1,pw=1;i<=k;i++){ 
		ans=(ans+1ll*s[k][i]*v%mod*pw%mod)%mod;
		v=1ll*v*(n-(i+1)+1)%mod,pw=1ll*pw*p%mod;
	} 
	printf("%d\n",ans);
	return 0;
}
```

#### CF961G Partitions（\*2700）

> 给出一个长度为 $n$ 的序列 $a_1,a_2,⋯,a_n$，定义一个集合 $s$ 的权值 $w(s)=|s|\sum_{x\in s}a_x$，一个划分的权值为 $w'(p)=\sum_{s\in p}w(s)$。求将 $n$ 个元素划分成 $k$ 个集合的所有方案的权值和，对 $10^9+7$ 取模。
>
> $1\leq k\leq n\leq 2\times10^5$，$1\leq a_i\leq 10^9$。

注意到每个 $a_x$ 贡献到答案里的次数是一样的。枚举 $x$ 所在的集合大小 $i$：

$$
\begin{aligned}
\sum_{i=1}^n i\binom{n-1}{i-1}\begin{Bmatrix}n-i\\k-1\end{Bmatrix}
&=\sum_{i=1}^n i\binom{n-1}{i-1}\frac{1}{(k-1)!}\sum_{j=0}^{k-1}(-1)^{k-1-j}j^{n-i}\binom{k-1}{j}\\
&=\sum_{i=1}^n i\binom{n-1}{i-1}\frac{1}{(k-1)!}\sum_{j=0}^{k-1}(-1)^{k-1-j}j^{n-i}\frac{(k-1)!}{j!(k-1-j)!}\\
&=\sum_{j=0}^{k-1}\frac{(-1)^{k-1-j}}{j!(k-1-j)!}\times\sum_{i=1}^n i\binom{n-1}{i-1}j^{n-i}\\
&=\sum_{j=0}^{k-1}\frac{(-1)^{k-1-j}}{j!(k-1-j)!}\times(\sum_{i=1}^n\binom{n-1}{i-1}j^{n-i}+\sum_{i=1}^n (i-1)\binom{n-1}{i-1}j^{n-i})
\end{aligned}
$$

注意到 $\large \binom{n}{m}=\frac{n}{m}\binom{n-1}{m-1}$，故：

$$
\begin{aligned}
&=\sum_{j=0}^{k-1}\frac{(-1)^{k-1-j}}{j!(k-1-j)!}\times(\sum_{i=1}^n\binom{n-1}{i-1}j^{n-i}1^{i-1}+\sum_{i=1}^n (n-1)\binom{n-2}{i-2}j^{n-i}1^{i-2})\\
&=\sum_{j=0}^{k-1}\frac{(-1)^{k-1-j}}{j!(k-1-j)!}\times[(j+1)^{n-1}+(n-1)(j+1)^{n-2}]
\end{aligned}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,mod=1e9+7;
int n,k,x,sum,inv[N],ans;
int qpow(int x,int n){
	if(n<0) return 0;
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod) if(n&1) ans=1ll*ans*x%mod;
	return ans;
}
signed main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&x),sum=(sum+x)%mod;
	inv[0]=inv[1]=1;
	for(int i=2;i<=k;i++) inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
	for(int i=1;i<=k;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;
	for(int i=0;i<k;i++)
		ans=(ans+1ll*((k-1-i)&1?mod-1:1)*inv[i]%mod*inv[k-1-i]%mod*(qpow(i+1,n-1)+1ll*(n-1)*qpow(i+1,n-2)%mod)%mod)%mod;
	printf("%lld\n",1ll*sum*ans%mod);
	return 0;
}
```

### 欧拉数

欧拉数（Eulerian Number）：$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle$ 表示长度为 $n$ 且有恰好 $k$ 个升高的排列个数（即有 $k$ 个位置 $i$ 使得 $p_i<p_{i+1}$）。

递推：按套路从小到大插入数的方法，在长度为 $n-1$ 的排列中插入 $n$。插入在 $p_i<p_{i+1}$ 的 $i,i+1$ 中间或插入到最左端，升高个数不变；插入到 $p_i>p_{i+1}$ 的 $i,i+1$ 中间或插入到最右端，升高个数 $+1$。

$$
\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=(k+1)\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle+(n-k)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle
$$

边界为 $\left\langle\begin{matrix}n\\0\end{matrix}\right\rangle=1$。

```cpp
o[0][0]=1;
for(int i=1;i<=n;i++){
	o[i][0]=1;
	for(int j=1;j<=i;j++)
		o[i][j]=(1ll*(j+1)*o[i-1][j]%mod+1ll*(i-j)*o[i-1][j-1]%mod)%mod;
}
```

