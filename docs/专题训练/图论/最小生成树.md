## 基础算法

### Prim

类比 Dijkstra 算法，我们维护一个集合 $S$，表示这个集合中的生成树已经确定了。每次加入一个与当前 MST “最近”的。

$d_i$ 表示 $i$ 的邻边中，另一端在 MST 中且边权最小的那条，若没有就是 $\infty$。每次选一个 $d_i$ 最小的点，将其与这条边加入 MST，并更新其他点的 $d$。初始时随便选一个点即可。

时间复杂度 $\mathcal O(n^2)$。同样可以用堆优化。

```cpp
void prim(){
	for(int i=1;i<=n;i++) d[i]=1e9,v[i]=0;
	d[1]=0; 
	for(int i=1;i<n;i++){
		int x=0;
		for(int j=1;j<=n;j++)
			if(!v[j]&&(!x||d[j]<d[x])) x=j;
		v[x]=1;
		for(int y=1;y<=n;y++)
			if(!v[y]) d[y]=min(d[y],a[x][y]);
	}
}
```

### Kruskal

用贪心的思路，把所有的边权从小到大排序，然后一条一条尝试加入，用并查集维护连通性。

可以发现这样一定能得到原图的最小生成树，证明：按边权从小到大枚举所有边，假设某个时刻可以加入 $(u,v)$（即 $u,v$ 不连通）却选择不加入，最终得到了一棵最小生成树。考虑这棵最小生成树上 $u\leadsto v$ 的路径，这上面一定有一条边权 $\geq w_{u,v}$ 的边，用 $(u,v)$ 替换它答案一定不会变劣。

时间复杂度 $\mathcal O(m\log m)$。

### ※ Boruvka

第三种求最小生成树的算法。

我们维护当前形成的所有连通块，接下来对于每一个连通块，找到边权最小的出边，然后合并两个连通块。

不断重复这个操作，直到整张图变成一个连通块。

由于每次操作连通块数量至少减半，所以时间复杂度最坏为 $\mathcal o((n+m)\log n)$，随机图的话复杂度能更低。

## ※ Kruskal 重构树

Kruskal 重构树是基于 Kruskal 最小生成树的一种算法，它主要通过将边权转化为点权来实现。

这个算法的流程如下：

- 将所有边按照边权排序，设 $r(x)$ 表示 $x$ 所在连通块的根节点（用并查集维护）。
- 枚举所有的边 $(u,v)$，若 $u,v$ 不连通，则：
	- 新建一个点 $x$，令 $x$ 的权值为 $w_{u,v}$，连接 $(x,r(u))$ 和 $(x,r(v))$，然后令 $r(u)=r(v)=x$。
	不断重复以上过程，直到所有点均连通。

时间复杂度 $\mathcal O(m\log m)$。

这样，我们就得到了一棵 $2n-1$ 个节点的二叉树，其中叶节点为原图中的点，其余的点代表原图中的边，并且满足父节点权值大于等于子节点。

它有什么用呢？

- 求 $u,v$ 之间路径上的最大边权 → 求重构树上 $u,v$ 两个点的 LCA 的点权
- 只保留边权 $\leq x$ 的边形成的树 → 重构树上点权 $\leq x$ 的点的子树
- ……

### ※ [NOI2018] 归程

> 给出一张 $n$ 个点 $m$ 条边的无向连通图，每条边有长度 $d$ 和海拔 $h$。$q$ 次询问，每次给出 $x,p$，设从 $x$ 出发只经过海拔 $>p$ 的边到达的点集为 $S$，求 $S$ 中点到 $1$ 最短路长度的最小值。
>
> $T\leq 3$，$n\leq 2\times 10^5$，$m,q\leq 4\times 10^5$，$l\leq 10^4$，$h\leq 10^9$，强制在线。

### ※ 一个例题

> 给出一棵 $n$ 个点的树，边有边权。定义一个点的权值为其到其他所有节点的路径上最小边权之和，求权值最大的点。
>
> $n\leq 10^5$。

## 非树边应用

### 最小生成树唯一性

> 判断 MST 的唯一性。

### 次小生成树

非严格次小生成树？严格最小生成树？

### 最小生成基环树

> 最小生成基环树。

### 一个例题

> 对于一张 $n$ 个点 $m$ 条边的无向图，对每一条边，都求一个最大权值 $k$，使得如果把这条边的权值改为 $k$（而其他边的权值不变），整个图的任意一棵 MST 上都有这条边。
>
> $n,m\leq 10^5$。

## 最小瓶颈

### 最小瓶颈生成树

最小生成树一定是最小瓶颈生成树（而最小瓶颈生成树不一定是最小生成树）

关于最小生成树一定是瓶颈生成树这一命题，可以运用反证法证明：我们设最小生成树中的最大边权为 $w$，如果最小生成树不是瓶颈生成树的话，则瓶颈生成树的所有边权都小于 $w$，我们只需删去原最小生成树中的最长边，用瓶颈生成树中的一条边来连接删去边后形成的两棵树，得到的新生成树一定比原最小生成树的权值和还要小，这样就产生了矛盾。

### 最小瓶颈路

无向图 $u\leadsto v$ 的最小瓶颈路的最大边权 → 最小生成树上 $u\leadsto v$ 的最大边权

#### [NOIP2013] 货车运输

> 给出一张 $n$ 个点 $m$ 条边的图，每条边有一个限重。
>
> $q$ 次询问，每次给出 $u,v$，问 $u\leadsto v$ 在不超过限重的情况下，重量最大可以是多少。
>
> $n\leq 10^4$，$m\leq 5\times 10^4$，$q\leq 3\times 10^4$。

#### P3684 [CERC2016] 机棚障碍 Hangar Hurdles

> 有一个 $n\times n$ 的网格图，上面有些格子可行，有些格子是障碍。
>
> 规定箱子是一个奇数边长的正方形，其坐标为其中心格点的坐标。
>
> $q$ 次询问想把一个箱子从 $(r_1,c_1)$ 推到 $(r_2,c_2)$，箱子最大的大小。
>
> $2\leq n\leq 10^3$，$1\leq q\leq 3\times 10^5$，$1\leq r_1,c_1,r_2,c_2\leq n$。


## ※ 最小直径生成树

BZOJ2180 最小直径生成树

> 给出一张 $n$ 个点 $m$ 条边的无向图，边有边权，求一棵生成树 $T$，使得 $T$ 的直径最小。输出这个直径。
>
> $1\leq m\leq 10^3$，$0\leq w_i\leq 10^3$。

## 建图练习

### 一个例题

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有点权 $a_i$，边有边权。
>
> 你可以选择一个非空点集 $S$，最小化 $\sum_{i\in S}a_i+\sum_{j\notin S}(\min_{i\in S}dis(i,j))$。
>
> $n,m\leq 10^5$，$a_i\leq 10^9$。

### 另一个例题

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有点权 $a_i$。对于生成树 $T$，设 $deg_x$ 表示 $x$ 在 $T$ 中的度数，定义 $T$ 的权值为 $\sum_x a_x\cdot deg_x$。求 MST。

## 综合练习

### CF1242B 0-1 MST（\*1900）

> 一个 $n$ 个点的无向完全图，边权为 $0$ 或 $1$。边权为 $1$ 的边有 $m$ 条。求 MST。
>
> $1\leq n\leq 10^5$，$0\leq m\leq \min(\frac{n(n-1)}{2},10^5)$。

### CF76A Gift（\*2200）

> 给出一张 $n$ 个点 $m$ 条边的无向图，每条边有属性 $(g_i,s_i)$。给定 $G,S$，求一棵图的生成树 $T$ 最小化 $G\times \max\limits_{i\in T}(g_i)+S\times \max\limits_{i\in T}(s_i)$。
>
> $2\leq n\leq 200$，$1\leq m\leq 5\times 10^4$，$1\leq G,S,g_i,s_i\leq 10^9$，2s。

### HDU7226 Darnassus

> 给出一个排列 $p_{1\sim n}$，建一张 $n$ 个点的完全图，$(i,j)$ 的边权为 $|i-j|\times|p_i-p_j|$，求这张图的 MST。
>
> $1\leq T\leq 5$，$1\leq n\leq 5\times 10^4$。


### ※ CF891C Envy（\*2300）

> 给出一张 $n$ 个点 $m$ 条边的无向连通图。每次询问给一个边集，问这些边能否出现在同一棵 MST 中。
>
> $n,m,\sum |S|\leq 5\times 10^5$。


### ※ 最大曼哈顿距离生成树

> 给出平面上 $n$ 个点，两个点之间的距离定义为曼哈顿距离，求这 $n$ 个点的最大生成树。
>
> $n\leq 2\times 10^6$。

