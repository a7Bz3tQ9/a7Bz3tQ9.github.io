## 一、最短路

### 基础算法

#### Dijkstra

**在所有边权均为正的情况下**，我们可以使用 Dijkstra 算法求出一个点到所有其他点的最短路。**注意不能用来求最长路。**

我们维护一个集合，表示这个集合内的点的最短路已经确定了。

每次从剩下的点中选择当前距离最小的点 $u$ 加入这个集合，然后枚举另一个点 $v$ 进行更新：$d_v\gets \min(d_v,d_u+w_{u,v})$。

直接这样做时间复杂度是 $\mathcal O(n^2)$ 的。

我们注意到，复杂度主要来源于两个地方。第一个是找出当前距离最小的点，这个用堆很容易实现。第二个是枚举 $v$，可以邻接表存图降到边数级别。

这样就把复杂度降到了 $\mathcal O(m\log m)$。

最短路的变种：优化 DP。spfa 是下下策，先尝试 dij。

- 比如 $d_y=\max(\min_{(x,y)\in E}\{d_x+w_{x,y}\},g_y)$。

    等价于 $d_y=\min_{(x,y)\in E}\{\max(d_x+w_{x,y},g_y)\}$。每次确定 $d_x$ 后，用 $\max(d_x+w_{x,y},g_y)$ 松弛 $d_y$ 即可。

    不难发现仍然是正确的。

#### Bellman-Ford

另一种求单源最短路的算法。边权可正可负。

考虑在上面出现过的松弛操作：$d_v=\min(d_v,d_u+w_{u,v})$。由于最短路径只会经过最多 $n$ 个点，因此每一个点的最短路径只会被松弛至多 $n-1$ 次。

所以我们可以对整张图进行 $n-1$ 次松弛操作，每次枚举所有的边进行更新。（初始只有 $d_S$ 正确，进行 $k$ 轮松弛后，所有边数 $\leq k$ 的路径都被考虑到。所以若存在最短路，至多松弛 $n-1$ 轮）

时间复杂度 $\mathcal O(nm)$。

- 判负环：若进行 $n-1$ 轮后，仍然有边能松弛，则必存在一个 $S$ 能抵达的负环。

#### SPFA

Bellman-Ford 的改进版。边权可正可负。

注意到，在进行松弛操作的时候，如果点 $u$ 的最短路一直没有变化，那么就不需要再枚举这个点的出边进行松弛了。

也就是说我们可以用一个队列保存所有距离发生变化的点，每次取出一个点进行更新。

如果图是随机的，SPFA 非常优秀，而且还可以有负权。

但是在最坏情况下它的复杂度和 Bellman-Ford 相同，都是 $\mathcal O(nm)$。

#### Floyd

全源最短路。边权可正可负。

用 DP 的思想，设 $f_{k,i,j}$ 为仅允许途经 $[1,k]$ 中节点时，$i\leadsto j$ 的最短路长度。

由于每个点在最短路中只会出现一次（不然就出现负环了，不存在最短路），所以可以写出转移方程：$f_{k,i,j}\gets\min(f_{k-1,i,j},f_{k-1,i,k}+f_{k-1,k,j})$。

时间复杂度 $\mathcal O(n^3)$。

实际上第一维可以省去，所以空间复杂度 $\mathcal O(n^2)$。

注意三层循环的顺序不能颠倒（如果是 $f_{i,j}\gets \min(f_{i,j},f_{i,k}+f_{k,j})$ 的话，$k$ 必须第一层循环枚举）。

- 判负环：Floyd 后判是否存在 $f_{i,i}<0$ 即可。如果要求的是从某一点 $s$ 是否有可达负环，根据 $f_{i,i}<0$ 确定负环上的点，再做一遍连通性 BFS 即可。

- 给出一个有向图，求两两点对之间的一条路径，使得边权最大值最小。（BZOJ1641 Cow Hurdles 奶牛跨栏）

    把加法改成取 $\max$ 就行。

- Floyd 传递闭包：

    有时候我们需要维护一些有传递性的关系，比如相等、连通等等。

    初始条件往往是已知若干个点对具有这些关系，然后让你求出来所有的关系。

    可以直接把 Floyd 算法做一下调整：`f[i][j]=f[i][j]|(f[i][k]&f[k][j])`。这个算法叫传递闭包。

    可以 bitset 优化：`if(f[i][k]) f[i]|=f[k];`。时间复杂度 $\mathcal O(\frac{n^3}{\omega})$。

- ※ 广义矩乘优化 Floyd：可以倍增优化转移，把经过 $k$ 条边改为经过 $2^k$ 条边。
	
	??? info "※ 一个例题"
		
        CF147B Smile House（\*2500）
        
        > 给出一张 $n$ 个点 $m$ 条边的有向图，边有边权，问最小的正环的大小。这里最小正环指的是包含的点数最少。
        >
        > $1\leq n\leq 300$，$0\leq m\leq\frac{n(n-1)}{2}$，$-10^4\leq w_{i,j}\leq 10^4$。
        
        设 $f_{i,j,k}$ 表示 $i\leadsto j$ 经过 $\leq k$ 条边的最大边权和。可以倍增优化转移，把经过 $k$ 条边改为经过 $2^k$ 条边。
        
        然后用倍增定位到最小的正环：如果再走 $\leq 2^x$ 步仍然都是负环没有正环，就给答案 $+2^x$。check 是否有正环就看是否存在 $f_{x,i,i}>0$。
        
        时间复杂度 $\mathcal O(n^3\log n)$。
        
        ```cpp
        #include<bits/stdc++.h>
        using namespace std;
        const int N=310;
        int n,m,x,y,ans;
        struct mat{
            int x[N][N];
            mat(){memset(x,-0x3f,sizeof(x));}
            friend mat operator*(mat a,mat b){
                mat c;
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=n;j++){
                        c.x[i][j]=max(a.x[i][j],b.x[i][j]);
                        for(int k=1;k<=n;k++)
                            c.x[i][j]=max(c.x[i][j],a.x[i][k]+b.x[k][j]);
                    }
                return c;
            }
        }f[15],cur,tmp;
        signed main(){
            scanf("%d%d",&n,&m);
            for(int i=1;i<=m;i++)
                scanf("%d%d",&x,&y),scanf("%d%d",&f[0].x[x][y],&f[0].x[y][x]);
            for(int i=1;i<=9;i++) f[i]=f[i-1]*f[i-1];
            for(int i=1;i<=n;i++) cur.x[i][i]=0;
            for(int i=9;i>=0;i--){
                tmp=cur*f[i];
                bool ok=1;
                for(int j=1;j<=n;j++) ok&=tmp.x[j][j]<=0;
                if(ok) ans+=1<<i,cur=tmp;
            }
            ans++,printf("%d\n",ans>n?0:ans);
            return 0;
        }
        ```

- ※ 最小正权环：

    > 给出一张无向正权图，求图中最小环。

    最小环必定是简单环。

    考虑环上最大点 $k$ 和任意其他两点 $i,j$，最小环必能被分割成 $f_{k-1,i,j}+f_{k-1,i,k}+f_{k-1,k,j}$。但可能会退化成路径！

    于是改为：考虑环上最大点 $k$ 和其相邻两点 $i,j$，最小环必能分割成 $f_{k-1,i,j}+w_{i,k}+w_{k,j}$。

    时间复杂度 $\mathcal O(n^3)$。

    ??? info "※ 拓展（无权无向图最小环更优做法）"

        事实上，无权无向图最小环（保证环上至少有 $3$ 个点）可以做到 $\mathcal O(n(n+m))$。
        
        枚举 $S$，求出以 $S$ 为根的一棵 bfs 生成树，对于一条非树边 $(x,y)$，我们就找到了一个环，$\text{chkmin}(ans,d_x+d_y+1)$ 即可（$d_x$ 表示 $dis_{S,x}$。生成树的好处是，非树边与所覆盖的树边构成环。bfs 树的好处是，树边走的都是最短路）。
        
        正确性：因为若 $d_x,d_y$ 对应路径有交则不优，并且最小环一定会被算到。
        
        实现：从 $S$ 开始 bfs。每次取出 queue 的 front $x$，枚举 $y\in N(x)$，若 $d_y$ 未赋值，找到了一条树边，$d_y=d_x+1$；否则，找到了一条非树边，$\text{chkmin}(ans,d_x+d_y+1)$。
        
        时间复杂度 $\mathcal O(n(n+m))$。
    
#### ※ Johnson

对于多源最短路，如果我们枚举一个点然后跑堆优化的 Dijkstra，那么复杂度是 $\mathcal O(nm\log n)$ 的，在图比较稀疏的情况下，这个复杂度要优于 Floyd 算法的 $\mathcal O(n^3)$。

但是 Dijkstra 算法要求所有边权均非负。

于是就有了重赋权的技巧。

我们新建一个 $0$ 号点，并且从这个点出发向所有点连一条边权为 $0$ 的边，然后跑单源最短路（SPFA 或者 Bellman-Ford）。

设距离数组为 $h$，接下来对于每条边 $(u,v)$，令 $w'_{u,v}\gets w_{u,v}+h_u-h_v$。

这样所有的边权就都变成非负了，我们就可以跑 Dijkstra 算法了。

首先由于 $h_v\leq h_u+w_{u,v}$，新图的边权一定非负。

设新图上的最短路径为 $d'$，原图上的最短路径为 $d$。
	
$\begin{aligned}d'_{u,v}&=\min\limits_{a_1,a_2,\cdots,a_k}w'_{u,a_1}+w'_{a_1,a_2}+\cdots+w'_{a_k,v}\\&=\min\limits_{a_1,a_2,\cdots,a_k}w_{u,a_1}+(h_u-h_{a_1})+w_{a_1,a_2}+(h_{a_1}-h_{a_2})+\cdots+w_{a_k,v}+(h_{a_k}-h_v)\\&=h_u-h_v+\min\limits_{a_1,a_2,\cdots,a_k}w_{u,a_1}+\cdots+w_{a_k,v}\\&=h_u-h_v+d_{u,v}\end{aligned}$

#### ※ 最短路树（最短路图）

所谓最短路树，就是在求完从 $S$ 出发的但愿最短路后，只保留最短路上的边形成的树。

只需要在求最短路的过程中维护一个 $pre$ 数组表示这个点的前驱即可。

### 建图练习

#### CF938D Buy a Ticket

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有点权 $a_i$。对每个 $i\in[1,n]$，求 $\min\limits_{1\leq j\leq n}\{2\cdot dis(i,j)+a_j\}$。
> 
> $1\leq n,m\leq 10^5$。

建一个超级源 $S$，连 $(S,i,a_i)$，原图边权整体 $\times 2$，跑单源最短路。

#### 一个例题

> 给出一张 $n$ 个点的图，点有点权 $a_i$。
>
> 若 $a_i\text{ and }a_j\neq 0$，则 $(i,j,\text{lowbit}(a_i\text{ and }a_j))\in E$。求 $d(1,n)$。
>
> $1\leq n\leq 10^5$，$0<a_i<2^{32}$。

由于 $\min$ 和 $\text{low}$ 同向，原题等价于，若 $a_i,a_j$ 第 $k$ 位都是 $1$，连 $(i,j,2^k)$。

进一步，第 $k$ 位是 $1$ 的点集两两互达且代价为 $2^k$。完全图边数无法承受，考虑 **建立虚点**，作为使用 $2^k$ 代价的中转站，来回的边权和设置为 $2^k$ 即可（比如去 $0$ 回 $2^k$）。

$\mathcal O(\log V)$ 个虚点，至多 $\mathcal O(n\log V)$ 条边，复杂度 $\mathcal O(n\log V\log n)$。

#### P4366 [Code+#4]最短路

> 给出一张 $n$ 个点的无向图，图中除了一些给出的有向边之外，任意两点 $i,j$ 之间都存在一条边权为 $C\cdot (i\oplus j)$ 的边。求 $dis(s,t)$。
>
> $n\leq 10^5$。

将一条边切割为一条路径，每次分别翻对应的位，与原图等价。具体地，对每个二进制位 $k$，连 $(i,i\oplus 2^k,C\cdot 2^k)$。新图的边数 $\mathcal O(n\log n)$。

时间复杂度 $\mathcal O(n\log^2 n)$。

#### 多源汇最短路

> 给定点集 $S_1,S_2$，求 $\min\limits_{u\in S_1}\min\limits_{v\in S_2}dis(u,v)$。

建立超级源超级汇。

#### [GXOI/GZOI2019] 旅行者

> 给出一张 $n$ 个点 $m$ 条边的无向带权图，其中有 $k$ 个关键点，求这 $k$ 个关键点间两两最短路的最小值。
> 
> $2\leq k\leq n,m\leq 10^5$。

之前多源多汇最短路解决的是两个不相交集合间的最短路，尝试把一个集合划分为两个，对于任意点对，需要至少将它们分开一次。

**二进制分组**。对于图中任意两关键点，它们编号的二进制位中必有一位不同。对于每个二进制位，分成这位为 $0$ 和这位为 $1$ 的两个集合。

时间复杂度 $\mathcal O(m\log m\log V)$。

二进制分组

每一位标号为 $0$ 放一个集合，标号为 $1$ 放一个集合

两个不同的点至少有一次会被分在两个不同的集合中

#### [JLOI2011] 飞行路线

> 给定一张 $n$ 个点 $m$ 条边的带权无向图，你可以把至多 $k$ 条边的边权变成 $0$，求 $s\leadsto t$ 的最短路。
> 
> $2\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$0\leq k\leq 10$。

经典模型：分层图最短路。

设 $(i,j)$ 表示从 $s$ 到达 $i$，途中把 $j$ 条边变成 $0$ 的情况。

把一个点拆成 $k$ 个点。

对于一条边 $(u,v)$：

- 从 $(u,k)$ 到 $(v,k)$ 连边权为 $w_{u,v}$ 的边。
- 从 $(u,k)$ 到 $(v,k+1)$ 连边权为 $0$ 的边。

最后求一遍从 $(s,0)$ 出发的单源最短路，答案即为 $\min\limits_{i\leq k}d(t,i)$。

时间复杂度 $\mathcal O(k(n+m)\log m)$。


### 同余最短路

#### 一个例题

> 给出 $a_{1\sim n}$，问最少选多少个数使得它们的和 $\bmod p=r$。数字可以重复使用。

由于数字可重复使用，每种余数的状态等价，视为节点。

连 $(i\to (i+a_k)\bmod p,1)$。答案为 $dis(0,r)$。

#### [ARC084B] Small Multiple

> 问 $n$ 的倍数当中，数位和最小的数是多少。
>
> $n\leq 10^5$。

每种余数的状态都是等价的，视为节点。

如何把造一个数分解为若干步拼成的过程，且余数和数位和的变化都一目了然？从 $1$ 开始（因为要求的就是到 $0$ 的最短路，所以不能从 $0$ 开始），任何数都可以由 $\times 10$ 和 $+1$ 两个操作拼成。

对于 $0\sim n-1$ 的每个点 $k$，连 $(k\to 10k\bmod n,0),(k\to (k+1)\bmod n,1)$。最后到 $0$ 的最短路长度就是最小的数位和。

是否可能出现不合法路径？连续执行了 $>9$ 次 $+1$ 操作，就不可能出现在最优路径中。

#### P3403 跳楼机

> 给出 $a,b,c$，问能拼出多少 $\leq p$ 的数。即有多少个 $ax+by+cz=d\,(x,y,z\geq 0,d\leq p)$ 的 $d$。
>
> $1\leq a,b,c\leq 10^5$，$p<2^{63}$。

我们把所有满足条件的 $d$ 在 $\bmod c$ 意义下划分：

- $+c$ 本身不改变其于余数。

  如果 $d'$ 能拼，那么 $d'+c,d'+2c,\cdots$ 都能拼。

  只需要知道在某个等价类中的第一个元素。

对于余数 $k$，连 $(k\to (k+a)\bmod c,a),(k\to (k+b)\bmod c,b)$。

对于余数 $k$，第一个元素是 $d_k$，在范围内的元素数目为 $\lfloor\frac{p-d_k}{c}\rfloor+1$。

### 差分约束

> 有 $n$ 个变量 $x_{1\sim n}$ 和 $m$ 个形如 $x_{u_i}-x_{v_i}\leq c_i$ 的约束，求一组可行解。

$x_{v_i}+c_i\geq x_{u_i}$，连 $(v_i\to u_i,c_i)$，令 $x_i$ 为 $d_i$，则在 $s$ 可达 $v_i$ 的前提下符合该约束。

把所有约束都以边的形式加进图。可达性问题：建立超级源连向每个点。如果到每个点的最短路存在，那么所有约束必成立。什么是最短路不存在？图中有负环。

变形：

- $x_i-x_j\leq z$：连 $(j\to i,z)$。
- $x_i-x_j\geq z$：连 $(i\to j,-z)$。
- $x_i-x_j=z$：连 $(j\to i,z),(i\to j,-z)$。


### 综合练习

#### QOJ#9108. Zayin and Obstacles

> 一个 $n\times n\times n$ 的三维空间，有 $m$ 个立方体障碍，求从一个点到另一个点的最短路。
> 
> $1\leq T\leq 5$，$1\leq n\leq 100$，$1\leq m\leq 1000$。

??? note "解答"

    BFS 求最短路。用三维差分和三维前缀和标记障碍。
    
    二维前缀和？
    
    法 1：
    
    ```cpp
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
             b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
    ```
    
    法 2：
    
    ```cpp
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) a[i][j]+=a[i][j-1];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) a[i][j]+=a[i-1][j];
    ```
    
    三维前缀和？
    
    法 1：
    
    ```cpp
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=1;k<=p;k++)
                  b[i][j][k]=b[i-1][j][k]+b[i][j-1][k]+b[i][j][k-1]
                                -b[i-1][j-1][k]-b[i-1][j][k-1]-b[i][j-1][j-1]
                                +b[i-1][j-1][k-1]+a[i][j][k];
    ```
    
    其实就是容斥。
    
    $t$ 维前缀和：$S(x_1,\cdots,x_t)=\sum_{T\subseteq\{1,2,\cdots,t\},T\neq \varnothing}(-1)^{|T|-1}S(x_1-[1\in T],\cdots,x_t-[t\in T])+A(x_1,\cdots,x_t)$
    
    但是，随着维度 $t$ 变高，容斥的复杂度是 $2^t$，总复杂度 $O(n^t\times 2^t)$。
    
    法 2：
    
    ```cpp
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=1;k<=p;k++) a[i][j][k]+=a[i-1][j][k];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=1;k<=p;k++) a[i][j][k]+=a[i][j-1][k];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=1;k<=p;k++) a[i][j][k]+=a[i][j][k-1];
    ```
    
    对每个维度，依次对该维度执行“一维前缀和”操作。
    
    对于 $t$ 维，时间复杂度 $\mathcal O(n^t\times t)$。
    
    二维差分？
    
    ```cpp
    d[x1][y1]+=v;
    d[x1][y2+1]-=v,d[x2+1][y1]-=v;
    d[x2+1][y2+1]+=v; 
    ```
    
    三维差分？
    
    ```cpp
    //[a,d]*[b,e]*[c,f] 三维差分
    s[a][b][c]+=v;
    s[d+1][b][c]-=v,s[a][e+1][c]-=v,s[a][b][f+1]-=v;
    s[d+1][e+1][c]+=v,s[a][e+1][f+1]+=v,s[d+1][b][f+1]+=v;
    s[d+1][e+1][f+1]-=v;
    ```
    
    $t$ 维空间，更新超矩形区域（每个维度 $i$ 范围 $[a_i,b_i]$）：$2^t$ 个顶点，每个顶点在维度 $i$ 上的坐标为 $a_i$ 或 $b_i+1$。对每个顶点，统计其取 $b_i+1$ 的维度数量 $k$，则该顶点的更新量为 $v\times (-1)^k$。
    
    ??? info "高维前缀和与高维差分"
    
        $[0,1]\times [0,1]\times \cdots\times [0,1]$ 空间的高维前缀和（状压）：
    
        ```cpp
        for(int i=0;i<n;i++)	//枚举每一维
            for(int j=0;j<(1<<n);j++)
                if(j>>i&1) s[j]+=s[j^(1<<i)]; 
        ```
    
        高维差分：
    
        ```cpp
        for(int i=0;i<n;i++)	//枚举每一维
            for(int j=0;j<(1<<n);j++)
                if(j>>i&1) s[j]-=s[j^(1<<i)]; 
        ```

#### 一个例题

> 给出一个 $n\times m$ 的网格图，每个格子可能是空地或者障碍。求每个障碍分别能到达多少个空地（四连通）。
> 
> $n,m\leq 1000$。

??? note "解答"

	给每个空地连通块标号。一个障碍能到它上下左右的空地连通块。
	
	时间复杂度 $\mathcal O(nm)$。

#### CF416E President's Path（\*2500）

> 给出一张 $n$ 个点 $m$ 条边的无向图。对任意点对 $(s,t)$，求有多少条边在至少一条 $s\leadsto t$ 的最短路上。
> 
> $1 \leq n \leq 500, 1\leq m \leq \frac{n(n+1)}{2}$。

边 $(x,y,w)$ 存在于点 $(s,t)$  间的最短路中的充要条件为 $\min(d_{s,x}+d_{y,t},d_{s,y}+d_{x,t})+w=d_{s,t}$。

Floyd 求出 $d$ 后枚举点对 $s,t$ 和边 $(x,y,w)$，复杂度 $\mathcal O(n^4)$。

考虑枚举中间点。

- 我们想要一次性起到枚举以该点结尾的所有边的效果。

  倘若 $p$ 在 $s\leadsto t$ 的最短路上，则 $d_{s,p}+d_{p,t}=d_{s,t}$，那么我们可以一次性加上以 $p$ 点结尾的在 $s\leadsto p$ 最短路上的边，这样加边显然是不重不漏的；同样地，如果 $p$ 不在 $s\leadsto t$ 的最短路上，那么所有以 $p$ 结尾的边均不会在 $s\leadsto t$ 的最短路上。

- 如何对每个 $p$ 求出 $s\leadsto p$ 最短路上以 $p$ 结尾的边数 $cnt_p$？此时这个量与 $t$ 无关，枚举 $s$，枚举每条边 $(x,y)$，若 $(x,y)$ 在 $s\leadsto y$ 的最短路上，$cnt_y$ 加 $1$ 即可。

  然后枚举 $t$，枚举 $p$，若 $p$ 在 $s\leadsto t$ 的最短路上，将 $cnt_p$ 计入答案。

时间复杂度 $\mathcal O(n^3)$。

#### [NEERC2017]Journey from Petersburg to Moscow

> 给出一张 $n$ 个点 $m$ 条边的无向图，定义一条路径的长度为其中前 $k$ 大的边权之和。求 $1\leadsto n$ 的最短路。
>
> $2\leq n\leq 3000$，$1\leq m\leq 3000$，$1\leq k<n$。

枚举第 $k$ 大的边权 $v$，将边权改为 $\max(w_i-v,0)$，跑普通最短路，答案为 $dis_{1,n}+v\cdot k$。

设改完边权后最短路上边权集合为 $W$。

若 $W$ 的前 $k$ 大有 $0$（也就是选了 $<k$ 条边权 $\geq v$ 的边），那么把前 $k$ 大边权加上 $v$ 后，会有一些原本 $\leq v$ 的边权被抬到 $v$。因此该答案会被 $v$ 更小的方案覆盖掉。

若 $W$ 的第 $k+1$ 大不是 $0$（也就是选了 $>k$ 条边权 $\geq v$ 的边），那么把前 $k$ 大边权加上 $v$ 后，会有一些不是前 $k$ 大但被算进答案的边。因此该答案会被 $v$ 更大的方案覆盖掉。

实际上 $v$ 可以三分，这样就能做到更优复杂度。

时间复杂度 $\mathcal O(n\log n\log m)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e3+5;
int n,m,k,x,y,z,v[N],cnt,a[N];
ll d[N],v1,v2,ans=1e18;
vector<pair<int,int> >g[N];
priority_queue<pair<ll,int> >q;
ll dij(int w){
	for(int i=1;i<=n;i++) d[i]=1e18,v[i]=0;
	q.push({d[1]=0,1});
	while(q.size()){
		int x=q.top().second;q.pop();
		if(v[x]) continue; v[x]=1;
		for(auto p:g[x]){
			int y=p.first,z=max(p.second-w,0);
			if(d[y]>d[x]+z) d[y]=d[x]+z,q.push({-d[y],y});
		}
	}
	return d[n]+1ll*k*w;
}
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z),a[i]=z;
		g[x].push_back({y,z}),g[y].push_back({x,z});
	}
	sort(a+1,a+1+m),cnt=unique(a+1,a+1+m)-a-1;
	int l=0,r=cnt;
	while(l+3<=r){
		int m1=l+(r-l)/3,m2=m1+(r-l)/3;
		if(dij(a[m1])<dij(a[m2])) r=m2;
		else l=m1; 
	}
	for(int i=l;i<=r;i++) ans=min(ans,dij(a[i]));
	printf("%lld\n",ans);
	return 0;
}
```

#### HDU 4479 Shortest path

> 给出一张 $n$ 个点 $m$ 条边的有向带权图。求 $1\leadsto n$ 的所有边权严格递增的路径中，边权和最小的其中一条。
> 
> $1\leq n,m\leq 10^5$。

按边权从小到大的顺序松弛。边权相同的一起做。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4+5,M=5e4+5;
int t,n,m;
ll d[N];
struct E{
	int x,y,z;
}e[M];
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)
			scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
		sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
		fill(d+1,d+1+n,1e18),d[1]=0;
		for(int l=1,r;l<=m;l=r+1){
			r=l;
			while(r<m&&e[r+1].z==e[l].z) r++;
			vector<pair<int,ll> >v;
			for(int i=l;i<=r;i++){
				int x=e[i].x,y=e[i].y,z=e[i].z;
				if(d[x]<1e18&&d[y]>d[x]+z) v.push_back({y,d[x]+z});
				if(d[y]<1e18&&d[x]>d[y]+z) v.push_back({x,d[y]+z});
			}
			for(auto p:v) d[p.first]=min(d[p.first],p.second);
		}
		if(d[n]<1e18) printf("%lld\n",d[n]);
		else puts("No answer");
	}
	return 0;
} 
```

### ※ 删边最短路

> 给出一张 $n$ 个点 $m$ 条边正权 **无向图**，以及一条 $1\leadsto n$ 的最短路径 $e_1,e_2,\cdots,e_k$（指定最短路径）。
>
> 对每个 $i$ 求删去 $e_i$ 后的最短路长度。
>
> $n,m\leq 2\times 10^5$。

容易想到，删去一条边后，新的最短路和原来的最短路是有很多边重合的。

进一步可以发现，新的最短路一定可以表示成，一段指定最短路径的前缀 + 一段非最短路径 + 一段指定最短路径的后缀：首先不会走回头路。并且由于只删了一条边，如果有多段非最短路径，其他不包含所删边的非最短路径都能替换为一段指定最短路径。

假如求出一棵包含指定路径的最短路树，则总存在只用到一条非树边的答案：删去一条边后最短路树被分为两个连通块，解中不存在一条非树边 $(x,y)$ 连接两个连通块。

枚举 $(x,y)$，用 $\min(d_{1,x}+d_{y,n},d_{1,y}+d_{x,n})+w_{x,y}$ 更新最短路树上 $(x\leadsto y)\cap(1\leadsto n)$ 上边的答案即可。

可以扩展到求删去任意一条边后的最短路：CF1163F。

### 结合 DP

#### [NOIP2017 提高组] 逛公园（较短路计数）

> 给出一张 $n$ 个点 $m$ 条边的图，问 $1\leadsto n$ 与最短路的差不超过 $k$ 的路径有多少条。
> 
> 可能有 $0$ 边，如果数量无限输出 $-1$。
> 
> $n\leq 10^5$，$m\leq 2\times 10^5$，$k\leq 50$。

首先从 $1$ 出发跑一遍最短路，得到数组 $dis$。

一看 $k$ 这么小，我们就设 $f_{i,j}$ 表示从 $1$ 到 $i$，与最短路的差等于 $j$ 的有多少条。

$f_{u,d}\gets f_{v,d'}$，其中 $d'$ 满足 $dis_v+d'+w=dis_u+d$，即 $d'=dis_u-dis_v+d-w$。

注意特判 $-1$ 的情况，出现 $-1$ 需要满足存在 $0$ 环并且存在经过这个 $0$ 环的满足条件的路径。

可以记搜实现，如果搜到 $f_{u,d}$ 之后继续搜，再次搜到 $f_{u,d}$ 意味着搜到了 $0$ 环。

#### CF1693C Keshi in Search of AmShZ（\*2300）

> 给出一张 $n$ 个点 $m$ 条边的有向图。每一时刻，可以做以下两件事之一：
>
> - 删去图中的一条边。
> - 在目前 $x$ 的出边中随机一条走过去。
>
> 求从 $1$ 出发，在最坏情况下到达 $n$ 的最早时刻。
>
> $2\leq n\leq 2\times 10^5$，$1\leq m\leq 2\times 10^5$。

结论：1. 我们不会重复经过点。2. 只需要考虑在点上删该点出边。

设 $f_x$ 表示 $x\leadsto n$ 在最优策略中、最坏情况下的时间。

$f_x=\min\limits_{(x\to y)\in E}\{f_y+$ 为此需要删的边数 $+1\}$：为了在最坏情况下也能抵达，需要把连向比 DP 值更大的 $y'$ 的边都删去。用 dij 模拟这一过程：每条边有多少条比它优的出边在处理到它时已经确定。

### ※ 结合分治

#### ※ 一个例题

> 给出一张 $n$ 个点的无向图，对于任意三元组 $(a,b,c)$，求 $a\to b$ 不经过点 $c$ 的最短路。
>
> $n\leq 300$。

$(a,b,c)$ 的答案：Floyd 中 $k=c$ 时跳过。

对于每个 $c$ 需要做 $\mathcal O(n)$ 个枚举 $k$，然而其中大部分都是重复的。

用分治减少冗余（类似缺一背包）。分治区间表示没加入的 $k$，$l=r$ 时就是 $c=l$ 的答案。

时间复杂度 $\mathcal O(n^3\log n)$。

#### ※ P3350 [ZJOI2016]旅行者

> 给出一张 $n\times m$ 的正权边网格图，$q$ 次询问两点间的最短路。
>
> $n\times m\leq 10^4$，$q\leq 10^5$。


## 二、最小生成树

### 基础算法

#### Prim

类比 Dijkstra 算法，我们维护一个集合 $S$，表示这个集合中的生成树已经确定了。每次加入一个与当前 MST “最近”的。

$d_i$ 表示 $i$ 的邻边中，另一端在 MST 中且边权最小的那条，若没有就是 $\infty$。每次选一个 $d_i$ 最小的点，将其与这条边加入 MST，并更新其他点的 $d$。初始时随便选一个点即可。

时间复杂度 $\mathcal O(n^2)$。同样可以用堆优化。

```cpp
void prim(){
	for(int i=1;i<=n;i++) d[i]=1e9,v[i]=0;
	d[1]=0; 
	for(int i=1;i<n;i++){
		int x=0;
		for(int j=1;j<=n;j++)
			if(!v[j]&&(!x||d[j]<d[x])) x=j;
		v[x]=1;
		for(int y=1;y<=n;y++)
			if(!v[y]) d[y]=min(d[y],a[x][y]);
	}
}
```

#### Kruskal

用贪心的思路，把所有的边权从小到大排序，然后一条一条尝试加入，用并查集维护连通性。

可以发现这样一定能得到原图的最小生成树，证明：按边权从小到大枚举所有边，假设某个时刻可以加入 $(u,v)$（即 $u,v$ 不连通）却选择不加入，最终得到了一棵最小生成树。考虑这棵最小生成树上 $u\leadsto v$ 的路径，这上面一定有一条边权 $\geq w_{u,v}$ 的边，用 $(u,v)$ 替换它答案一定不会变劣。

时间复杂度 $\mathcal O(m\log m)$。

#### ※ Boruvka

第三种求最小生成树的算法。

我们维护当前形成的所有连通块，接下来对于每一个连通块，找到边权最小的出边，然后合并两个连通块。

不断重复这个操作，直到整张图变成一个连通块。

由于每次操作连通块数量至少减半，所以时间复杂度最坏为 $\mathcal o((n+m)\log n)$，随机图的话复杂度能更低。

### ※ Kruskal 重构树

Kruskal 重构树是基于 Kruskal 最小生成树的一种算法，它主要通过将边权转化为点权来实现。

这个算法的流程如下：

- 将所有边按照边权排序，设 $r(x)$ 表示 $x$ 所在连通块的根节点（用并查集维护）。
- 枚举所有的边 $(u,v)$，若 $u,v$ 不连通，则：
	- 新建一个点 $x$，令 $x$ 的权值为 $w_{u,v}$，连接 $(x,r(u))$ 和 $(x,r(v))$，然后令 $r(u)=r(v)=x$。
	不断重复以上过程，直到所有点均连通。

时间复杂度 $\mathcal O(m\log m)$。

这样，我们就得到了一棵 $2n-1$ 个节点的二叉树，其中叶节点为原图中的点，其余的点代表原图中的边，并且满足父节点权值大于等于子节点。

它有什么用呢？

- 求 $u,v$ 之间路径上的最大边权 → 求重构树上 $u,v$ 两个点的 LCA 的点权
- 只保留边权 $\leq x$ 的边形成的树 → 重构树上点权 $\leq x$ 的点的子树
- ……

#### ※ [NOI2018] 归程

> 给出一张 $n$ 个点 $m$ 条边的无向连通图，每条边有长度 $d$ 和海拔 $h$。$q$ 次询问，每次给出 $x,p$，设从 $x$ 出发只经过海拔 $>p$ 的边到达的点集为 $S$，求 $S$ 中点到 $1$ 最短路长度的最小值。
>
> $T\leq 3$，$n\leq 2\times 10^5$，$m,q\leq 4\times 10^5$，$l\leq 10^4$，$h\leq 10^9$，强制在线。

由于终点都是 $1$，可以先 dijkstra 求出 $1$ 到每个点的距离 $d_i$，那么答案就是 $x$ 能到达的点中 $d$ 的最小值，显然可以 Kruskal 重构树解决，记录子树最小值即可。

时间复杂度 $\mathcal O(Tn\log n)$。

#### ※ 一个例题

> 给出一棵 $n$ 个点的树，边有边权。定义一个点的权值为其到其他所有节点的路径上最小边权之和，求权值最大的点。
> 
> $n\leq 10^5$。

Kruskal 重构树，变成二叉树

LCA 处考虑

静态

可差分数组上打标记再前缀和，不需树状数组

### 非树边应用

#### 最小生成树唯一性

> 判断 MST 的唯一性。

枚举非树边，判断其覆盖的树边路径上是否存在于它权值相等的边。

（MST 性质：非树边权值 $\geq$ 对应路径上边的权值）

#### 次小生成树

最小生成树替换一条边

非严格次小生成树？严格最小生成树？

非严格次小生成树为 MST 加上某条非树边 $(u,v)$，再删去最小生成树上 $u\leadsto v$ 的边权最大的边。

证明：次小生成树肯定包含某条非树边 $(u,v)$。把 $(u,v)$ 提前加入生成树，再跑 Kruskal，所有树边中，只有 $u\leadsto v$ 的边权最大的边无法加入。

P4180 [BJWC2010] 严格次小生成树

> 严格次小生成树。
>
> $n\leq 10^5$，$m\leq 3\times 10^5$，$0\leq w_i\leq 10^9$。

枚举非树边，若其权值 $>$ 路径 $\max$ 则能替换路径上的最大边，若其权值 $=$ 路径 $\max$ 则替换路径上的严格次大边。路径最大和次大可以倍增，路径 $(x,y)$ 拆成 $(x,\text{lca}),(\text{lca},y)$。

#### 最小生成基环树

> 最小生成基环树。

MST + 一条权值最小的非树边。

#### 一个例题

> 对于一张 $n$ 个点 $m$ 条边的无向图，对每一条边，都求一个最大权值 $k$，使得如果把这条边的权值改为 $k$（而其他边的权值不变），整个图的任意一棵 MST 上都有这条边。
>
> $n,m\leq 10^5$。

先任意求一棵 MST。

非树边？路径最大值 $-1$。

树边？只要它不能被非树边替换即可。所有覆盖它的非树边的最小值 $-1$。路径取 $\min$ 可以倍增（先转化成祖孙链 update。由于只要查询长度是 $1$ 的段，只要打完大的段然后把标记往下推即可）/树剖。

### 最小瓶颈

#### 最小瓶颈生成树

最小生成树一定是最小瓶颈生成树（而最小瓶颈生成树不一定是最小生成树）

关于最小生成树一定是瓶颈生成树这一命题，可以运用反证法证明：我们设最小生成树中的最大边权为 $w$，如果最小生成树不是瓶颈生成树的话，则瓶颈生成树的所有边权都小于 $w$，我们只需删去原最小生成树中的最长边，用瓶颈生成树中的一条边来连接删去边后形成的两棵树，得到的新生成树一定比原最小生成树的权值和还要小，这样就产生了矛盾。

#### 最小瓶颈路

无向图 $u\leadsto v$ 的最小瓶颈路的最大边权 → 最小生成树上 $u\leasdto v$ 的最大边权

###### [NOIP2013] 货车运输

> 给出一张 $n$ 个点 $m$ 条边的图，每条边有一个限重。
> 
> $q$ 次询问，每次给出 $u,v$，问 $u\leadsto v$ 在不超过限重的情况下，重量最大可以是多少。
> 
>  $n\leq 10^4$，$m\leq 5\times 10^4$，$q\leq 3\times 10^4$。

按照限重求一个最大生成树，接下来每次询问等价于求一条链上的最小值。树上倍增即可。

时间复杂度 $\mathcal O(n\log n)$。

也可以用 Kruskal 重构树，建出来重构树之后每次询问等价于求 LCA。时间复杂度还是 $\mathcal O(n\log n)$。

###### P3684 [CERC2016] 机棚障碍 Hangar Hurdles

> 有一个 $n\times n$ 的网格图，上面有些格子可行，有些格子是障碍。
>
> 规定箱子是一个奇数边长的正方形，其坐标为其中心格点的坐标。
>
> $q$ 次询问想把一个箱子从 $(r_1,c_1)$ 推到 $(r_2,c_2)$，箱子最大的大小。
>
> $2\leq n\leq 10^3$，$1\leq q\leq 3\times 10^5$，$1\leq r_1,c_1,r_2,c_2\leq n$。

首先求出以每个格子为中心最大的箱子能有多大，转化为：求一条路径，使得路径上的最小值最大。

### ※ 最小直径生成树

BZOJ2180 最小直径生成树

> 给出一张 $n$ 个点 $m$ 条边的无向图，边有边权，求一棵生成树 $T$，使得 $T$ 的直径最小。输出这个直径。
>
> $1\leq m\leq 10^3$，$0\leq w_i\leq 10^3$。

### 建图练习

#### 水电厂建立问题

#### 一个例题

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有点权 $a_i$。对于生成树 $T$，设 $deg_x$ 表示 $x$ 在 $T$ 中的度数，定义 $T$ 的权值为 $\sum_x a_x\cdot deg_x$。求 MST。

$\sum_x a_x\cdot (\sum_{(x,y)\in T}1)=\sum_{(x,y)\in T}a_x+a_y$。令 $w(x,y)=a_x+a_y$ 求 MST 即可。


### 综合练习

#### CF1242B 0-1 MST（\*1900）

> 一个 $n$ 个点的无向完全图，边权为 $0$ 或 $1$。边权为 $1$ 的边有 $m$ 条。求 MST。
>
> $1\leq n\leq 10^5$，$0\leq m\leq \min(\frac{n(n-1)}{2},10^5)$。

初步转化：根据 Kruskal 的思想，先连 $0$ 再连 $1$，如果能维护 $0$ 边构成的连通块，答案就是连通块数 $-1$。

枚举每个点尝试将它加入到之前的 $0$ 连通块，加不了就新建一个连通块。有 $0$ 边相连 $\Leftrightarrow$ 不全是 $1$ 边。

枚举之前连通块的复杂度？如果枚举到的连通块有 $1$ 边相连，$1$ 边总量是 $m$ 所以这部分复杂度 $\mathcal O(m)$；若没有，就直接 merge 了，而 merge 的过程最多进行 $n-1$ 次，这部分 $\mathcal O(n)$。所以复杂度正确。

#### CF76A Gift（\*2200）

> 给出一张 $n$ 个点 $m$ 条边的无向图，每条边有属性 $(g_i,s_i)$。给定 $G,S$，求一棵图的生成树 $T$ 最小化 $G\times \max\limits_{i\in T}(g_i)+S\times \max\limits_{i\in T}(s_i)$。
>
> $2\leq n\leq 200$，$1\leq m\leq 5\times 10^4$，$1\leq G,S,g_i,s_i\leq 10^9$，2s。

先将所有边按 $g$ 排序，依次加入每条边。这样加入 $g_i$ 时，就固定了 $g_i$ 是最大值。

暴力：将已加入的边按 $s_i$ 求最小瓶颈生成树（也就是 MST）。时间复杂度 $\mathcal O(m^2\log m)$。

优化：每次新加一条边时，只需将加这条边之前的 MST 的 $n-1$ 条边与这条边结合，计算新的 MST。时间复杂度 $\mathcal O(mn\log n)$。可以优化成 $\mathcal O(mn\alpha)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=210,M=5e4+5;
int n,m,G,S,f[N],t,t2;
long long ans=8e18;	//坑：1e18 不够
struct E{
    int x,y,g,s;
}e[M],a[M],b[M];
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
signed main(){
    scanf("%d%d%d%d",&n,&m,&G,&S);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].g,&e[i].s);
    sort(e+1,e+1+m,[](E x,E y){return x.g<y.g;});
    for(int i=1;i<=m;i++){
        int cnt=t,mx=0;
        copy(a+1,a+1+t,b+1),b[++cnt]=e[i];
        sort(b+1,b+1+cnt,[](E x,E y){return x.s<y.s;});
        iota(f+1,f+1+n,1),t=0;
        for(int j=1;j<=cnt;j++){
            int x=find(b[j].x),y=find(b[j].y);
            if(x!=y) f[y]=x,a[++t]=b[j],mx=max(mx,b[j].s);
        }
        if(t==n-1) ans=min(ans,1ll*G*e[i].g+1ll*S*mx);
    }
    printf("%lld\n",ans<8e18?ans:-1);
    return 0;
}
```

#### HDU7226 Darnassus

> 给出一个排列 $p_{1\sim n}$，建一张 $n$ 个点的完全图，$(i,j)$ 的边权为 $|i-j|\times|p_i-p_j|$，求这张图的 MST。
>
> $1\leq T\leq 5$，$1\leq n\leq 5\times 10^4$。

完全图的 MST 不要只想着 Boruvka！

想想“排列”的用意？值域小！只考虑边 $(i,i+1)$，这样生成树每条边的边权都 $\leq n$，因此存在一种 MST 也只有边权 $\leq n$ 的边。那么与 $i$ 相连的有向边就只有 $\mathcal O(\sqrt{n})$ 条了。

#### CF891C Envy（\*2300）

> 给出一张 $n$ 个点 $m$ 条边的无向连通图。每次询问给一个边集，问这些边能否出现在同一棵 MST 中。
> 
> $n,m,\sum |S|\leq 5\times 10^5$。

一张图上的最小生成树的性质：

- 对于任意权值的边，所有最小生成树中这个权值的边的数量是一定的
- 对于任意正确加边方案，加完小于某权值的所有边后图的连通性是一样的

所以对于不同权值的边，它们是否同时出现在最小生成树中是互不影响的。所以对于每组询问，我们只需要判断相同权值的边是否能同时出现在最小生成树中即可。

对于每组询问，我们分开考虑，每次只考虑一种权值的边。对于所有权值为 $w$ 的边，我们需要把原图中所有权值小于 $w$ 的边加进去（并查集），然后依次加询问中权值为 $w$ 的边，看是否有环。

加原图中的边时我们不能暴力加边。在询问之前，预处理出每种权值的边在加完小于该权值的边时，它的两个端点分别属于哪个集合。

#### ※ 最大曼哈顿距离生成树

> 给出平面上 $n$ 个点，两个点之间的距离定义为曼哈顿距离，求这 $n$ 个点的最大生成树。
>
> $n\leq 2\times 10^6$。

考虑 Prim，只需快速求出当前树与未连接点中的距离最大值（也可以 Boruvka，本质是一样的）。

一个经典的转化是，$a,b$ 的曼哈顿距离是四种给 $x_a,x_b,y_a,y_b$ 赋正负号的方案中带权和最大的，与求最大值的目标“同向”。用堆分别维护四种情况即可，时间复杂度 $\mathcal O(n\log n)$。

方法 2：

有一个套路：曼哈顿转切比雪夫。

两个点的切比雪夫距离定义为 $\max(|x_1-x_2|,|y_1-y_2|)$。

曼哈顿转切比雪夫：对于一个点 $(x,y)$，我们把它变成 $(x+y,x-y)$ 即可。

对于一个连通块，我们希望求出离它最远的点。容易发现，最远的点只有可能个是横/纵坐标最小/大的点，直接记录一下四个方向的最大值和次大值即可。

如果用 Boruvka 的话，时间复杂度其实是 $\mathcal O(n)$ 的，因为合并次数是 $\mathcal O(1)$ 的。

