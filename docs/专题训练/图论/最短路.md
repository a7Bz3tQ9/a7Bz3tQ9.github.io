## 基础算法

### Dijkstra

**在所有边权均为正的情况下**，我们可以使用 Dijkstra 算法求出一个点到所有其他点的最短路。**注意在此情况下不能求最长路。**

我们维护一个集合，表示这个集合内的点的最短路已经确定了。

每次从剩下的点中选择当前距离最小的点 $u$ 加入这个集合，然后枚举另一个点 $v$ 进行更新：$d_v\gets \min(d_v,d_u+w_{u,v})$。

直接这样做时间复杂度是 $\mathcal O(n^2)$ 的。

我们注意到，复杂度主要来源于两个地方。第一个是找出当前距离最小的点，这个用堆很容易实现。第二个是枚举 $v$，可以邻接表存图降到边数级别。

这样就把复杂度降到了 $\mathcal O(m\log m)$。

### Bellman-Ford

另一种求单源最短路的算法。边权可正可负。

考虑在上面出现过的松弛操作：$d_v=\min(d_v,d_u+w_{u,v})$。由于最短路径只会经过最多 $n$ 个点，因此每一个点的最短路径只会被松弛至多 $n-1$ 次。

所以我们可以对整张图进行 $n-1$ 次松弛操作，每次枚举所有的边进行更新。（初始只有 $d_S$ 正确，进行 $k$ 轮松弛后，所有边数 $\leq k$ 的路径都被考虑到。所以若存在最短路，至多松弛 $n-1$ 轮）

时间复杂度 $\mathcal O(nm)$。

- 判负环：若进行 $n-1$ 轮后，仍然有边能松弛，则必存在一个 $S$ 能抵达的负环。

### SPFA

Bellman-Ford 的改进版。边权可正可负。

注意到，在进行松弛操作的时候，如果点 $u$ 的最短路一直没有变化，那么就不需要再枚举这个点的出边进行松弛了。

也就是说我们可以用一个队列保存所有距离发生变化的点，每次取出一个点进行更新。

如果图是随机的，SPFA 非常优秀，而且还可以有负权。

但是在最坏情况下它的复杂度和 Bellman-Ford 相同，都是 $\mathcal O(nm)$。

### Floyd

全源最短路。边权可正可负。

用 DP 的思想，设 $f_{k,i,j}$ 为仅允许途经 $[1,k]$ 中节点时，$i\leadsto j$ 的最短路长度。

由于每个点在最短路中只会出现一次（不然就出现负环了，不存在最短路），所以可以写出转移方程：$f_{k,i,j}\gets\min(f_{k-1,i,j},f_{k-1,i,k}+f_{k-1,k,j})$。

时间复杂度 $\mathcal O(n^3)$。

实际上第一维可以省去，所以空间复杂度 $\mathcal O(n^2)$。

**注意三层循环的顺序不能颠倒**（如果是 $f_{i,j}\gets \min(f_{i,j},f_{i,k}+f_{k,j})$ 的话，$k$ 必须第一层循环枚举）。

- 判负环：Floyd 后判是否存在 $f_{i,i}<0$ 即可。如果要求的是从某一点 $s$ 是否有可达负环，根据 $f_{i,i}<0$ 确定负环上的点，再做一遍连通性 BFS 即可。

- Floyd 变种之传递闭包：

    有时候我们需要维护一些有传递性的关系，比如相等、连通等等。

    初始条件往往是已知若干个点对具有这些关系，然后让你求出来所有的关系。

    可以直接把 Floyd 算法做一下调整：`f[i][j]=f[i][j]|(f[i][k]&f[k][j])`。这个算法叫传递闭包。

    可以 bitset 优化：`if(f[i][k]) f[i]|=f[k];`。时间复杂度 $\mathcal O(\frac{n^3}{\omega})$。

- Floyd 另一个变种：给出一个有向图，求两两点对之间的一条路径，使得边权最大值最小。（BZOJ1641 Cow Hurdles 奶牛跨栏）

    把加法改成取 $\max$ 就行。

- ※ 广义矩乘优化 Floyd：可以倍增优化转移，把经过 $k$ 条边改为经过 $2^k$ 条边。
	
	??? info "※ 一个例题"
		
        CF147B Smile House（\*2500）
        
        > 给出一张 $n$ 个点 $m$ 条边的有向图，边有边权，问最小的正环的大小。这里最小正环指的是包含的点数最少。
        >
        > $1\leq n\leq 300$，$0\leq m\leq\frac{n(n-1)}{2}$，$-10^4\leq w_{i,j}\leq 10^4$。
        
        设 $f_{i,j,k}$ 表示 $i\leadsto j$ 经过 $\leq k$ 条边的最大边权和。可以倍增优化转移，把经过 $k$ 条边改为经过 $2^k$ 条边。
        
        然后用倍增定位到最小的正环：如果再走 $\leq 2^x$ 步仍然都是负环没有正环，就给答案 $+2^x$。check 是否有正环就看是否存在 $f_{x,i,i}>0$。
        
        时间复杂度 $\mathcal O(n^3\log n)$。
        
        ```cpp
        #include<bits/stdc++.h>
        using namespace std;
        const int N=310;
        int n,m,x,y,ans;
        struct mat{
            int x[N][N];
            mat(){memset(x,-0x3f,sizeof(x));}
            friend mat operator*(mat a,mat b){
                mat c;
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=n;j++){
                        c.x[i][j]=max(a.x[i][j],b.x[i][j]);
                        for(int k=1;k<=n;k++)
                            c.x[i][j]=max(c.x[i][j],a.x[i][k]+b.x[k][j]);
                    }
                return c;
            }
        }f[15],cur,tmp;
        signed main(){
            scanf("%d%d",&n,&m);
            for(int i=1;i<=m;i++)
                scanf("%d%d",&x,&y),scanf("%d%d",&f[0].x[x][y],&f[0].x[y][x]);
            for(int i=1;i<=9;i++) f[i]=f[i-1]*f[i-1];
            for(int i=1;i<=n;i++) cur.x[i][i]=0;
            for(int i=9;i>=0;i--){
                tmp=cur*f[i];
                bool ok=1;
                for(int j=1;j<=n;j++) ok&=tmp.x[j][j]<=0;
                if(ok) ans+=1<<i,cur=tmp;
            }
            ans++,printf("%d\n",ans>n?0:ans);
            return 0;
        }
        ```

- ※ 最小正权环：

    > 给出一张无向正权图，求图中最小环。

    最小环必定是简单环。

    考虑环上最大点 $k$ 和任意其他两点 $i,j$，最小环必能被分割成 $f_{k-1,i,j}+f_{k-1,i,k}+f_{k-1,k,j}$。但可能会退化成路径！

    于是改为：考虑环上最大点 $k$ 和其相邻两点 $i,j$，最小环必能分割成 $f_{k-1,i,j}+w_{i,k}+w_{k,j}$。

    时间复杂度 $\mathcal O(n^3)$。

    ??? info "※ 拓展（无权无向图最小环更优做法）"

        事实上，无权无向图最小环（保证环上至少有 $3$ 个点）可以做到 $\mathcal O(n(n+m))$。
        
        枚举 $S$，求出以 $S$ 为根的一棵 bfs 生成树，对于一条非树边 $(x,y)$，我们就找到了一个环，$\text{chkmin}(ans,d_x+d_y+1)$ 即可（$d_x$ 表示 $dis_{S,x}$。生成树的好处是，非树边与所覆盖的树边构成环。bfs 树的好处是，树边走的都是最短路）。
        
        正确性：因为若 $d_x,d_y$ 对应路径有交则不优，并且最小环一定会被算到。
        
        实现：从 $S$ 开始 bfs。每次取出 queue 的 front $x$，枚举 $y\in N(x)$，若 $d_y$ 未赋值，找到了一条树边，$d_y=d_x+1$；否则，找到了一条非树边，$\text{chkmin}(ans,d_x+d_y+1)$。
        
        时间复杂度 $\mathcal O(n(n+m))$。
    
### ※ Johnson

对于多源最短路，如果我们枚举一个点然后跑堆优化的 Dijkstra，那么复杂度是 $\mathcal O(nm\log n)$ 的，在图比较稀疏的情况下，这个复杂度要优于 Floyd 算法的 $\mathcal O(n^3)$。

但是 Dijkstra 算法要求所有边权均非负。

于是就有了重赋权的技巧。

我们新建一个 $0$ 号点，并且从这个点出发向所有点连一条边权为 $0$ 的边，然后跑单源最短路（SPFA 或者 Bellman-Ford）。

设距离数组为 $h$，接下来对于每条边 $(u,v)$，令 $w'_{u,v}\gets w_{u,v}+h_u-h_v$。

这样所有的边权就都变成非负了，我们就可以跑 Dijkstra 算法了。

首先由于 $h_v\leq h_u+w_{u,v}$，新图的边权一定非负。

设新图上的最短路径为 $d'$，原图上的最短路径为 $d$。
	
$\begin{aligned}d'_{u,v}&=\min\limits_{a_1,a_2,\cdots,a_k}w'_{u,a_1}+w'_{a_1,a_2}+\cdots+w'_{a_k,v}\\&=\min\limits_{a_1,a_2,\cdots,a_k}w_{u,a_1}+(h_u-h_{a_1})+w_{a_1,a_2}+(h_{a_1}-h_{a_2})+\cdots+w_{a_k,v}+(h_{a_k}-h_v)\\&=h_u-h_v+\min\limits_{a_1,a_2,\cdots,a_k}w_{u,a_1}+\cdots+w_{a_k,v}\\&=h_u-h_v+d_{u,v}\end{aligned}$

## 最短路树、最短路 DAG

所谓最短路树，就是在求完从 $S$ 出发的单源最短路后，只保留最短路上的边形成的树。只需要在求最短路的过程中维护一个 $pre$ 数组表示这个点的前驱即可。

最短路 DAG：包含所有 $S$ 到 $x$ 最短路经过的边。只需求出最短路后，对于边 $(x,y)$，若 $d_x+w{x,y}=d_y$，则保留这条边。

### CF1076D Edge Deletion

> 给出一张 $n$ 个点 $m$ 条边的无向简单带权连通图，要求保留至多 $k$ 条边。定义"好点"是指删边后，节点 $1$ 到它的最短路长度仍然等于原图最短路长度的节点。最大化删边后的好点个数。
> 
> $n,m\leq 3\times 10^5$。

### P2149 [SDOI2009] Elaxia的路线

> 给出一张 $n$ 个点 $m$ 条边的无向图。给定两对点，求两对点分别的最短路的最长公共路径。
> 
> $1\leq n\leq 1500$，$1\leq m\leq 3\times 10^5$，$1\leq w\leq 10^4$。


## 建图练习

### CF938D Buy a Ticket

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有点权 $a_i$。对每个 $i\in[1,n]$，求 $\min\limits_{1\leq j\leq n}\{2\cdot dis(i,j)+a_j\}$。
>
> $1\leq n,m\leq 10^5$。


### 一个例题

> 给出一张 $n$ 个点的图，点有点权 $a_i$。
>
> 若 $a_i\text{ and }a_j\neq 0$，则 $(i,j,\text{lowbit}(a_i\text{ and }a_j))\in E$。求 $d(1,n)$。
>
> $1\leq n\leq 10^5$，$0<a_i<2^{32}$。

### P4366 [Code+#4]最短路

> 给出一张 $n$ 个点的无向图，图中除了一些给出的有向边之外，任意两点 $i,j$ 之间都存在一条边权为 $C\cdot (i\oplus j)$ 的边。求 $dis(s,t)$。
>
> $n\leq 10^5$。


### 多源汇最短路

> 给定点集 $S_1,S_2$，求 $\min\limits_{u\in S_1}\min\limits_{v\in S_2}dis(u,v)$。


### [GXOI/GZOI2019] 旅行者

> 给出一张 $n$ 个点 $m$ 条边的无向带权图，其中有 $k$ 个关键点，求这 $k$ 个关键点间两两最短路的最小值。
>
> $2\leq k\leq n,m\leq 10^5$。


### [JLOI2011] 飞行路线

> 给定一张 $n$ 个点 $m$ 条边的带权无向图，你可以把至多 $k$ 条边的边权变成 $0$，求 $s\leadsto t$ 的最短路。
>
> $2\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$0\leq k\leq 10$。

## 同余最短路

### 一个例题

> 给出 $a_{1\sim n}$，问最少选多少个数使得它们的和 $\bmod p=r$。数字可以重复使用。。

### [ARC084B] Small Multiple

> 问 $n$ 的倍数当中，数位和最小的数是多少。
>
> $n\leq 10^5$。


### P3403 跳楼机

> 给出 $a,b,c$，问能拼出多少 $\leq p$ 的数。即有多少个 $ax+by+cz=d\,(x,y,z\geq 0,d\leq p)$ 的 $d$。
>
> $1\leq a,b,c\leq 10^5$，$p<2^{63}$。

## 差分约束

> 有 $n$ 个变量 $x_{1\sim n}$ 和 $m$ 个形如 $x_{u_i}-x_{v_i}\leq c_i$ 的约束，求一组可行解。

$x_{v_i}+c_i\geq x_{u_i}$，连 $(v_i\to u_i,c_i)$，令 $x_i$ 为 $d_i$，则在 $s$ 可达 $v_i$ 的前提下符合该约束。

把所有约束都以边的形式加进图。可达性问题：建立超级源连向每个点。如果到每个点的最短路存在，那么所有约束必成立。什么是最短路不存在？图中有负环。

变形：

- $x_i-x_j\leq z$：连 $(j\to i,z)$。
- $x_i-x_j\geq z$：连 $(i\to j,-z)$。
- $x_i-x_j=z$：连 $(j\to i,z),(i\to j,-z)$。


## 综合练习

### QOJ#9108. Zayin and Obstacles

> 一个 $n\times n\times n$ 的三维空间，有 $m$ 个立方体障碍，求从一个点到另一个点的最短路。
>
> $1\leq T\leq 5$，$1\leq n\leq 100$，$1\leq m\leq 1000$。

### 一个例题

> 给出一个 $n\times m$ 的网格图，每个格子可能是空地或者障碍。求每个障碍分别能到达多少个空地（四连通）。
>
> $n,m\leq 1000$。


### CF416E President's Path（\*2500）

> 给出一张 $n$ 个点 $m$ 条边的无向图。对任意点对 $(s,t)$，求有多少条边在至少一条 $s\leadsto t$ 的最短路上。
>
> $1 \leq n \leq 500, 1\leq m \leq \frac{n(n+1)}{2}$。

### CF1650G Counting Shortcuts



### ※ [NEERC2017]Journey from Petersburg to Moscow

> 给出一张 $n$ 个点 $m$ 条边的无向图，定义一条路径的长度为其中前 $k$ 大的边权之和。求 $1\leadsto n$ 的最短路。
>
> $2\leq n\leq 3000$，$1\leq m\leq 3000$，$1\leq k<n$。


### HDU 4479 Shortest path

> 给出一张 $n$ 个点 $m$ 条边的有向带权图。求 $1\leadsto n$ 的所有边权严格递增的路径中，边权和最小的其中一条。
>
> $1\leq n,m\leq 10^5$。

## ※ 删边最短路

> 给出一张 $n$ 个点 $m$ 条边正权 **无向图**，以及一条 $1\leadsto n$ 的最短路径 $e_1,e_2,\cdots,e_k$（指定最短路径）。
>
> 对每个 $i$ 求删去 $e_i$ 后的最短路长度。
>
> $n,m\leq 2\times 10^5$。


可以扩展到求删去任意一条边后的最短路：CF1163F。

## 结合 DP

### [NOIP2017 提高组] 逛公园（较短路计数）

> 给出一张 $n$ 个点 $m$ 条边的图，问 $1\leadsto n$ 与最短路的差不超过 $k$ 的路径有多少条。
>
> 可能有 $0$ 边，如果数量无限输出 $-1$。
>
> $n\leq 10^5$，$m\leq 2\times 10^5$，$k\leq 50$。


### CF1693C Keshi in Search of AmShZ（\*2300）

> 给出一张 $n$ 个点 $m$ 条边的有向图。每一时刻，可以做以下两件事之一：
>
> - 删去图中的一条边。
> - 在目前 $x$ 的出边中随机一条走过去。
>
> 求从 $1$ 出发，在最坏情况下到达 $n$ 的最早时刻。
>
> $2\leq n\leq 2\times 10^5$，$1\leq m\leq 2\times 10^5$。

## ※ 结合分治

### ※ 一个例题

> 给出一张 $n$ 个点的无向图，对于任意三元组 $(a,b,c)$，求 $a\to b$ 不经过点 $c$ 的最短路。
>
> $n\leq 300$。

### ※ P3350 [ZJOI2016]旅行者

> 给出一张 $n\times m$ 的正权边网格图，$q$ 次询问两点间的最短路。
>
> $n\times m\leq 10^4$，$q\leq 10^5$。