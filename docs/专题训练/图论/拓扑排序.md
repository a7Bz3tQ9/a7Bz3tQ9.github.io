#### 拓扑排序

拓扑序：给点排序，使得有向边全是前面的点指向后面的。拓扑序不一定唯一。

性质：

- DAG 中的任意一条路径 $x\leadsto  y$，一定是拓扑序的一个子序列。因为拓扑序上不可能后面的指向前面的。

  DAG 可以尝试摆在拓扑序上考虑路径。

  （DAG 删点最短路）

一个有向图存在拓扑排序 $\Leftrightarrow$ 是一个 DAG。

- 必要性显然。有环就不可能有拓扑排序。

- 充分性：在 dfs 遍历时记录 in,out 的时间戳，按 out 从大到小就是一个合法拓扑序。

  证明：DAG 不存在返祖边。只要证明对于树边、前向边、横叉边，都是由 out 大的指向 out 小的即可。祖先的 out 显然大于后代的 out，树边、前向边显然。而横叉边一定从 in 大的指向 in 小的，而这两个子树不交，所以肯定是从 out 大的指向 out 小的。

实际上都是用队列实现，不断剥离入度为 $0$ 的点。如果过程无法进行完，就可以知道这个图不是 DAG。

变式：

- 字典序最小的拓扑序。

  把队列换成小根堆。

- 求一个拓扑序使得，$1$ 尽可能靠前，在此基础上 $2$ 尽可能靠前，在此基础上 $3$ 尽可能靠前，以此类推。

  把大的点放后面，前面留给小的点。可以证明，等价于从后往前放，每次放一个最大的点。反图 + 大根堆 即可。

  证明：假如某个位置没有放能放的最大的点 $x$，而是放了 $y<x$，那么把 $x$ 挪到 $y$ 后面更优。

  （技巧：证明一个贪心，可以用 调整法 + 反证，不满足这个贪心的解都能调整成满足这个贪心的解，并且满足这个贪心的解更优）

##### B1

P3573 [POI2014] RAJ-Rally

> 求 DAG 删去每个点后的，全局的最长路。

删去 $x$ 后的任意一条路径，就是拓扑序的、不包含 $x$ 的子序列。

注意到这个子序列构成的链上，最多只有一条边“跨过”了 $x$。没有边跨过 $x$ 的情况是很容易算的，否则考虑在跨过 $x$ 的这条边上统计。

枚举每条边 $(u,v)$，对每个点 $p$ 预处理出以 $p$ 为结尾的最长路 $f_p$、以 $p$ 为开头的最长路 $g_p$，那么用 $f_u+w_{u,v}+g_v$ 更新拓扑序上在 $u,v$ 之间的点的答案即可。这是区间取 $\max$，单点求值。线段树即可，也可以离线，扫描线 + multiset。

##### [题解待补] B2

P7831 [CCO2021] Travelling Merchant

> 给出一张 $n$ 个点 $m$ 条边的有向图，第 $i$ 条边有参数 $r_i,p_i$，表示要经过这条边你必须要有 $\geq r_i$ 元，然后经过这条边后你会获得 $p_i$ 元。
>
> 对每个点求，从这个点开始至少要带多少元，才能在图上无限走下去。不可能输出 $-1$。
>
> $2\leq n,m\leq 2\times 10^5$，$0\leq r_i,p_i\leq 10^9$。



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,id[N],out[N],del[N],ans[N];
struct E{int x,y,r,p;}e[N];
vector<int>rg[N];
queue<int>q;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].r,&e[i].p),
		rg[e[i].y].push_back(i),out[e[i].x]++,id[i]=i;
	sort(id+1,id+1+m,[](int x,int y){return e[x].r>e[y].r;});
	for(int i=1;i<=n;i++){
		ans[i]=2e9;
		if(!out[i]) q.push(i);
	}
	for(int i=1;i<=m;i++){
		while(q.size()){
			int x=q.front();q.pop();
			for(int j:rg[x]) if(!del[j]){
				del[j]=1;
				int y=e[j].x;
				if(ans[x]<2e9)
					ans[y]=min(ans[y],max(e[j].r,ans[x]-e[j].p));
				if(!--out[y]) q.push(y);
			}
		}
		int j=id[i];
		if(!del[j]){
			del[j]=1;
			int x=e[j].x;
			ans[x]=min(ans[x],e[j].r);
			if(!--out[x]) q.push(x);
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]<2e9?ans[i]:-1);
	return 0;
}
```

##### B3

P5284 [十二省联考 2019] 字符串问题

> 给出一个长度为 $n$ 的串 $s$。有 $n_a$ 个 A 类串，$n_b$ 个 B 类串，都是 $s$ 的子串，以区间的形式给出。
>
> 有 $m$ 个支配关系，形如第 $i$ 个 A 类串支配第 $j$ 个 B 类串。
>
> 你需要求出最长的字符串 $t$ 的长度，使得 $t$ 可以被划分成若干个 A 类串的拼接，并且相邻两个 A 类串 $t_i$ 和 $t_{i+1}$ 满足 $t_i$ 支配某个 B 类串 $j$，而 $j$ 是 $t_{i+1}$ 的前缀。
>
> 如果 $t$ 可以无限长，输出 $-1$。
>
> $n,m,n_a,n_b\leq 2\times 10^5$。

首先构建出图论模型：

- 若 $x$ 支配 $y$ 则将 $A_x$ 向 $B_y$ 连边。
- 若 $B_j$ 是 $A_i$ 的前缀，将 $B_j$ 向 $A_i$ 连边。

（构造路径，转化成求最优路径，是很重要的思想）

每个 $A_i$ 权值为其长度，$B_i$ 权值为 $0$，那么拓扑排序求出最长路就是答案。如果出现环输出 $-1$。

优化建图：怎么对于一个串 $A$，将它所有的前缀 $B$ 连向它。对 $s$ 建立后缀树，找到 $A$ 在后缀树上的节点 $p$，那么它的前缀要么是 $p$ 的祖先，要么是 $p$ 中比 $A$ 短的串。

使用前缀优化建图的思想。前者后缀树上从父亲连向儿子，后者将 $p$ 中的串按长度从小到大排序，这样连：

<img src="https://img2023.cnblogs.com/blog/1859218/202309/1859218-20230908092853391-1881901118.png" alt="image" style="zoom: 60%;" />