欧拉图：存在欧拉回路的图。

半欧拉图：存在欧拉路径但不存在欧拉回路的图。

#### 判定

无向图：

- 欧拉图：连通且度数全偶。
- 半欧拉图：连通且恰有 $2$ 个奇点。这 $2$ 个奇点是欧拉路径的起点与终点。

有向图：

- 欧拉图：基图连通且所有点 入度 = 出度。
- 半欧拉图：基图连通且恰有一个点 出度 - 入度 $=1$ 也恰有一个点 入度 - 出度 $=1$。分别是欧拉路径的起点与终点。

混合图：

- 存在欧拉回路：存在一个对所有无向边定向的方案，使得所有点 入度 = 出度。需要网络流。

#### 求法

如果在搜索时记录边，搜完一个环可能会掠过一些环没有搜到。于是改成在回溯时记录边，之前没有搜到的环会在回溯到环的位置时搜到，因此不会走漏。举两个栗子：

<img src="https://img2023.cnblogs.com/blog/1859218/202301/1859218-20230129202326946-784938200.png" alt="image"  />

由于度数有保证，所以不会出现没走完就走投无路的情况。

因为一个点可能被访问多次，一不小心可能会写成 $\mathcal O(n^2)$ 的（因为每次遍历所有的出边）。解决方案就是设一个 cur 数组，每次直接从上一次访问到的出边继续遍历）。时间复杂度 $\mathcal O(n+m)$。

当前弧优化防下面这种图卡。

<img src="https://img2023.cnblogs.com/blog/1859218/202301/1859218-20230129205705931-186393937.png" alt="image" style="zoom: 33%;" />

```cpp
int cnt=1,hd[N],to[N<<1],nxt[N<<1],vis[N];	//!!! cnt=1
vector<int>ans;
void add(int x,int y){
    to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;
}
void dfs(int x){
    for(int &i=hd[x];i;i=nxt[i]){
        int y=to[i],tmp=i;	//!!! 保存临时变量 tmp
        if(!vis[i>>1]) vis[i>>1]=1,dfs(y),ans.push_back(tmp);
    }
}
```

UOJ#117

```cpp
//UOJ 117
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=4e5+5;
int t,n,m,x,y,cnt=1,in[N],ou[N],hd[N],to[M],nxt[M],tot,ans[M];
bool vis[M];
void add(int x,int y){
	to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;
}
void dfs(int x){
	for(int &i=hd[x];i;i=nxt[i]){
		int y=to[i],c=(t==1?i/2:i-1),k=i&1; 
		if(vis[c]) continue;
		vis[c]=1,dfs(y);
		if(t==1) ans[++tot]=k?-c:c;
		else ans[++tot]=c;
	}
}
signed main(){
	scanf("%d%d%d",&t,&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y),add(x,y);
		if(t==1) add(y,x),in[x]++,in[y]++;
		else in[y]++,ou[x]++;
	}
	if(t==1){for(int i=1;i<=n;i++) if(in[i]&1) puts("NO"),exit(0);}
	else for(int i=1;i<=n;i++) if(in[i]!=ou[i]) puts("NO"),exit(0);
	for(int i=1;i<=n;i++)
		if(hd[i]){dfs(i);break;} 
	if(tot!=m) puts("NO"),exit(0);
	puts("YES"); 
	for(int i=tot;i>=1;i--)
		printf("%d%c",ans[i],i==0?'\n':' ');
	return 0;
}
```

#### 例题

欧拉回路模型：给边定向使得入度等于出度；求出一个包含所有边的大环。**边定向问题可以考虑欧拉回路**。

##### A1

> 给出一张无向图，将其中的每条边定向，要求每个节点的入度和出度的差 $\leq 1$。

奇点连向虚点 $s$，由于无向图总度数是偶数，奇点一定有偶数个，故连完后整个图是欧拉图，跑欧拉回路定向后，删掉 $s$ 以及 $s$ 相连的边，点的出入度最多变化 $1$。

##### A2

> 平面上 $n$ 个整点 $(x_i,y_i)$，要求将它们染成红色或蓝色，且每行每列红蓝点个数差 $\leq 1$。

把 $(x_i,y_i)$ 看作一条无向边，染红色蓝色相当于给无向边定向，转化为 A1。

##### A3

> 生成长度为 $2^n$ 的首尾相接的串使得所有长度为 $n$ 的 $01$ 串都出现过。

- $01$ 串当成点：想象一个长度为 $n$ 的框在长度为 $2^n$ 的环上平移的过程。如果一个 $01$ 串的后 $n-1$ 位是另一个 $01$ 串的前 $n-1$ 位就从前一个串向后一个串连边（显然一个串会连向两个串，即后面加上 $0/1$ 再删去首个字符），求哈密顿回路。好像不太好求。
- $01$ 串当成边（类似 ABC209E,HDU4850）：改成从前 $n-1$ 位连向后 $n-1$ 位，跑欧拉回路。

一定要思考图论中边和点的关系，弄清楚什么是边，什么是点，不要思维定式。

##### A4

> 给出一张无向图（不一定连通），加最少的边使之成为一个欧拉连通图。

两件事：1. 消奇点；2. 连通。

先连能同时搞定两件事的边，再连只能搞定一件事的。如果所有连通块都没有奇点，可以连一个大环，一个偶点多连两条边还是偶点。现在多了有奇点的连通块，由于无向图奇点一定有偶数个，可以选其中两个奇点分别连一条边去连接其他连通块，搞定两个奇点。剩下的奇点随便匹配。

![image](https://img2023.cnblogs.com/blog/1859218/202301/1859218-20230129201717092-833706106.png)

##### HDU4850 Wow! Such String!

2023.3.3

> 构造一个长度为 $n$ 的字符串，使得每个长度 $\geq 4$ 的子串均仅出现一次。
>
> $1\leq n\leq 5\times 10^6$。

想象一个长度为 $4$ 的框滑动的过程：将长度为 $3$ 的串抽象成点（当前框的末尾 $3$ 位），若点 $x$ 的后两位是点 $y$ 的前两位就连边 $x\to y$。每经过图中的一条边，就相当于将框移动了一位，构造了一个新的长度为 $4$ 的子串（两端点就唯一确定了这个长度为 $4$ 的子串），每个长度为 $4$ 的子串只出现一次就等价于每条边至多走一次。

（即对于每个长度为 $4$ 的串，前三位向后三位连边）

当 $n>26^4+3$ 时无解。不妨构造每个长度为 $4$ 的子串都恰好出现一次的方案，然后输出长度为 $n$ 的前缀。由于每个点的入度和出度都是 $26$，故该有向图一定存在欧拉回路。

##### CF508D Tanya and Password（\*2500）

2023.3.3

> 给出 $n$ 个长度为 $3$ 的字符串 $s_{1\sim n}$，求是否存在一个长度为 $n+2$ 的字符串，使得 $s_{1\sim n}$ 恰好是其 $n$ 个长度为 $3$ 的子串。
>
> $1\leq n\leq 2\times 10^5$。

又是这个套路。

将长度为 $2$ 的字符串抽象成点，对于每个 $s_i$，前两位向后两位连边。判该有向图是否存在欧拉路径。

## dcx

存在欧拉回路：

- 无向图：连通且每个点度数为偶数。
- 有向图：连通且每个点入度等于出度。

- 证明充分性：随便走直到走不动肯定能走出一个环（中间点走进来就能走出去，走不了只能是回到起点了），但这个环不一定包含所有边。把这个环删掉仍然满足存在欧拉回路的条件，并且图连通，可以接着走环。怎么把两个环拼一起？找到两个环的公共点，一个环走到公共点的时候去另一个环绕一圈，最后再走回来。这样环就能不停地扩大，直到扩大到整张图。

方案输出：

- Hierholzer 算法，爆搜，把边倒着加进答案里（回溯的时候加）。

  正确性：假如现在搜了一个环，还没包含所有边，那么回溯到两个环的公共点时，就能去搜另一个环。而由于是倒着加边的，当前只加了起点倒着到这个公共点的边，再倒着把另一个环的边加上，再倒回起点，就把两个环拼起来了。

- 混合图欧拉回路定向：需要网络流。

套路 1：构造。将一个无向图定向，使得入度和出度的差 $\leq 1$。

- 奇点连向虚点 $S$，跑欧拉回路定向后，删掉 $S$ 以及 $S$ 相连的边。

  证明：无向图总度数是偶数，奇点一定有偶数个，连完后整个图是欧拉图。并且，删掉 $S$ 后及其邻边，点的出入度最多变化 $1$。

- 平面上 $n$ 个整点 $(x_i,y_i)$，要求将它们染成红色或蓝色，且每行每列红蓝点个数差 $\leq 1$。（CF547D Mike and Fish）

  把行列化点、点化边，建立二分图。转化为，给边染色，使得每个点的红蓝邻边个数差 $\leq 1$。

  染红色或蓝色相当于给边定向。比如对于行对应的点，红边对应出度，蓝边对应入度；对于列对应的点，红边对应出入度，蓝边对应出度。

- 给出 $n$ 条线段 $[l_i,r_i]$，给这些线段染成红色或蓝色，使得直线上任意一点被红蓝线段覆盖次数之差 $\leq 1$。（CF429D Points and Segments）

  将红色线段看成区间 $+1$，蓝色看成区间 $-1$。差分，红色线段 $l_i$ 加 $1$、$r_i+1$ 减 $1$，蓝色线段 $l_i$ 减 $1$、$r_i+1$ 加 $1$。

  如果每个点被红蓝线段覆盖次数之和都是偶数，那么一定有红蓝线段覆盖次数之差 $=0$，也就是差分数组全为 $0$，连 $(l_i,r_i+1)$ 跑欧拉回路即可。

  对于被覆盖次数为奇数的点 $i$，新增一条红色或蓝色线段 $[i,i]$，转化为偶数的情况即可。

套路 2：生成一个串，使得所有长度为 $n$ 的串都出现恰好一次。

- 生成长度为 $(n-1)+2^n$ 的串，使得共 $2^n$ 个长度为 $n$ 的 $01$ 串都出现过（显然也是恰好出现一次）。

  如果把长度为 $n$ 的 $01$ 串当点（想象长度为 $n$ 的框滑动的过程），每个点经过恰好一次，哈密顿回路，GG。

  考虑把长度为 $n$ 的 $01$ 串当成边（想象长度为 $n-1$ 的框滑动的过程，相邻两个框叠起来对应一条边），每条边经过恰好一次，跑欧拉回路（显然这个图连通，且每个点入度 = 出度）。

  输出方案：第一条边 + 之后每条边的末尾字符。

  这个串实际上还有一个性质：因为最后走回了起点，所以开头 $n-1$ 位等于末尾 $n-1$ 位。

- 生成长度为 $2^n$ 的首尾相接的串，使得共 $2^n$ 个长度为 $n$ 的 $01$ 串都出现过。

  就是上一题取长度为 $2^n$ 的前缀。

- 构造一个长度为 $n$、字符集为 $m$ 的字符串 $S$，使得本质不同子串的数量尽可能多。$n\leq 10^5$，$m\leq 26$。

  ($m=2$：QOJ#5434)

  我们希望长度小的子串全都出现，长度大的子串（不足以全部出现的）出现的互不相同。

  - 长度为 $k$ 的串都出现，至少需要 $(k-1)+m^k$ 的长度。

    考虑找到最大的 $k$，使得 $(k-1)+m^k\leq n$。

    这样，只要所有长度为 $k$ 的串都出现了，长度为 $[1,k]$ 的串就都出现了。且，只要所有长度为 $k+1$ 的子串都互不相同，那么长度为 $[k+1,n]$ 的子串也互不相同。

    转化为，使得所有长度为 $k$ 的串都出现，且所有长度为 $k+1$ 的串互不相同。

  考虑把长度为 $k$ 的串当成点（因为 $m^k\leq n$，点数是 $\mathcal O(n)$ 的），长度为 $k+1$ 的串当成边。要找一条有 $n-k+1$ 个点的路径（对应 $S$），经过每个点至少一次，且经过的边互不相同。

  - 先按套路求出一个长度为 $(k-1)+m^k$ 的串 $T$，使得每个长度为 $k$ 的串出现恰好一次。显然 $T$ 中每个长度为 $k+1$ 的串互不相同。

    $T$ 在图上是一条经过每个点恰好一次的路径。我们希望在这条路径的基础上，加 $n-k+1-|T|$ 个点，加点的时候扩展的必须是不同的边。

  因为经过不同的边似乎只能欧拉回路，而整张图扣掉 $T$ 并不是欧拉图。

- 注意到 $T$ 最后一个点到第一个点一定有边（最后一个点与第一个点肯定能叠起来），$T$ 实际上是一个回路断掉一条边。不妨把这条边选上，转化成在一个“基础环”上加边。

  - 考虑把基础环删掉，再跑欧拉回路，把新跑出的环接到基础环上。在点数不超的情况下就把整个接进去，否则把能接的都接进去。

  输出方案：

  - 拼接两个环：一个环走到公共点，到另一个环上绕一圈，再从公共点继续走。

    拼接一个环 + 一条路径（不完整的环）：从路径开始走到公共点，到环上绕一圈。

    我觉得可以把小环挂在”小环与基础环的公共点“上，走 路径 - 基础环，在走基础环的过程中，如果点上有挂着的，就输出来。

##### F1

P6168 [IOI2016] railroad / UOJ#236. 【IOI2016】railroad

> 火车初始速度为 $1$。可以用 $x$ 的代价使火车的速度减小 $x$。
>
> 有 $n$ 个车站，对于第 $i$ 个车站，进入车站时火车速度必须 $\leq s_i$，出了这个车站时火车的速度会变成 $t_i$。
>
> 排列车站，求使得所有车站恰好被经过一次的最小代价。
>
> $1\leq n\leq 2\times 10^5$，$1\leq s_i\leq 10^9$，$1\leq t_i\leq 10^9$。

改成，增加火车的速度没有代价，进入车站时火车速度必须 $=s_i$。

将速度看成点，车站看成边，连 $(s_i\to t_i,0)$（必须要走的边，称为“必选边”），$(i\to i+1,0)$，$(i+1\to i,1)$，答案就是经过所有必选边的最短路径。

加一条边 $(\infty\to 1,0)$，改成经过所有必选边的最短回路。回路的好处是，覆盖每条 $(i,i+1)$ 的向右的边数 = 向左的边数。

考虑在必选边的基础上还得加哪些边。对于 $(i,i+1)$，如果覆盖了这条边的 向左的必选边数 ≠ 向右的必选边数，就得加若干 $i\to i+1$ 或 $i+1\to i$ 的边。先把这些边都加上，得到若干个回路连通块，我们还需要将连通块通过 $i\to i+1$ 和 $i+1\to i$ 连起来。

显然我们只会在相邻连通块之间连边。变成 MST 问题。

（提炼模型：$\min_{p\in perm(n)}\sum_{i=1}^{n-1}\max(t_{p_i}-s_{p_{i+1}},0)$，把排列变成环，变成在必须边 $s_i\to t_i$ 的基础上加边，找欧拉回路，$i\to i+1$ 边权为 $0$，$i+1\to i$ 边权为 $1$。$\sum_{i=1}^n|a_{p_i}-b_{p_{(i\bmod n)+1}}|$ 也类似，$i\to i+1$ 边权也是 $1$）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
int n,m,a[N],b[N],t,c[N],d[N],f[N];
long long ans;
struct E{int x,y,z;}e[N];
int find(int x){
	return x==f[x]?x:f[x]=find(f[x]);
}
signed main(){
	scanf("%d%*d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]),
		c[++t]=a[i],c[++t]=b[i];
	sort(c+1,c+1+t),t=unique(c+1,c+1+t)-c-1;
	iota(f+1,f+1+t,1);
	for(int i=1;i<=n;i++){
		int x=lower_bound(c+1,c+1+t,a[i])-c,
		y=lower_bound(c+1,c+1+t,b[i])-c;
		d[x]++,d[y]--,f[find(x)]=find(y);
	}
	d[t]++,d[1]--,f[find(t)]=find(1);
	for(int i=1;i<t;i++){
		if((d[i]+=d[i-1]))
			f[find(i)]=find(i+1),
			ans+=d[i]>0?1ll*(c[i+1]-c[i])*d[i]:0;	//加向右走的边没有代价，加向左走的边才有代价
		e[++m]={i,i+1,c[i+1]-c[i]};
	}
	sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
	for(int i=1;i<=m;i++){
		int x=find(e[i].x),y=find(e[i].y);
		if(x!=y) f[y]=x,ans+=e[i].z;
	}
	printf("%lld\n",ans);
	return 0;
}
```

##### F2

[BOI2016 Acrobat](https://vjudge.net/problem/Baekjoon-13973)

> ![image](https://img2023.cnblogs.com/blog/1859218/202309/1859218-20230909112822504-1122594692.png)
>
> $1\leq n,m\leq 3\times 10^5$。

要使每个点的度数为偶数且连通。

先考虑怎么使每个点的度数变成偶数，再用操作 2 去连通。

注意到操作 1 会改变 $a_i,a_j,b_i,b_j$ 的度数奇偶性，操作 2 会改变 $b_i,b_j$ 的度数奇偶性，且总度数为偶数。

于是考虑先用操作 1 使所有 $a$ 度数变成偶数：发现就是 DFS 树 - A1 这道题。大概需要 $n$ 次操作。

再操作 2 把所有 $b$ 串起来，大概 $n$ 次操作。

最后用操作 2 把所有度数为奇数的 $b$ 两两连起来，大概 $\frac n 2$ 次操作。