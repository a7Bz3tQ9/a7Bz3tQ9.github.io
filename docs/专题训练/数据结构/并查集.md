### 并查集

并查集直接路径压缩是均摊 $\mathcal O(n\log n)$，所以可撤销并查集需要按秩合并保证树高。

#### C1

> 加边。求 $\sum_{i=1}^n\sum_{j=i+1}^n L(i,j)$，其中 $L(i,j)$ 表示 $i,j$ 最早什么时候连通。

第 $i$ 个时刻合并集合 $x$ 和集合 $y$ 时，贡献 $i\cdot sz_x\cdot sz_y$。

#### C2

> 加边。求两个点是在什么时候连通的。在线。

只按秩合并不路径压缩。如图，直接合并根为 $A,B$ 的集合，$A=\text{lca}(x,y)$，$B$ 为 $x\to A$ 链上 $A$ 的儿子。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829144951980-161400863.png" alt="image" style="zoom:50%;" />

间接合并：设 $B,C$ 分别为 $x\to A,y\to A$ 链上 $A$ 的儿子，则 $x,y$ 连通的时刻为 $\max(w(B,A),w(C,A))$。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829145123991-1523824026.png" alt="image" style="zoom:50%;" />

维护 $dep$。

（离线就是“并查集生成树”查询路径边权最大值）

#### C3

> 加边。询问第 $x$ 个点在第 $i$ 条边加入后所在连通块的大小。离线。

Kruskal 重构树，以边的编号作为边权，算 $x$ 只经过 $\leq i$ 的边能到多少个点。

#### C4

> 给出一个数组 $a_{1\sim n}$，初始全为 $0$，两种操作：
>
> 1. 令 $a_x\gets 1$。
> 2. 询问 $a_{x\sim n}$ 中第一个为 $0$ 的位置。

维护 $f_i$ 表示从 $i$ 开始向右延伸 $1$ 最多能延伸到哪里。并查集路径压缩维护。

1. `fa[x-1]=x`。
2. 输出 `find(x)+1`。

#### C5

> 给出一个初始全为 $0$ 的数组 $a_{1\sim n}$，每次操作把 $a_{l\sim r}$ 中所有还是 $0$ 的数​变成 $k$。求最后数组变成了什么。

维护 $f_i$ 表示 $i$ 及其右边第一个为 $0$ 的位置。并查集路径压缩维护。暴力赋值。

#### C6

> 给出一个数组 $a_{1\sim n}$，每次操作可以对一个区间的数开根下取整。询问区间和。

一个数只会开根 $\mathcal O(\log\log V)$ 次，变成 $1$ 就不用管了。

维护 $f_i$ 表示 $i$ 及其右边第一个 $\neq 1$ 的位置，暴力开根。树状数组维护单点加，区间求和。

#### C7

> 给出 $a_{1\sim n},b_{1\sim n},c_{1\sim n}$，求 $a_i\times b_j\times \min(c_{i\sim j})$ 的最大值。

单调栈：枚举 $\min(c_{i\sim j})=c_x$，求出区间最小值为 $c_x$ 的区间范围 $L,R$，在 $[L,x]$ 里找到最大/最小的 $a_i$，$[x,R]$ 里找到最大/最小的 $b_j$。找最小是因为可能有负数。

并查集：关于 $c$ 从大到小进行合并，那么合并两个内部合并好的区间 $[l_1,r_1],[r_1+1,r_2]$ 时，$\min(c_{l_1\sim r_2})$ 就是 $\min(c_{r_1},c_{r_1+1})$，并查集维护集合内部 $a,b$ 的最大/最小值。

具体地，将边 $(i,i+1)$ 按 $\min(c_i,c_{i+1})$ 从大到小合并（把点权转成边权，好处是，**这样 $\min(c_{l\sim r})$ 就是 $l\sim r$ 这条链所有边的 $\min$**。如果按点权从大到小排序，枚举到一个点时要考虑它相邻的每个点，而枚举边只要考虑这条边两端的两个点）。枚举到一条边 $(i,i+1)$ 时，就把这条边的两端合并：设这条边的两端分别在合并好的两个集合 $x,y$ 里，从 $x,y$ 里分别选一个点，区间最小值都是 $\min(c_i,c_{i+1})$。

这种做法是很容易扩展到树上的（区间最小值改成路径最小值），因为实际上我们没有用到区间的性质。点权转边权，这样路径最小值就是这条链所有边的 $\min$。类似的题目有 CF915F。

另一个想法是分治，找到 $\min(c_{i\sim j})$ 然后分裂两半，即从小到大分裂。这和从大到小合并是相对的，一种行不通时不妨想想另一种。如 P8552。

#### C8

> 给出一棵树，两种操作：
>
> 1. 加边。
> 2. 询问两个点是否存在至少两条不相交路径。