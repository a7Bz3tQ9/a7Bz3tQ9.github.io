### 树状数组

考虑访问一个前缀，只会访问线段树上节点的左儿子。删掉线段树上所有节点的右儿子，就是树状数组了。

树状数组上节点 $x$ 维护的是 $[x-\text{lowbit}(x)+1,x]$ 的信息，其中 $\text{lowbit}(x)$ 为 $x$ 二进制从右往左第一个 $1$ 及之后的 $0$ 组成的数。

容易发现，除了根节点外，每个点 $x$ 都有唯一的父亲 $x+\text{lowbit}(x)$。$\text{lowbit}(x)=2^i$ 的点 $x$ 在从下往上数第 $i$ 层。

<img src="https://s2.loli.net/2025/12/10/nudv9tYNfgAkcGo.png" alt="image" style="zoom: 25%;" />

单点修改时一直跳 father 即可，前缀查询时因为节点 $x$ 维护的是 $[x-\text{lowbit}(x)+1,x]$ 的和，所以跳到 $x-\text{lowbit}(x)$。

无论修改还是查询每次至少向上跳一层，复杂度 $\mathcal O(\log n)$。

<img src="https://s2.loli.net/2025/12/10/fiZF9TvgmlbIyhR.png" alt="image" style="zoom: 35%;" />

#### A1

> 单点加，区间求和。$1\leq n,q\leq 10^6$。

#### A2

> 区间加，单点查询

差分，转化为单点加，区间查询。

#### A3

> 区间加，区间求和

首先通过差分转化为前缀加，前缀求和。维护原数组 $a$ 的差分数组 $b$。

$\sum_{i=1}^r a_i=\sum_{i=1}^r\sum_{j=1}^i b_j=\sum_{i=1}^r b_i\times (r-i+1)=(r+1)\times \sum_{i=1}^r b_i-\sum_{i=1}^r i\times b_i$

用两个树状数组分别维护 $b_i$ 和 $i\times b_i$ 的前缀和即可。

```cpp
//LOJ 132
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
int n,m,x,op,l,r;
ll s[N],a[N],b[N];
void add(int x,int y){
	for(int i=x;i<=n;i+=i&(-i)) a[i]+=y,b[i]+=1ll*x*y;
}
ll query(int x){
	ll u=0,v=0;
	for(int i=x;i;i-=i&(-i)) u+=a[i],v+=b[i];
	return (x+1)*u-v+s[x];
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&x),s[i]=s[i-1]+x;
	while(m--){
		scanf("%d%d%d",&op,&l,&r);
		if(op==1) scanf("%d",&x),add(l,x),add(r+1,-x);
		else printf("%lld\n",query(r)-query(l-1));
	}
	return 0;
}
```

#### 二维树状数组

节点 $(x,y)$ 维护 $x$ 坐标属于 $[x-\text{lowbit}(x)+1,x]$ 且 $y$ 坐标属于 $[y-\text{lowbit}(y)+1,y]$ 的元素的和。

修改和查询时两重循环，外层跳 $x$ 坐标，内层跳 $y$ 坐标即可。查询时用二维差分将区间查询转成前缀查询。更高维的树状数组同理。

```cpp
//LOJ 133
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=(1<<12)+5;
int n,m,x;
ll c[N][N];
void add(int x,int y,int v){
	for(int i=x;i<=n;i+=i&(-i))
		for(int j=y;j<=m;j+=j&(-j)) c[i][j]+=v;
}
ll query(int x,int y){
	ll ans=0;
	for(int i=x;i;i-=i&(-i))
		for(int j=y;j;j-=j&(-j)) ans+=c[i][j];
	return ans;
}
signed main(){
	scanf("%d%d",&n,&m);
	int op,a,b,c,d;
	while(~scanf("%d%d%d%d",&op,&a,&b,&c)){
		if(op==1) add(a,b,c);
		else scanf("%d",&d),printf("%lld\n",query(c,d)-query(a-1,d)-query(c,b-1)+query(a-1,b-1));
	}
	return 0;
}
```

#### 二维 区间加，区间求和

维护原数组 $a$ 和二维差分数组 $b$。

考虑对前缀 $(p,q)$ 求和：

$\sum_{i=1}^p\sum_{j=1}^q a_{i,j}=\sum_{i=1}^p\sum_{j=1}^q\sum_{k=1}^i\sum_{l=1}^j b_{k,l}=\sum_{i=1}^p\sum_{j=1}^q b_{i,j}(p-i+1)(q-j+1)$

$=(p+1)(q+1)\sum_{i=1}^p\sum_{j=1}^q b_{i,j}-(p+1)\sum_{i=1}^p\sum_{j=1}^q j\cdot b_{i,j}-(q+1)\sum_{i=1}^p\sum_{j=1}^q i\cdot b_{i,j}+\sum_{i=1}^p\sum_{j=1}^q i\cdot j\cdot b_{i,j}$

用四个树状数组维护 $b_{i,j}$，$i\cdot b_{i,j}$，$j\cdot b_{i,j}$，$i\cdot j\cdot b_{i,j}$ 的二维前缀和即可。

如果卡空间可以开 `short` 或 `char`。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2100;
int n,m,x;
ll a[N][N],b[N][N],c[N][N],d[N][N];
void add(int x,int y,int v){
	for(int i=x;i<=n;i+=i&(-i))
		for(int j=y;j<=m;j+=j&(-j))
			a[i][j]+=v,b[i][j]+=x*v,c[i][j]+=y*v,d[i][j]+=x*y*v;
}
ll query(int x,int y){
	ll u=0,v=0,w=0,k=0;
	for(int i=x;i;i-=i&(-i))
		for(int j=y;j;j-=j&(-j))
			u+=a[i][j],v+=b[i][j],w+=c[i][j],k+=d[i][j]; 
	return (x+1)*(y+1)*u-(x+1)*w-(y+1)*v+k;
}
signed main(){
	scanf("%d%d",&n,&m);
	int op,a,b,c,d;
	while(~scanf("%d%d%d%d%d",&op,&a,&b,&c,&d)){
		if(op==1) scanf("%d",&x),add(a,b,x),add(a,d+1,-x),add(c+1,b,-x),add(c+1,d+1,x);
		else printf("%lld\n",query(c,d)-query(a-1,d)-query(c,b-1)+query(a-1,b-1));
	}
	return 0;
}
```

#### 线性建树

建树时从前到后将每个节点 $x$ 的值累加到父亲 $x+\text{lowbit}(x)$ 即可。

```cpp
for(int i=1;i<=n;i++){
	scanf("%d",&x),c[i]+=x;
	if((j=i+(i&(-i)))<=n) c[j]+=c[i];
}
```

#### 树状数组二分/倍增

> 给出一个非负整数序列 $a$，$q$ 次询问：
>
> - `x`：求一个最小的 $i\in[1,n]$ 使得 $a_1+a_2+\cdots+a_i\geq x$。

利用树状数组的性质二分即可。其实这个过程长得很像倍增，但实质比较像线段树。

#### D1

动态第 $k$ 小

> 支持：
>
> 1. 加入或删除一个数。
> 2. 求全局第 $k$ 小的数。

二分不好。倍增。怎么 check $x+2^i$ 能否当答案：就是 $[1,x]$ 有几个数 + `c[x+(1<<i)]`。

<img src="https://s2.loli.net/2025/12/10/ebLcJCRMnYit4kw.png" alt="image" style="zoom: 33%;" />

```cpp
int kth(int k){
	int x=0,s=0;
	for(int i=20;i>=0;i--)
		if(x+(1<<i)<=n&&s+c[x+(1<<i)]<k) s+=c[x+=(1<<i)];
	return x+1;
}
```

#### 区间赋值，区间求和

考虑经典的 `set` 维护连续段做法，每次区间修改的操作只会新增至多两个连续段。

每增加或减少一个连续段需要进行一次区间加，最终均摊只会进行 $\mathcal O(n+q)$ 次区间加。

用两个树状数组支持区间加区间求和即可。

用到了平衡树？再用一个树状数组维护连续段，把 `set` 换成树状数组上二分即可。

### 杂题

#### LIS

<img src="https://s2.loli.net/2025/12/10/T28cHFxlBJ4erXL.png" alt="image.png" style="zoom:67%;" />

<img src="https://s2.loli.net/2025/12/10/4P1s2CfBTWaqkv7.png" alt="image.png" style="zoom: 67%;" />

#### 二维数点

<img src="https://s2.loli.net/2025/12/10/MlRmToXwG9NxDiy.png" alt="image.png" style="zoom:67%;" />

<img src="https://s2.loli.net/2025/12/10/npWzEd4LCsiHtQk.png" alt="image.png" style="zoom:67%;" />

### 小练习

> 给出一棵 $n$ 个节点的树，点、边有编号。$m$ 次询问：
>
> - `l r`：查询只保留点编号 $\in[l,r]$ 的点、边编号 $\in[l,r]$ 点的边，有多少点连通块。此时 $a$ 与 $b$ 连通等价于 $a,b\in[l,r]$ 且 $a,b$ 在树上简单路径中所有点与边编号都 $\in[l,r]$。
>
> $1\leq n,m\leq 10^6$。

对于任意森林，**连通块数 = 点数 - 边数**，点数就是 $r-l+1$，边数：求有多少编号为 $i$ 的边 $(x,y)$，满足 $l\leq i,x,y\leq r$。

这是一个三维的问题。一个巧妙的转化：$l\leq \min(i,x,y)\leq \max(i,x,y)\leq r$，这样就变成了二维的，$(i,x,y)$ 变成平面上一个点 $(\min(i,x,y),\max(i,x,y))$，离线树状数组维护二维数点即可。