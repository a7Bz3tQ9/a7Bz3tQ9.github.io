### 线段树

区间修改维护区间信息：

1. 区间信息与区间信息的合并

2. 标记与标记的合并

   例如 $x\to kx+b$，合并 $(k_1,b_1),(k_2,b_2)$， $k_2(k_1x+b_1)+b_2=k_1k_2x+(k_2b_1+b_2)$，得到 $(k_1k_2,k_2b_1+b_2)$。

3. 标记与区间信息的合并（标记作用到区间信息上，区间信息会发生什么的变化）

   比如 $x\to kx+b$，$sum(x)$ 会变成 $k\cdot sum(x)+b\cdot len$。

维护什么东西：考虑 info + info、info + tag 需要什么东西。如最大子段和的 后缀 max + 前缀 max。

```cpp
struct tag{
	void upd(tag tg){}	//tag 和 tag 结合
}tg[N<<2];
struct info{
	void upd(tag tg){}	//info 和 tag 结合
	info operator+(info a){}	//info 和 info 结合
}s[N<<2];
void upd(int p,tag v){
	s[p].upd(v),tg[p].upd(v);
}
void down(int p){
	upd(p<<1,tg[p]),upd(p<<1|1,tg[p]),清空 tg[p].s=tg[p].mxs=0;
}
```

#### P3373 【模板】线段树 2

> 区间加，区间乘，区间求和。

怎么处理时间顺序问题？手动钦定顺序将 $add$ 和 $mul$ 结合起来。

维护 tag $(mul,add)$，考虑两条路：

表示区间内的数先 $\times mul$ 再 $+add$，合并 info 和 tag 就是 $sum'\gets sum\times mul+add\cdot len$。

当前 info $sum$ 依次经过 $(\times mul_x,+add_x),(\times mul_{fa},+add_{fa})$ 后，则会变成
$$
\begin{aligned}
sum'&\gets(sum\times mul_x+add_x\cdot len)\times mul_{fa}+add_{fa}\cdot len\\
&=sum\times mul_x\times mul_{fa}+(add_x\times mul_{fa}+add_{fa})\cdot len
\end{aligned}
$$
于是下传时 $mul_x'\gets mul_x\times mul_{fa}$，$add_x'\gets add_x\times mul_{fa}+add_{fa}$。

（因为区间乘会影响区间加，但区间加不会影响区间乘，所以钦定优先级 $mul>add$）

---

考虑两个 tag：`add` 和 `mul`。

- 区间加法：直接更新 `add` 标记和区间和。
- 区间乘法：不仅要更新当前区间和，还要更新当前区间的 `add` 标记。根据乘法分配律 $(sum\times mul+add)\times v=sum\times mul\times v+add\times v$。

#### A1

> 区间加，区间乘，区间赋值，查询区间和。

考虑区间覆盖会直接置空区间乘和区间加，区间乘会影响区间加，区间加无法影响其他操作，所以钦定优先级 $cov>mul>add$。

维护 tag $(cov,mul,add)$ 表示先赋值为 $cov$ 再 $\times mul$ 最后 $+add$。若存在 $cov$ 标记则记 $\text{cover}(sum,cov)$ 为 $cov\cdot len$，否则还是 $sum$。那么合并 info 和 tag 就是
$$
sum'\gets\text{cover}(sum,cov)\times mul+add\cdot len
$$
当前 info $sum$ 依次经过 $(cov_x,\times mul_x,+add_x),(cov_{fa},\times mul_{fa},+add_{fa})$ 后，则会变成
$$
\begin{aligned}
sum'&\gets
\text{cover}((\text{cover}(sum,cov_x)\times mul_x+add_x\cdot len),cov_{fa})\times mul_{fa}+add_{fa}\cdot len\\
&=
\begin{cases}
\text{cover}(sum,cov_{fa})\times mul_{fa}+add_{fa}\cdot len&(\text{have }cov_{fa})
\\
\text{cover}(sum,cov_x)\times mul_x\times mul_{fa}+(add_x\times mul_{fa}+add_{fa})\cdot len&(\text{otherwise})
\end{cases}
\end{aligned}
$$

#### A2

> 区间加，区间求平方和，区间求方差。$1\leq n,q\leq 10^5$.

<img src="https://s2.loli.net/2025/12/10/kGHshjm6wTaAygp.png" style="zoom: 50%;" />

<img src="https://s2.loli.net/2025/12/10/2IlcLKnjdrpOs6E.png" style="zoom: 67%;" />

#### A3

> 区间加等差数列，区间求和。$1\leq n,q\leq 10^5$。

维护懒标记的时候维护两个信息：首项和公差。

加等差数列对区间和带来的影响可以直接计算，下放懒标记的时候也可以直接计算。

#### E1

> 平面上有 $n$ 个矩阵 $(U_i,D_i,L_i,R_i)$，求矩阵面积并。$n\leq 10^5$。
>

首先离散化。将矩形理解为上下两条边之间的面积。插入一条边相当于覆盖一段区间。

线段树维护区间内被覆盖次数 $\geq 1$ 的长度。维护区间最小值（区间最小被覆盖次数）和区间最小值个数即可，如果区间最小值为 $0$，就用区间长度减去区间最小值个数即可。每次插入/删除一条边前统计一下扫过的面积。

从上往下即可。

#### P2221 [HAOI2012]高速公路

> 一条由 $n-1$ 段路以及 $n$ 个收费站组成的东西向的链，收费站依次编号为 $1\sim n$，从收费站 $i$ 行驶到 $i+1$（或从 $i+1$ 行驶到 $i$）需要收取一定的费用，高速路刚建成时所有的路段都是免费的。
>
> 要求动态维护 $m$ 个操作：
>
> 1. 将收费站 $l,r\,(l<r)$ 之间的路上的收费 $+v$（可能是负数）。
> 2. 求对于给定的 $l,r\,(l<r)$，在第 $l\sim r$ 个收费站里等概率随机取出两个不同的收费站 $a,b$，求从 $a$ 行驶到 $b$ 期望花费的费用。
>
> $n,m\leq 10^5$，$|v|\leq 10^4$。

$$
\begin{aligned}
\sum_{i=l}^r\sum_{j=l}^r dis(l,r)
&=\sum_{i=l}^{r-1}(i-l+1)(r-i)a_i\\
&=\sum_{i=l}^{r-1}(ir-i^2-lr+li+r-i)a_i\\
&=-\sum_{i=l}^{r-1}i^2a_i+(r+l-1)\sum_{i=l}^{r-1}i\cdot a_i-r(l-1)\sum_{i=l}^{r-1}a_i\\
&=-S_3(l,r-1)+(r+l-1)S_2(l,r-1)-r(l-1)S_1(l,r-1)
\end{aligned}
$$

其中 $S_1(l,r)=\sum_{i=l}^r a_i$，$S_2(l,r)=\sum_{i=l}^r i\cdot a_i$，$S_3(l,r)=\sum_{i=l}^r i^2a_i$。

$1^2+2^2+\cdots+x^2=\frac{x(x+1)(2x+1)}{6}$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,m,l,r,v,tg[N<<2];
char o[5];
struct node{
	ll s1,s2,s3;
	node operator+(node a){return {s1+a.s1,s2+a.s2,s3+a.s3};}
}s[N<<2];
void upd(int p,int l,int r,int v){
	auto S=[&](int x,int o){return o?1ll*(1+x)*x/2:1ll*x*(x+1)*(2*x+1)/6;};
	s[p].s1+=(r-l+1)*v,s[p].s2+=(S(r,1)-S(l-1,1))*v,s[p].s3+=(S(r,0)-S(l-1,0))*v,tg[p]+=v;	//某 sb 写成了 s[p].s1+=v
}
void down(int p,int l,int r,int mid){
	if(tg[p]) upd(p<<1,l,mid,tg[p]),upd(p<<1|1,mid+1,r,tg[p]),tg[p]=0;
}
void modify(int p,int l,int r,int lx,int rx,int v){
	if(l>=lx&&r<=rx) return upd(p,l,r,v);
	int mid=(l+r)/2;
	down(p,l,r,mid);
	if(lx<=mid) modify(p<<1,l,mid,lx,rx,v);
	if(rx>mid) modify(p<<1|1,mid+1,r,lx,rx,v);
	s[p]=s[p<<1]+s[p<<1|1];
} 
node query(int p,int l,int r,int lx,int rx){
	if(lx>rx) return {0,0,0};
	if(l>=lx&&r<=rx) return s[p];
	int mid=(l+r)/2;
	down(p,l,r,mid);
	if(rx<=mid) return query(p<<1,l,mid,lx,rx);
	if(lx>mid) return query(p<<1|1,mid+1,r,lx,rx);
	return query(p<<1,l,mid,lx,rx)+query(p<<1|1,mid+1,r,lx,rx); 
}
signed main(){
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%s%d%d",o+1,&l,&r);
		if(o[1]=='C') scanf("%d",&v),modify(1,1,n,l,r-1,v);
		else{
			node t=query(1,1,n,l,r-1);
			ll x=-t.s3+(r+l-1)*t.s2-1ll*r*(l-1)*t.s1,y=1ll*(r-l+1)*(r-l)/2,d=__gcd(x,y);
			printf("%lld/%lld\n",x/d,y/d);
		}
	}
	return 0;
}
```

#### E3

2022.6.18 CF446C DZY Loves Fibonacci Numbers（\*2400）

> 支持区间加（从第一项开始的）斐波那契，询问区间和。$n,m\leq 10^5$。

方法一：会求斐波那契区间和即可。

$\sum_{i=1}^n F_i=\sum_{i=1}^n (F_{i+2}-F_{i+1})=F_{n+2}-F_2$。

若干个斐波那契数列相加，仍然满足斐波那契数列的性质，只是 $f_1,f_2$ 改变了。

方法二：
$$
F_n=\frac{1}{\sqrt 5}(\frac{1+\sqrt 5}{2})^n-\frac{1}{\sqrt 5}(\frac{1-\sqrt 5}{2})^n
$$
转化为区间加等比数列。

处理根号：扩域（如 P5320）。类似表示虚数的方法，将每个数表示成 $A+B\sqrt 5$，加减乘除照样定义。由于最后区间和一定不包含 $\sqrt 5$，所以答案中的 $B$ 一定是 $0$。

而此题 $\sqrt 5$ 在 $\bmod 10^9+9$ 意义下有二次剩余，所以可以不扩域。

### 均摊技巧

#### F1

trick：一个数 $\bmod$ 完一个比它小的数后大小减半。

> 维护一个长度为 $n$ 的序列，$m$ 次操作，支持区间对 $x$ 取模，询问区间和。
>
> $n,m\leq 10^5$。

- 若 $a<x$：$a\bmod x=x$。
- 若 $a\geq x$：由于 $a=\lfloor\frac a x\rfloor x+(a\bmod x)$，那么 $x+(a\bmod x)\leq a$，而 $a\bmod x\leq x$，所以 $2(a\bmod x)\leq a$。因此，$a\bmod x\leq \frac a 2$。

线段树，若区间最大值 $<x$ 就不递归，否则暴力修改。由于一个数如果 $\geq x$，取模后至少减半，所以每个数至多被取模 $\log V$ 次。

时间复杂度 $\mathcal O(m\log n\log V)$。

#### F2

UOJ#228. 基础数据结构练习题

> 支持区间加，区间开根号（向下取整），询问区间和。
>
> $n,m\leq 10^5$。

一个区间里的数开根号极差会变小。区间加对极差的改变不大。

若线段树一个区间 $\max=\min$，区间开根打个区间覆盖的 tag 即可；否则暴力修改。

设 $x$ 表示线段树有多少 $\max-\min>1$ 的节点。一次区间加可以使 $x$ 增加 $\mathcal O(\log n)$（只有区间交界处的节点可能会变，区间中间节点不会变）。但一个节点被开 $\log\log V$ 次根后就不是 $\max-\min>1$ 的点了（取模是 $\log V$，开根相当于它的 $\log$ 每次减半，所以是 $\log\log V$）。

因此 $x$ 总变化量 $\mathcal O(m\log n)$。总复杂度 $\mathcal O(m\log n\log \log V)$。

#### F3

> 支持区间加，询问区间 $\gcd$。$n,m\leq 10^5$。

辗转相减法的推论：$\gcd(x,y,z)=\gcd(x,y-x,z-y)$，推广到 $n$ 个数也成立。

> 证明：设 $\gcd(x,y,z)=a$，$x=m_1a,y=m_2a,z=m_3a$，$m_1,m_2,m_3$ 互质。
>
> $\gcd(x,y-x,z-y)=\gcd(m_1a,(m_2-m_1)a,(m_3-m_2)a)$，由于 $m_1,m_2,m_3$ 互质，所以 $m_1,m_2-m_1,m_3-m_2$ 必然也互质，所以 $\gcd(x,y-x,z-y)=a=\gcd(x,y,z)$。

$\gcd(a_l,a_{l+1},a_{l+2},\cdots,a_r)=\gcd(a_l,a_{l+1}-a_l,a_{l+2}-a_{l+1},\cdots,a_r-a_{r-1})$，那么差分将区间加变为单点加。用线段树维护差分数组的 $\gcd$，修改就暴力修改，pushup 时就更新一下，再维护一下原序列即可（为了求 $a_l$）。

#### HDU 5634 Rikka with Phi

> 给出 $a_{1\sim n}$，初始全为 $1$。
>
> 1. `l r`：$\forall i\in[l,r]$，$a_i\gets \varphi(a_i)$。
> 2. `l r x`：$\forall i\in[l,r]$，$a_i\gets x$。
> 3. 求区间和。

操作 1 做 $\mathcal O(\log n)$ 次就变成 $1$ 了（因为奇数的 $\varphi$ 一定是偶数，偶数的 $\varphi$ 一定减半），如果没有 2 就可以暴力线段树了：只有区间 $\max>1$ 才递归。

优化：当区间所有数都相同，变成区间覆盖。这样就能过了。因为每一次操作 2 会加 $\mathcal O(1)$ 段数，这些段会多取 $\varphi$ $\mathcal O(\log n)$ 次，总共会多操作 $\mathcal O(n\log n)$ 次。

#### HDU  6315

<img src="https://s2.loli.net/2025/12/10/2dfFxI1N4DBmrHG.png" alt="image.png" style="zoom:67%;" />

<img src="https://s2.loli.net/2025/12/10/PHUfQgdrMxLiNRa.png" alt="image.png" style="zoom:67%;" />

### 杂题

#### E2

> 给出三元组序列 $a_{1\sim n}$，每个是 $(c,x,y)$ 表示颜色和坐标。
>
> 支持单点修改，询问区间颜色不同的两个点的曼哈顿距离最大值。
>
> $n,q\leq 10^5$，$c\leq 10^9$。

套路地用 $|a-b|=\max(a-b,b-a)$ 把绝对值拆掉。

<img src="https://s2.loli.net/2025/12/10/V5gztakMPFTNvUJ.png" alt="image" style="zoom:33%;" />

四种情况分别求 $\max$。以第一种为例，等价于 $(x_1+y_1)-(x_2+y_2)$，若没有颜色限制，找一个最大的 $x+y$ 和一个最小的 $x+y$ 即可。

处理颜色不同：小技巧，维护最大、次大、最小、次小的值和颜色。

#### [TJOI2016] 排序

> 给出一个排列 $a_{1\sim n}$，$m$ 次操作：
>
> - `0 l r`：将 $a_{l\sim r}$ 升序排序。
> - `1 l r`：将 $a_{l\sim r}$ 降序排序。
>
> 最后，给出 $p$，询问 $a_p$。
>
> $n,m\leq 10^5$。

<img src="https://s2.loli.net/2025/12/10/k7JcWOK6u1wHYFx.png" alt="image.png" style="zoom:67%;" />

#### P1712 [NOI2016] 区间

<img src="https://s2.loli.net/2025/12/10/9XdvGq5QCzDfMEh.png" style="zoom:67%;" />

将区间按长度排序。枚举最短区间，双指针扫最长区间，需要判断能否从一些区间中选出 $m$ 个使得包含公共点。

只需要把这些区间覆盖的位置 $+1$，查询最多覆盖次数是否 $\geq m$ 即可。

<img src="https://s2.loli.net/2025/12/10/tFYz9WnxadsN8ZE.png" style="zoom:67%;" />

#### P4198 楼房重建

> 给出 $a_{1\sim n}$，支持单点修改，每次求区间上升序列的长度，其中上升序列指由前缀最大值组成的序列。
>
> $n,q\leq 10^5$。

 维护 $ans$，合并两个区间时，先 $ans_p\gets ans_{lc_p}$，当前结尾是 $mx_{lc_p}$，要算 $rc_p$ 以 $mx_{lc_p}$ 开头的上升序列长度。

写一个 $G(p,pre)$ 算区间 $p$ 以 $pre$ 开始的上升序列长度：

- 若 $pre\geq mx_{lc_p}$，$G(p,pre)\gets G(rc_p,pre)$。
- 否则 $pre<mx_{lc_p}$，$G(p,pre)\gets G(lc_p,pre)+G(rc_p,mx_{lc_p})$，$G(rc_p,mx_{lc_p})$ 与 $pre$ 无关。发现 $ans_p=G(p,0)=G(lc_p,0)+G(rc_p,mx_{lc_p})$，所以 $G(rc_p,mx_{lc_p})=ans_p-ans_{lc_p}$。

现在两种情况都只往一边递归，算一次 $G$ 是 $\mathcal O(\log n)$ 的。

#### CF765F Souvenirs

> 给出 $a_{1\sim n}$，$q$ 次询问 $a_{l\sim r}$ 中相差最小的两个数的差。
>
> $n,q\leq 2\times 10^5$。

离线，枚举 $r$，$seg_l$ 表示 $[l,r]$ 的答案。

以 $a_x>a_r$ 为例。找 $x<r,a_x>a_r$ 的最大的 $x$，用 $a_x-a_r$ 更新 $seg_{1\sim x}$；再找次大的 $y$，用 $a_y-a_r$ 更新 $seg_{1\sim y}$，以此类推。由于 $a_x-a_y$ 也更新了 $seg_{1\sim y}$，所以有用的 $y$ 满足 $a_y-a_r<a_x-a_y$，$a_y<\frac{a_x+a_r}{2}$。每次值域减半。

#### P2757 [国家集训队]等差子序列 / CF452F Permutation（\*2700）

> 一个长度为 $n$ 的排列 $A$，问是否存在 $1\leq x<y<z\leq n$ 使得 $A_x,A_y,A_z$ 构成等差数列。
>
> $n\leq 10^5$。

枚举 $y$ 和公差 $t$，判断 $A_y-t,A_y+t$ 是否分别在 $A_y$ 两边。

设权值线段树上第 $i$ 个位置为 $c_i$。对于 $1\leq x<y$，将 $c_{A_x}$ 改为 $1$，对于 $y<z\leq n$，将 $c_{A_y}$ 改为 $0$。问题转化为判断是否存在 $t$，使得 $c_{A_y-t}\neq c_{A_y+t}$。

我们只需判断它的否命题：$\forall t$，$c_{A_y-t}=c_{A_y+t}$。

即以 $A_y$ 为中心，$[A_y-(n-A_y),n]$ 或 $[1,A_y+(A_y-1)]$ 是否是一个回文区间。正着 = 反着。如果是字符串，哈希。那么 $01$ 串也可以哈希，线段树维护正串和反串的哈希，合并 $[l,mid],[mid+1,r]$ 时，正串 $h_{[l,mid]}+h_{[mid+1,r]}\times c^{mid-l+1}$，反串 $h'_{[l,mid]}\times c^{r-mid}+h'_{[mid+1,r]}$。

当 $y\to y+1$ 时，$y$ 变到左边去了，$c_{A_y}\gets 1$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e5+5,c=131;
int n,a[N],x;
ll pw[N],s[N<<2],s2[N<<2];
void modify(int p,int l,int r,int pos){
	if(l==r){s[p]=s2[p]=1;return ;}
	int mid=(l+r)/2;
	if(pos<=mid) modify(p<<1,l,mid,pos);
	else modify(p<<1|1,mid+1,r,pos);
	s[p]=s[p<<1]+s[p<<1|1]*pw[mid-l+1];
	s2[p]=s2[p<<1]*pw[r-mid]+s2[p<<1|1];
}
ll query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return s[p];
	int mid=(l+r)/2;
	if(rx<=mid) return query(p<<1,l,mid,lx,rx);
	if(lx>mid) return query(p<<1|1,mid+1,r,lx,rx);
	return query(p<<1,l,mid,lx,rx)+query(p<<1|1,mid+1,r,lx,rx)*pw[mid-max(l,lx)+1];
} 
ll query2(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return s2[p];
	int mid=(l+r)/2;
	if(rx<=mid) return query2(p<<1,l,mid,lx,rx);
	if(lx>mid) return query2(p<<1|1,mid+1,r,lx,rx);
	return query2(p<<1,l,mid,lx,rx)*pw[min(r,rx)-mid]+query2(p<<1|1,mid+1,r,lx,rx);
}
signed main(){
	scanf("%d",&n),pw[0]=1;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),pw[i]=pw[i-1]*c;
	for(int i=1;i<=n;i++){
		int x=min(a[i]-1,n-a[i]);
		if(x&&query(1,1,n,a[i]+1,a[i]+x)!=query2(1,1,n,a[i]-x,a[i]-1)) puts("YES"),exit(0);
		modify(1,1,n,a[i]);
	}
	puts("NO");
	return 0;
}
```

### BZOJ 3489（弱化版）

> 给出一个长度为 $n$ 的序列，$m$ 次查询区间 $[l,r]$ 中有多少值只出现一次。

转化为 **值对区间的贡献**。对于每个位置 $i$，预处理它左边和右边第一个与它相同的数的位置 $pre_i,nxt_i$，那么 $i$ 只会对 $l\in(pre_i,i],r\in[i,nxt_i)$ 的询问 $[l,r]$ 有贡献。

构造二维平面，每个位置 $i$ 的贡献的范围对应平面上一个矩形 $(pre_i,i],[i,nxt_i)$，查询的区间 $[l,r]$ 对应平面上一个点 $(l,r)$，那么就转化为了点 $(l,r)$ 被多少矩形覆盖了。

**总结：**把询问 $[l,r]$ 看作平面上一个点，值对询问的贡献是一个矩形，扫描线，$n$ 次矩阵加，$m$ 次点查询。

#### P4121 [WC2005]双面棋盘

> 一个 $n\times n$ 的黑白棋盘。操作：把 $(x,y)$ 的颜色取反，每次操作后分别输出黑白连通块个数（四连通）。
>
> $n\leq 100$，$q\leq 10^4$。非 $\mathcal O(n^2q)$。

线段树套并查集。线段树的第 $i$ 个叶子维护第 $i$ 行的连通情况。合并左右儿子时，相当于合并左儿子的最后一行、右儿子的第一行，枚举每一列，如果这两行在这一列同色就 `merge`。

每个节点只要存节点对应那些行的第一行和最后一行。

单点修改时，$\mathcal O(\alpha n)$ 重建该行的并查集，向上合并。合并时并查集复杂度是 $\mathcal O(\alpha n)$ 的，总共进行 $\mathcal O(\log n)$ 次合并。总时间复杂度 $\mathcal O(q\alpha n\log n)$。

```cpp
#include<bits/stdc++.h>
#define id(x,y) (x-1)*n+y
using namespace std;
const int N=210;
int n,m,a[N][N],x,y,f[N*N];
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
struct node{
	int fst[N],lst[N],c[2];
	void set(int x){
		for(int i=1;i<=n;i++) f[id(x,i)]=id(x,i);
		c[0]=c[1]=0;
		for(int i=1;i<=n;i++){
			if(i>1&&a[x][i]==a[x][i-1]) f[find(id(x,i))]=find(id(x,i-1));
			else c[a[x][i]]++;
		}
		for(int i=1;i<=n;i++) fst[i]=lst[i]=f[id(x,i)];
	}
	friend node merge(node x,node y,int mid){
		node p;
		for(int i=1;i<=n;i++)
			f[x.fst[i]]=x.fst[i],f[x.lst[i]]=x.lst[i],
			f[y.fst[i]]=y.fst[i],f[y.lst[i]]=y.lst[i]; 
		p.c[0]=x.c[0]+y.c[0],p.c[1]=x.c[1]+y.c[1];
		for(int i=1;i<=n;i++)
			if(a[mid][i]==a[mid+1][i]&&find(x.lst[i])!=find(y.fst[i]))
				f[find(x.lst[i])]=find(y.fst[i]),p.c[a[mid][i]]--;
		for(int i=1;i<=n;i++) p.fst[i]=find(x.fst[i]),p.lst[i]=find(y.lst[i]);	//一定要 find！因为有可能两个中间颜色不同的点能通过上下的颜色连通
		return p;
	}
}s[N<<2];
void build(int p,int l,int r){
	if(l==r) return s[p].set(l);
	int mid=(l+r)/2;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	s[p]=merge(s[p<<1],s[p<<1|1],mid);
}
void modify(int p,int l,int r,int pos){
	if(l==r) return s[p].set(l);
	int mid=(l+r)/2;
	if(pos<=mid) modify(p<<1,l,mid,pos);
	else modify(p<<1|1,mid+1,r,pos);
	s[p]=merge(s[p<<1],s[p<<1|1],mid);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) scanf("%d",&a[i][j]);
	build(1,1,n),scanf("%d",&m);
	while(m--){
		scanf("%d%d",&x,&y),a[x][y]^=1,modify(1,1,n,x);
		printf("%d %d\n",s[1].c[1],s[1].c[0]);
	}
	return 0;
}
```

#### CF526F Pudding Monsters（\*3000）

> 给出一个 $n\times n$ 的棋盘，其中有 $n$ 个棋子，每行每列恰好有一个棋子。
>
> 求有多少 $k\times k$ 的子棋盘中恰好有 $k$ 个棋子，$k\in[1,n]$。
>
> $1\leq n\leq 3\times 10^5$。

由于每行每列只有一个棋子，设 $a_i$ 表示第 $i$ 行的棋子在哪列，$a$ 是一个排列。那么 $k\times k$ 的子棋盘中恰好有 $k$ 个棋子，等价于存在 $a$ 的一个长度为 $k$ 的子区间，使得这个子区间中的数连续。

而 $[l,r]$ 连续又等价于 $(\max-\min)-(r-l)=0$。这是一个经典问题，扫描线 $r$，单调栈维护 $\max,\min$ 的变化，维护线段树区间最小值 `mn` 及个数 `cnt` 来维护 $0$ 的个数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,x,y,a[N],tg[N<<2],mn[N<<2],cnt[N<<2],t1,t2,s1[N],s2[N];
long long ans;
void push(int p){
	mn[p]=min(mn[p<<1],mn[p<<1|1]);
	cnt[p]=(mn[p<<1]==mn[p])*cnt[p<<1]+(mn[p<<1|1]==mn[p])*cnt[p<<1|1];
}
void upd(int p,int v){tg[p]+=v,mn[p]+=v;}
void down(int p){
	if(tg[p]) upd(p<<1,tg[p]),upd(p<<1|1,tg[p]),tg[p]=0;
}
void build(int p,int l,int r){
	if(l==r){mn[p]=l,cnt[p]=1;return ;}
	int mid=(l+r)/2;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push(p);
}
void modify(int p,int l,int r,int lx,int rx,int v){
	if(l>=lx&&r<=rx) return upd(p,v);
	int mid=(l+r)/2;
	down(p);
	if(lx<=mid) modify(p<<1,l,mid,lx,rx,v);
	if(rx>mid) modify(p<<1|1,mid+1,r,lx,rx,v);
	push(p);
}
int query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return !mn[p]?cnt[p]:0;
	int mid=(l+r)/2,ans=0;
	down(p);
	if(lx<=mid) ans=query(p<<1,l,mid,lx,rx);
	if(rx>mid) ans+=query(p<<1|1,mid+1,r,lx,rx);
	return ans;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&x,&y),a[x]=y;
	build(1,1,n);
	for(int i=1;i<=n;i++){
		while(t1&&a[i]<a[s1[t1]]) modify(1,1,n,s1[t1-1]+1,s1[t1],a[s1[t1]]-a[i]),t1--;
		while(t2&&a[i]>a[s2[t2]]) modify(1,1,n,s2[t2-1]+1,s2[t2],a[i]-a[s2[t2]]),t2--;
		s1[++t1]=s2[++t2]=i;
		modify(1,1,n,1,n,-1),ans+=query(1,1,n,1,i);
	}
	printf("%lld\n",ans);
	return 0;
}
```
