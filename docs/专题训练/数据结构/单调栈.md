#### 基础应用

> 求每个数左边第一个比它大的数。

若 $j<i$ 且 $a_j<a_i$，则 $i+1\sim n$ 左边第一个比它大的数一定不可能是 $a_j$。于是可以把 $a_j$ 扔掉。这就是单调栈的原理，最后没有扔掉的是单调递减的。每次加入一个数就扔掉它前面栈里一段连续的数。

不难发现，处理完 $1\sim i$ 后，栈顶就是 $i+1$ 左边第一个比它大的数。

#### 本质

假设处理了 $1\sim i$。栈中实际上是维护了一段一段的后缀最大值 $\max_j a_{j\sim i}$（**后缀最大值是递减的，分段后存在栈中**）。

新加入 $a_{i+1}$ 后，原来那些比 $a_{i+1}$ 小的后缀最大值会更新为 $a_{i+1}$，比 $a_{i+1}$ 大的不变。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829091909913-1373135342.png" alt="image" style="zoom: 50%;" />

#### A1

> 求 $\sum_{l=1}^n\sum_{r=l}^n\max(a_{l\sim r})$。

子区间 = 前缀的后缀。枚举 $r$，维护 $1\sim r$ 所有后缀最大值的和。而单调栈就是维护了一段一段后缀最大值：

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829094937488-2132498544.png" alt="image" style="zoom: 50%;" />

也可以枚举区间最大值的位置，看贡献到多少个区间。或笛卡尔树。

#### A2

> 变成区间询问。$f(x,y)=\sum_{l=x}^y\sum_{r=l}^y \max(a_{l\sim r})$。询问 $f(x,y)$。
>
> $\mathcal O((n+q)\log n)$。

离线。枚举 $r$，处理 $y=r$ 的询问。

设 $b_i=\max(a_{i\sim r})$，$f(x,y)=f(x,y-1)+\sum_{i=x}^y b_i$。

//...

线段树维护区间加一次函数 $ax+b$，线段树上维护一次函数的 $a,b$ 值即可（见 P4458）。

#### A3

> 给出 $a_{1\sim n}$，求 $\max(a_{l\sim r})\times (a_r-a_l+1)$ 的最大值。

这样相乘的东西，一个套路是枚举其中一项。单调栈很大的一个作用是把式子中的区间最大值拿掉。

枚举 $\max(a_{l\sim r})=a_x$，能得到区间最大值为 $a_x$ 的区间范围 $L,R$，在 $[x,R]$ 找一个最大的数 $a_r$，$[L,x]$ 找一个最小的数 $a_l$ 即可。

#### A4

> 求全 $1$ 最大子矩阵的面积。$n\leq 5000$。

枚举子矩阵的底边是哪行，预处理这行每个位置最多能往上延伸 $h_x$ 个 $1$（$\mathcal O(n^2)$ 预处理 $up_{x-1,y}\to up_{x,y}$）。

对于左右边界 $l,r$，面积 $\min(h_{l\sim r})\times (r-l+1)$。枚举 $\min(h_{l\sim r})=h_x$，选符合条件的最大的 $r$ 和最小的 $l$。

#### A5

ZR#2312，拓展到环上 CF5E

> 给出 $a_{1\sim n}$，求有多少 $(x,y)$ 满足 $a_{x+1\sim y-1}\leq \min(a_x,a_y)$。$\mathcal O(n)$。

枚举 $y$，处理 $1\sim y-1$ 的单调栈。如果 $i$ 被弹掉了那么 $i+1\sim y-1$ 一定有比 $a_i$ 大的，所以符合条件的 $x$ 一定在单调栈中。另一种理解方式：单调栈的元素是后缀最大值。

首先单调栈中 $a_x<a_y$ 的 $x$，会在加入 $y$ 时弹掉。这些 $x$ 和 $y$ 都能组成答案。

并且栈顶 $x$ 和 $y$ 也能组成答案，因为虽然 $a_x>a_y$，但它们中间没有比 $a_x,a_y$ 更大的数了。

其余都无法和 $y$ 组成答案。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829103538290-1299485718.png" alt="image" style="zoom: 50%;" />

#### A6

> 给出一个 $n\times n$ 的矩形，元素有正有负，求和 $>0$ 的子矩形的面积最大值。
>
> $\mathcal O(n^3\log n)$。

枚举子矩形的上下边界 $u,d$，把一列压成一个元素，即 $a_j\gets \sum_{i=u}^d a_{i,j}$。

现在有 $a_{1\sim n}$，对于子矩形的左右边界 $l,r$，要求 $\sum_{i=l}^r a_i>0$ 且 $r-l+1$ 尽量大。

求出 $a_i$ 的前缀和 $b_i$。$b_r>b_{l-1}$。枚举 $r$，就是要找 $b_r>b_{l-1}$ 的最小的 $l$，即要找最左边的比它小的数。

若 $i<j$ 且 $b_i<b_j$，那么 $i$ 把 $j$ 打爆了，把 $j$ 弹掉。实际上是在维护前缀最小值，加入一个数时如果比栈顶大就把加入的这个数弹掉。

不在栈中的都被打爆了，只要考虑栈中的数。由于栈中的数单调递减，所以二分栈中第一个比 $b_r$ 大的数即可。

#### P3400 仓鼠窝

> 求 $01$ 矩阵中全 $1$ 子矩阵的数量。

首先预处理 $h_{i,j}$ 表示 $(i,j)$ 往上连续 $1$ 的最长长度。

考虑统计以 $(i,j)$ 为右下角的子矩形数量 $cnt_{i,j}$。单调栈求出 $(i,j)$ 左边第一个 $h_{i,k}\leq h_{i,j}$ 的位置 $(i,k)$，那么 $cnt_{i,j}=cnt_{i,k}+h_{i,j}\times (j-k)$。因为高度 $\leq h_{i,j}$ 的子矩阵在 $cnt_{i,k}$ 已经统计过了，$[k+1,j]$ 之间的 $h$ 一定都 $\geq h_{i,j}$。

时间复杂度 $\mathcal O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+5;
int n,m,x,h[N][N],top,s[N];
long long cnt[N],ans;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&x),h[i][j]=x?h[i-1][j]+1:0;
	for(int i=1;i<=n;i++){
		top=0;
		for(int j=1;j<=m;j++){
			while(top&&h[i][s[top]]>h[i][j]) top--;
			s[++top]=j;
			cnt[top]=cnt[top-1]+h[i][j]*(s[top]-s[top-1]);
			ans+=cnt[top];
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

另一个做法是，求出左边第一个高度 $\leq h_{i,j}$ 的位置 $l_{i,j}$，右边第一个高度 $<h_{i,j}$ 的位置 $r_{i,j}$，则 $ans=\sum(j-l_{i,j})(r_{i,j}-j)h_{i,j}$。不难发现不重不漏。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+5;
int n,m,x,h[N][N],top,s[N],l[N],r[N];
long long ans;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&x),h[i][j]=x?h[i-1][j]+1:0;
	for(int i=1;i<=n;i++){
		top=0;
		for(int j=1;j<=m+1;j++){
			while(top&&h[i][s[top]]>h[i][j]) r[s[top--]]=j;
			s[++top]=j;
		}
		top=0;
		for(int j=m;j>=0;j--){
			while(top&&h[i][s[top]]>=h[i][j]) l[s[top--]]=j;
			s[++top]=j; 
		}
		for(int j=1;j<=m;j++) ans+=1ll*h[i][j]*(j-l[j])*(r[j]-j);
	}
	printf("%lld\n",ans);
	return 0;
}
```

#### P5300 [GXOI/GZOI2019]与或和

按位考虑，转化为上题。

至少有一个 $1$ 的子矩阵数量 = 子矩阵总数量 $\binom{n+1}{2}^2$（把矩阵看成网格图，相当于选两条竖线和两条横线）- 全 $0$ 子矩阵数量。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5,mod=1e9+7;
int n,a[N][N],h[N][N],ra,ro,top,s[N],cnt[N],tot;
int calc(){
	int ans=0;
	for(int i=1;i<=n;i++){
		top=0;
		for(int j=1;j<=n;j++){
			while(top&&h[i][s[top]]>h[i][j]) top--;
			s[++top]=j;	//有个 sb 写成了 i
			cnt[top]=(cnt[top-1]+h[i][j]*(s[top]-s[top-1]))%mod;
			ans=(ans+cnt[top])%mod;
		}
	}
	return ans;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) scanf("%d",&a[i][j]);
	tot=n*(n+1)/2,tot=1ll*tot*tot%mod;
	for(int x=0;x<=30;x++){
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) h[i][j]=(a[i][j]>>x&1)?h[i-1][j]+1:0;
		ra=(ra+1ll*calc()*(1<<x)%mod)%mod;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) h[i][j]=!(a[i][j]>>x&1)?h[i-1][j]+1:0;
		ro=(ro+1ll*(tot-calc()+mod)%mod*(1<<x)%mod)%mod;
	}
	printf("%d %d\n",ra,ro);
	return 0;
}
```

#### P1169 [ZJOI2007]棋盘制作

> 分别求 $01$ 矩阵中 $01$ 交错的最大正方形与矩形面积。

将横纵坐标和为偶数的点取反，转化为最大同色的正方形/矩形。

以 $0$ 为例，一个 DP 做法是设 $f_{i,j}$ 表示以 $(i,j)$ 为右下角的最大正方形边长，若 $a_{i,j}=0$，则 $f_{i,j}=\min(f_{i-1,j-1},f_{i-1,j},f_{i,j-1})+1$，否则 $f_{i,j}=0$；也可以在算矩形的时候求最大正方形边长。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int n,m,a[N][N],h[N][N],l[N],r[N],top,s[N],mx[N],ans,len;
void calc(int x){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) h[i][j]=a[i][j]==x?h[i-1][j]+1:0;
	for(int i=1;i<=n;i++){
		top=0;
		for(int j=1;j<=m+1;j++){
			while(top&&h[i][s[top]]>h[i][j]) r[s[top--]]=j;
			s[++top]=j;
		}
		top=0;
		for(int j=m;j>=0;j--){
			while(top&&h[i][s[top]]>=h[i][j]) l[s[top--]]=j;
			s[++top]=j; 
		}
		for(int j=1;j<=m;j++)
			ans=max(ans,(r[j]-l[j]-1)*h[i][j]),len=max(len,min(r[j]-l[j]-1,h[i][j]));
	}
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]),a[i][j]^=(i+j)&1;
	calc(0),calc(1);
	printf("%d\n%d\n",len*len,ans);
	return 0;
}
```

#### P3474 [POI2008]KUP-Plot purchase

> 给出 $k,n$，求一个子矩形满足权值和 $\in[k,2k]$。输出横纵坐标要反一下。
>
> $n<2000$，$1\leq k\leq 10^9$，$0\leq a_{i,j}\leq 2\times 10^9$。

首先如果存在 $a_{i,j}\in[k,2k]$，直接选它就行了。剩下的就只有 $<k$ 的可选和 $>2k$ 的不可选。

由于是求一个矩形，所以可以先单调栈求出最大的由 $<k$ 的数组成的矩形。这个矩形的和可能 $>2k$，所以要不断切割这个矩形直到 $\in[k,2k]$。

二维前缀和 $\mathcal O(1)$ 计算矩形的和，时间复杂度 $\mathcal O(n^2)$。