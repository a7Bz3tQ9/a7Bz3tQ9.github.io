#### 一、斜率优化

形如 $f_i=\min/\max\{f_j+cost_j+cost_i-F_iF_j\}$（一些只和 $i,j$ 有关的项 + **一个** 和 $i,j$ 都有关的项）。

改写为 $f_j+cost_j=F_iF_j+(f_i-cost_i)$。记 $y_j=f_j+cost_j$，$k=F_i$，$x_j=F_j$，$b=f_i-cost_i$，变为 $y_j=kx_j+b$ 的形式，对应一条直线，而每个 DP 的决策 $(x_j,y_j)$ 对应一个点。

以 $\min$ 为例。要让 $f_i$ 最小，则截距 $b=f_i-cost_i$ 最小。想象一条斜率固定为 $k$ 的直线从下往上移动，直至碰到第一个决策点 $(x_j,y_j)$，此时截距 $b$ 最小。

不难发现，可能成为最优决策的点（红点）形成一个下凸壳，而蓝点不是：若直线经过蓝点，则直线与凸壳相交，一定可以向下平移使直线和凸壳相切，此时更优。如果题目要求是 $\max$ 则是上凸壳。

<img src="https://img2022.cnblogs.com/blog/1859218/202207/1859218-20220703211116733-1896265984.png" alt="image" style="zoom: 33%;" />

#### 二、k,x 都单调

找到 $p_i$ 满足 $slope(p_i,p_{i+1})\geq k,slope(p_{i-1},p_i)<k$，则斜率为 $k$ 的直线和凸壳在 $p_i$ 处相切，$p_i$ 为最优决策（是否取等无影响，因为若 $slope(p_i,p_{i+1})=k$，$p_i,p_{i+1}$ 都是最优决策）。

如果 $i$ 分别对应的 $k$ 是单调递增的，可以用双端队列。设 $q_{l\sim r}$ 为队列，$x$ 为新加入的点。假设 $x_j$ 单调递增，这样新加的点一定在凸壳尾部。 

- 若 $slope(q_l,q_{l+1})<k$，就弹掉 $q_l$，不断重复除非只剩一个点了。最后 $q_l$ 就是最优决策：因为 $slope(q_l,q_{l+1})\geq k,slope(q_{l-1},q_l)<k$。
- 根据下凸壳的性质，队列中相邻两点组成的直线，斜率单调递增，需要不断弹掉当前队尾会破坏单调性的决策，即若 $slope(q_{r-1},q_r)\geq slope(q_r,x)$，就弹掉 $q_r$。

upd on 2023.11.7：学会一种用叉积代替 `slope` 的写法。判断 $slope(q_l,q_{l+1})$ 是否 $<k$ 时，只要判一下向量 $\vec{q_lq_{l+1}}$ 与向量 $(1,k)$（斜率的定义，它的斜率恰好是 $k$）的叉积即可。

##### P3195 [HNOI2008]玩具装箱

2022.7.3

> 给出一个长度为 $n$ 的序列 $a$ 以及常数 $m$。将 $a$ 分为若干段，对于一段 $[l,r]$，代价为 $(r-l+\sum_{i=l}^r a_i-m)^2$。求分段的最小代价。
>
> $1\leq n\leq 5\times 10^4,1\leq m,a_i\leq 10^7$。

记 $s_i=i+\sum_{i=1}^i a_i$。设 $f_i$ 表示前 $i$ 个数分段的最小代价，$f_i=\min\limits_{1\leq j<i}\{f_j+(s_i-s_j-(m+1))^2\}$。化简得 $\underline{f_j+s_j^2}_{\ y}=\underline{2(s_i-(m+1))}_{\ k}\times \underline{s_j}_{\ x}+\underline{f_i-(s_i-(m+1))^2}_{\ b}$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e4+5;
int n,m,x,q[N];
ll s[N],f[N];
ll get(int x){return f[x]+1ll*s[x]*s[x];}
double slope(int i,int j){
	return 1.0*(get(i)-get(j))/(s[i]-s[j]);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&x),s[i]=s[i-1]+x+1;
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&slope(q[l],q[l+1])<=2*(s[i]-(m+1))) l++;
		f[i]=f[q[l]]+1ll*(s[i]-s[q[l]]-(m+1))*(s[i]-s[q[l]]-(m+1));
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

##### 2. P3648 [APIO2014]序列分割

2022.7.3

> 给出一个长度为 $n$ 的非负整数序列 $a$。先要将序列分为 $k+1$ 个非空的块。为了得到 $k+1$ 块，你需要重复下面的操作 $k$ 次：
>
> 1. 选择一个有超过一个元素的块（初始时你只有一块，即整个序列）；
> 2. 选择两个相邻元素把这个块从中间分开，得到两个非空的块。
>
> 每次操作后将获得那两个新产生的块的元素和的乘积的分数。最大化最后的总得分，要求输出方案。
>
> $2\leq n\leq 10^5,1\leq k\leq \min(n-1,200),0\leq a_i\leq 10^4$。

首先答案与切的顺序无关，和切了哪些部分有关。

记 $s_i$ 为 $a_i$ 的前缀和。设 $f_{i,p}$ 表示前 $i$ 个数分 $p$ 块的最大分数，$f_{i,p}=\max\limits_{0\leq j<i}\{f_{j,p-1}+s_j(s_i-s_j)\}$，化简得 $\underline{f_{j,p-1}-s_j^2}_{\ y}=\underline{-s_i}_{\ k}\underline{s_j}_{\ x}+\underline{f_{i,p}}_{\ b}$。

由于 $a_i$ 可能为 $0$，注意特判 $slope=0$ 的情况（$s_i=s_j$）。转移记录最优决策点。$\max$ 就维护一个上凸壳。

时间复杂度 $\mathcal O(nk)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5,M=210;
int n,k,a[N],cur=1,pre,p[N][M],q[N];
ll s[N],f[2][N];
ll get(int x){return f[pre][x]-s[x]*s[x];}
double slope(int i,int j){
	return s[i]==s[j]?1e18:1.0*(get(i)-get(j))/(s[i]-s[j]);	//注意是 inf
}
void dfs(int i,int j){
	if(i) dfs(p[i][j],j-1),printf("%d ",i);
}
signed main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) 
		scanf("%d",&a[i]),s[i]=s[i-1]+a[i];
	for(int j=1;j<=k;j++){
		int l=0,r=0;
		swap(cur,pre);
		for(int i=1;i<=n;i++){
			while(l<r&&slope(q[l],q[l+1])>=-s[i]) l++;
			f[cur][i]=f[pre][q[l]]+s[q[l]]*(s[i]-s[q[l]]),p[i][j]=q[l];
			while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i)) r--;
			q[++r]=i; 
		}
	}
	printf("%lld\n",f[cur][n]),dfs(p[n][k],k-1);	//注意是 k-1 不是 k
	return 0;
}
```

##### 3. P6047 丝之割

2022.7.4

> 有 $m$ 条弦，一条弦可以抽象为一个二元组 $(u,v)$。每次你可以选择 $i,j\in[1,n]$，将所有满足 $u>i,v<j$ 的弦 $(u,v)$ 破坏，需要 $a_i\times b_j$ 的代价。
>
> 求破坏所有弦的最小代价。
>
> $1\leq n,m\leq 3\times 10^5$，$2\leq u\leq n$，$1\leq v<n$，$1\leq a_i,b_i\leq 10^6$。

首先，若两条弦 $(u_i,v_i),(u_j,v_j)$ 满足 $u_i\leq u_j$ 且 $v_i\geq v_j$，那么 $j$ 显然是无用的，因为割掉 $i$ 的同时一定能割掉 $j$。因此有用的弦一定满足 $u_i,v_i$ 同时单调递增。

设 $f_i$ 表示割掉前 $i$ 条弦的最小代价。记 $a'_i$ 为 $a_i$ 的前缀最小值，$b'_i$ 为 $b_i$ 的后缀最小值，那么 $f_i=\min\limits_{0\leq j<i}\{f_j+a'_{u_{j+1}-1}\times b'_{v_i+1}\}$。化简得 $\underline{f_j}_{\ y}=\underline{b'_{v_i+1}}_{\ k}\underline{-a'_{u_{j+1}-1}}_{\ x}+\underline{f_i}_{\ b}$。

注意为了让 $k$ 是递增的，$k$ 不能是 $-b'_{v_i+1}$；$x$ 可能相同。

时间复杂度 $\mathcal O(n+m\log m)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e5+5;
int n,m,cnt,a[N],b[N],l,r,q[N];
ll f[N];
struct node{
	int x,y;
}c[N]; 
int get(int i){return -a[c[i+1].x-1];}
double slope(int i,int j){
	return get(i)==get(j)?1e18:1.0*(f[i]-f[j])/(get(i)-get(j));
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=m;i++) scanf("%d%d",&c[i].x,&c[i].y);
	for(int i=2;i<=n;i++) a[i]=min(a[i],a[i-1]);
	for(int i=n-1;i>=1;i--) b[i]=min(b[i],b[i+1]);
	sort(c+1,c+1+m,[](node x,node y){return x.x!=y.x?x.x<y.x:x.y>y.y;});
	for(int i=1,r=0;i<=m;i++)
		if(c[i].y>r) c[++cnt]=c[i],r=c[i].y;
	m=cnt;
	for(int i=1;i<=m;i++){
		while(l<r&&slope(q[l],q[l+1])<=b[c[i].y+1]) l++;
		f[i]=f[q[l]]+1ll*a[c[q[l]+1].x-1]*b[c[i].y+1];
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[m]);
	return 0;
}
```

##### 4. CF311B Cats Transport（\*2400）

2022.7.4

>  $m$ 只猫，$p$ 位饲养员，$n$ 座山，第 $i$ 座山与第 $i−1$ 座山之间的距离是 $d_i$ 米。
>
>  第 $i$ 只猫在 $h_i$ 号山玩，玩到时刻 $t_i$ 停止，然后在原地等饲养员来接。每个饲养员从 $1$ 号山走到 $n$ 号山，把各座山上已经在等待的猫全部接走。饲养员的速度为 $1$ 米每单位时间，在每座山上接猫的时间可以忽略，可以携带的猫的数量为无穷大。
>
>  规划每个饲养员从 $1$ 号山出发的时间，使得所有猫等待时间的总和尽量小。饲养员出发的时间可以为负。
>
>  $2\leq n\leq 10^5$，$1\leq m\leq10^5$，$1\leq p\leq 100$，$1\leq d_i<10^4$，$1\leq h_i\leq n$，$0\leq t_i\leq 10^9$。

首先将所有 $t_i$ 减去 $\sum_{j=2}^{h_i}d_j$ 求出若要恰好接到第 $i$ 只猫要从哪一时刻出发。如果饲养员从 $T$ 时刻出发，则等待时间为 $T-t_i$。将 $t_i$ 从小到大排序，每个饲养员应该会带走一段连续区间的猫。

求出 $t$ 的前缀和 $s$。设 $f_{i,p}$ 表示用 $p$ 个饲养员接到前 $i$ 只猫的最小等待时间之和，$f_{i,p}=\min\limits_{0\leq j<i}\{f_{j,p-1}+(i-j)t_i-(s_i-s_j)\}$。化简得 $\underline{f_{j,p-1}+s_j}_{\ y}=\underline{t_i}_{\ k}\underline{j}_{\ x}+\underline{f_{i,p}-i\cdot t_i+s_i}_{\ b}$。

时间复杂度 $\mathcal O(mp)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,m,p,cur=1,pre,q[N];
ll d[N],t[N],s[N],f[2][N];
ll get(int i){return f[pre][i]+s[i];}
double slope(int i,int j){
	return 1.0*(get(i)-get(j))/(i-j);
}
signed main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=2;i<=n;i++) scanf("%lld",&d[i]),d[i]+=d[i-1];
	for(int i=1,h;i<=m;i++)
		scanf("%d%lld",&h,&t[i]),t[i]-=d[h];
	sort(t+1,t+1+m);
	for(int i=1;i<=m;i++) s[i]=s[i-1]+t[i];
	memset(f[cur],0x3f,sizeof(f[cur])),f[cur][0]=0;
	for(int j=1;j<=p;j++){
		int l=0,r=0;
		swap(cur,pre);
		for(int i=1;i<=m;i++){
			while(l<r&&slope(q[l],q[l+1])<=t[i]) l++;
			f[cur][i]=f[pre][q[l]]+(i-q[l])*t[i]-(s[i]-s[q[l]]);
			while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
			q[++r]=i;
		}
	}
	printf("%lld\n",f[cur][m]);
	return 0;
}
```

##### 5. P2365 任务安排

2022.7.6

> 有 $n$ 个任务，第 $i$ 个任务单独完成所需时间为 $t_i$。将 $n$ 个任务分为若干组，每组包含相邻的若干任务，在每组任务开始前，机器需要启动时间 $s$，完成这组任务的时间是各个任务所需时间之和。
>
> 同一组任务将在同一时刻完成。每个任务的费用是它的完成时刻 $\times f_i$。求最小总费用。
>
> $1\leq n\leq 5000$，$0\leq s\leq 50$，$1\leq t_i,f_i\leq 100$。

发现一组任务的完成时间依赖于分成的组数。考虑用费用提前计算的技巧计算 $s$ 的贡献，将启动时间 $s$ 对 $j+1\sim n$ 的所有任务的代价计算在内，而不仅仅是 $j+1\sim i$ 的任务。

设 $f_i$ 表示前 $i$ 个任务的最小费用加上当前 $s$ 的贡献，$f_i=\min\limits_{0\leq j<i}\{f_j+s(sf_n-sf_j)+st_i(sf_i-sf_j)\}$。化简得 $\underline{f_j-s\cdot sf_j}_{\ y}=\underline{st_i}_{\ k}\underline{sf_j}_{\ x}+\underline{f_i-st_isf_i-s\cdot sf_n}_{\ b}$。

时间复杂度 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+5;
int n,s,t[N],c[N],q[N];
ll f[N];
ll get(int i){return f[i]-s*c[i];}
double slope(int i,int j){
	return 1.0*(get(i)-get(j))/(c[i]-c[j]);
}
signed main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&t[i],&c[i]),t[i]+=t[i-1],c[i]+=c[i-1];
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&slope(q[l],q[l+1])<=t[i]) l++;
		f[i]=f[q[l]]+s*(c[n]-c[q[l]])+t[i]*(c[i]-c[q[l]]);
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
} 
```

##### 6. P2900 [USACO08MAR]Land Acquisition G

2022.7.6

> 有 $n$ 对 pair $(w_i,l_i)$，将其划分为若干组，每组的代价为 $(\max\limits_{i\in S}w_i)\times (\max\limits_{i\in S}l_i)$。求最小代价。
>
> $1\leq n\leq 5\times 10^4$，$w_i,l_i\leq 10^6$。

类似 P6047 丝之割，若 $(w_i,l_i),(w_j,l_j)$ 满足 $w_i\geq w_j$ 且 $l_i\geq l_j$，那么 $j$ 显然是无用的。将所有 pair 按 $w_i$ 从大到小排序，有用的 pair 满足 $l_i$ 递增。

设 $f_i$ 表示前 $i$ 个有用的 pair 的最小代价，$f_i=\min\limits_{0\leq j<i}\{f_j+w_{j+1}\times l_i\}$。化简得 $\underline{f_j}_{\ y}=\underline{l_i}_{\ k}\underline{-w_{j+1}}_{\ x}+\underline{f_i}_{\ b}$。

时间复杂度 $\mathcal O(n\log n)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int n,cnt,q[N];
long long f[N];
struct seg{int w,l;}a[N];
double slope(int i,int j){
	return 1.0*(f[i]-f[j])/(a[j+1].w-a[i+1].w);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].w,&a[i].l);
	sort(a+1,a+1+n,[](seg x,seg y){return x.w!=y.w?x.w>y.w:x.l>y.l;});
	for(int i=1,r=0;i<=n;i++)
		if(a[i].l>r) r=a[i].l,a[++cnt]=a[i];
	n=cnt;
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&slope(q[l],q[l+1])<=a[i].l) l++;
		f[i]=f[q[l]]+1ll*a[q[l]+1].w*a[i].l;
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

##### 7. CF1083E The Fair Nut and Rectangles（\*2400）

2022.7.6

> 有 $n$ 个左下角为 $(0,0)$、右上角为 $(x_i,y_i)$ 的矩形，保证两两不包含，每个矩阵有一个权值 $a_i$。选出若干矩形，求其面积并减去权值之和的最大值。
>
> $1\leq n\leq 10^6$，$1\leq x_i,y_i\leq 10^9$，$0\leq a_i\leq x_i\cdot y_i$。

由于矩阵不会互相包含，所以按 $x$ 递增排序后 $y$ 递减。

设 $f_i$ 表示前 $i$ 个矩形的答案且第 $i$ 个矩形必须选。枚举上一个选择的矩形，$f_i=\max\limits_{0\leq j<i}\{f_j+y_i(x_i-x_j)-a_i\}$。

$\underline{f_j}_{\ y}=\underline{y_i}_{\ k}\underline{x_j}_{\ x}+\underline{f_i-x_iy_i+a_i}_{\ b}$。维护一个上凸壳即可。

时间复杂度 $\mathcal O(n\log n)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
int n,q[N];
ll f[N],ans;
struct node{
	int x,y; ll a;
}a[N];
double slope(int i,int j){
	return 1.0*(f[i]-f[j])/(a[i].x-a[j].x);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%lld",&a[i].x,&a[i].y,&a[i].a);
	sort(a+1,a+1+n,[](node x,node y){return x.x<y.x;});
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&slope(q[l],q[l+1])>=a[i].y) l++;
		ans=max(ans,f[i]=f[q[l]]+1ll*a[i].y*(a[i].x-a[q[l]].x)-a[i].a);
		while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",ans);
	return 0;
}
```

##### 8. P5504 [JSOI2011] 柠檬

2022.7.6

> 给出一个长度为 $n$ 的序列 $a$，将其划分为若干段，每段选一个数，获得这个数 $\times$ 它在这段出现次数的平方 的价值。求最大总价值。
>
> $1\leq n\leq 10^5$，$1\leq a_i\leq 10^4$。

设 $f_i$ 表示前 $i$ 个数的最大总价值，$c_i$ 表示 $a_i$ 在 $a_{1\sim i}$ 出现了多少次。$f_i=\max\limits_{1\leq j\leq i\land a_i=a_j}\{f_{j-1}+a_i(c_i-c_j+1)^2\}$，$\underline{f_{j-1}+a_jc_j^2-2a_jc_j}_{\ y}=\underline{2a_ic_i}_{\ k}\underline{c_j}_{\ x}+\underline{f_i-a_ic_i^2-2a_ic_i-a_i}_{\ b}$.

要维护一个上凸壳，斜率单调递减，但 $k,x$ 单调递增，所以如果 $slope(q_{r-1},q_r)\leq k$ 就弹出 $q_r$（实际上是维护了一个单调栈），最后 $q_r$ 为最优决策。

注意 $j$ 可以为 $i$，每次要把 $i$ 先加入再转移。时间复杂度 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5,M=1e4+5;
int n,a[N],c[N],cnt[M];
ll f[N];
ll get(int i){return f[i-1]+1ll*a[i]*c[i]*c[i]-2*a[i]*c[i];} 
double slope(int i,int j){
	return 1.0*(get(i)-get(j))/(c[i]-c[j]);
}
struct dp{
	vector<int>q;
	int l=1,r=0;	//!!
	void calc(int i){
		while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i)) r--;
		q.resize(r+2),q[++r]=i;
		while(l<r&&slope(q[r-1],q[r])<=2*a[i]*c[i]) r--;
		f[i]=f[q[r]-1]+1ll*a[i]*(c[i]-c[q[r]]+1)*(c[i]-c[q[r]]+1);
	}
}t[M];
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),c[i]=++cnt[a[i]];
	for(int i=1;i<=n;i++) t[a[i]].calc(i);
	printf("%lld\n",f[n]);
	return 0;
}
```

##### 9. ZR#1435. 【20省选特训2】比赛（结合 cdq 分治）

2022.7.23

> 给出一个长度为 $n$ 的序列 $a$，要求选择一个 $a_i$ 非严格递增的子序列，收益为所选数的 $a_i$ 之和。并且，如果一个数不选，并且在它之前 **连续** 选择不选了 $x$ 个数，会损失 $x+1$ 的收益。
>
> 求可以获得的最大收益。
>
> $1\leq n\leq 10^5$。

处理连续：设 $f_i$ 表示考虑了前 $i$ 个数，强制选第 $i$ 个数的最大收益。$f_i=\max\limits_{j<i,a_j\leq a_i}\{f_j+a_i-\frac{(i-j-1)(i-j)}{2}\}$。

如果没有 $a_j\leq a_i$ 的限制：$\underline{f_j-\frac{j^2}{2}-\frac{j}{2}}_{\ y}=\underline{-i}_{\ k}\underline{j}_{\ x}+\underline{f_i+\frac{i^2}{2}-\frac i 2-a_i}_{\ b}$，维护上凸壳，斜率优化即可。

有 $a_j\leq a_i$：cdq 分治，先按 $a$ 排序，保证前一半的 $a$ 小于后一半，然后两边各按 $id$ 排。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,b[N],q[N];
ll f[N],ans=-1e18;
struct node{int x,id;}a[N];
ll F(int j,int i){return f[j]+b[i]-1ll*(i-j-1)*(i-j)/2;}	//注意这里写 b[i] 不是 a[i].x，因为 a[i] 是重新排过序的，a[i].x 不一定是 b[i]
double get(int i){return f[i]-0.5*i*i-0.5*i;}
double slope(int i,int j){return 1.0*(get(i)-get(j))/(i-j);}
void cdq(int l,int r){
	if(l==r){f[a[l].id]=max(f[a[l].id],F(0,a[l].id));return ;}
	int mid=(l+r)/2,j=l,L=0,R=0;
	cdq(l,mid);
	sort(a+l,a+1+mid,[](node x,node y){return x.id<y.id;});
	sort(a+mid+1,a+1+r,[](node x,node y){return x.id<y.id;});
	for(int i=mid+1;i<=r;i++){
		while(j<=mid&&a[j].id<a[i].id){
			while(L<R&&slope(q[R-1],q[R])<=slope(q[R],a[j].id)) R--;
			q[++R]=a[j++].id;
		}
		while(L<R&&slope(q[L],q[L+1])>=-a[i].id) L++;
		f[a[i].id]=max(f[a[i].id],F(q[L],a[i].id));
	}
	stable_sort(a+mid+1,a+1+r,[](node x,node y){return x.x<y.x;});
	cdq(mid+1,r);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]),a[i]={b[i],i},f[i]=-1e18;
	stable_sort(a+1,a+1+n,[](node x,node y){return x.x<y.x;});
	cdq(1,n);
	for(int i=0;i<=n;i++) ans=max(ans,f[i]-1ll*(n-i)*(n-i+1)/2);
	printf("%lld\n",ans);
	return 0; 
}
```

##### 10. P6302 [NOI2019] 回家路线 加强版

2022.7.26

> 有一张 $n$ 个点的图和三个参数 $A,B,C$，你需要从 $1$ 号点走到 $n$ 号点。
>
> 有 $m$ 条有向边（列车），每条有向边有一个出发时间 $p$ 和到达时间 $q$，只有在出发时间到达出发点才能选择走这条边。
>
> 走两条边的间隔可能存在等待时间，假设一次等待时间为 $x$，则需要花费 $Ax^2+Bx+C$ 的代价。
>
> 假设你在 $t$ 时刻到达 $n$ 号点，还需要额外花费 $t$ 的代价，求最小的总代价。
>
> $2\leq n\leq 10^5$，$1\leq m\leq 10^6$，$0\leq p_i<q_i\leq 4\times 10^4$。

设 $f_{x,i}$ 表示恰好在时刻 $i$ 到达点 $x$ 的最小代价，状态数巨大，无法接受。不如按边 DP：设 $f_i$ 表示搭乘第 $i$ 号列车的最小代价。
$$
f_i=\min_{y_j=x_i\land q_j\leq p_i}\{f_j+A(p_i-q_j)^2+B(p_i-q_j)+C\}
$$
处理 $q_j\leq p_i$：将每号列车拆成出发和到达两个事件并按时间排序。由于可以刚下车就上车，所以对于时刻相同的两个事件，到达应排在出发前。

斜率优化：$\underline{f_j+Aq_j^2-Bq_j}_{\ y}=\underline{2Ap_i}_{\ k}\underline{q_j}_{\ x}+\underline{f_i-Ap_i^2-Bp_i-C}_{\ b}$。由于按时间排序，所以 $k,x$ 有序。处理 $y_j=x_i$：对每个站点用单调队列实时维护下凸壳即可。

注意对 $x$ 相同，斜率不存在情况的处理。

```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=1e6+5;
int n,m,a,b,c,x[N],y[N],p[N],q[N];
ll f[N],ans=1e18;
vector<int>u[N],v[N];
struct dp{
	vector<int>Q;
	int l=1,r;	//初始 Q 为空
	ll Y(int i){return f[i]+1ll*a*q[i]*q[i]-1ll*b*q[i];}
	double slope(int i,int j){
		return q[i]==q[j]?(Y(j)>Y(i)?1e18:-1e18):1.0*(Y(j)-Y(i))/(q[j]-q[i]);	//注意 q[i]==q[j] 时的处理
	}
	void add(int i){
		while(l<r&&slope(Q[r-1],Q[r])>=slope(Q[r],i)) r--;
		Q.resize(r+2),Q[++r]=i;
	}
	void calc(int i){
		if(l>r) return ;
		while(l<r&&slope(Q[l],Q[l+1])<=2*a*p[i]) l++;
		int j=Q[l];
		f[i]=f[j]+1ll*a*(p[i]-q[j])*(p[i]-q[j])+1ll*b*(p[i]-q[j])+c;
	}
}s[N];
signed main(){
	scanf("%d%d%d%d%d",&n,&m,&a,&b,&c);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&x[i],&y[i],&p[i],&q[i]),f[i]=1e18;	//注意初始化 f[i]
		u[p[i]].push_back(i),v[q[i]].push_back(i);
	}
	s[1].Q.resize(2),s[1].Q[++s[1].r]=0;	//注意只有站点 1 初始队列中有 0，别的都为空
	for(int t=0;t<=4e4;t++){
		for(int j:v[t]) s[y[j]].add(j);
		for(int i:u[t]) s[x[i]].calc(i);
	}
	for(int i=1;i<=m;i++)
		if(y[i]==n) ans=min(ans,f[i]+q[i]);
	printf("%lld\n",ans);
	return 0;
}
```

#### 三、k 不单调，x 单调

##### 1. P5785 [SDOI2012]任务安排

2022.7.6

> 同 P2365 任务安排。
>
> $1\leq n\leq 3\times 10^5$，$1\leq s\leq 2^8$，$|t_i|\leq 2^8$，$0\leq c_i\leq 2^8$。

$\underline{f_j-s\cdot sf_j}_{\ y}=\underline{st_i}_{\ k}\underline{sf_j}_{\ x}+\underline{f_i-st_i^2-s\cdot sf_n}_{\ b}$，由于 $t_i$ 可能是负数，所以此题中 $k$ 不单调，当前没用的决策之后可能还会用到，所以不能直接弹掉队首决策。

$x$ 是单调的（由于 $c_i$ 可能为 $0$，注意特判 $x$ 相同的情况）。

因为凸壳中的斜率是单调的，所以只需要二分一个最大的 $i$ 满足 $slope(q_{i-1},q_i)\leq k$ / 最小的 $i$ 满足 $slope(q_i,q_{i+1})>k$，$q_i$ 即为最优决策。

时间复杂度 $\mathcal O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e5+5;
int n,s,t[N],c[N],q[N];
ll f[N];
ll get(int i){return f[i]-1ll*s*c[i];}
double slope(int i,int j){
	return c[i]==c[j]?1e18:1.0*(get(i)-get(j))/(c[i]-c[j]);
}
int find(int l,int r,int v){
	int p=r;
	while(l<=r){
		int mid=(l+r)/2;
		if(slope(q[mid],q[mid+1])>v) p=mid,r=mid-1;
		else l=mid+1;
	}
	return q[p];
}
signed main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&t[i],&c[i]),t[i]+=t[i-1],c[i]+=c[i-1];
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		int j=find(l,r,t[i]);
		f[i]=f[j]+1ll*s*(c[n]-c[j])+1ll*t[i]*(c[i]-c[j]);
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
} 
```

##### 2. CF1175G Yet Another Partiton Problem（\*3000）

2023.1.7 单调栈 + 可持久化李超树 + 凸包启发式合并

> 给出 $a_{1\sim n}$ 和 $k$，要求将其划分为 $k$ 段，某段 $a_{l\sim r}$ 的权值为 $(r-l+1)\times \max(a_{l\sim r})$，求每段权值之和的最小值。
>
> $1\leq n,a_i\leq 2\times 10^4$，$1\leq k\leq \min(100,n)$。

设 $f_{i,j}$ 表示 $a_{1\sim i}$ 划分成 $j$ 段的最小权值和。方便起见，记 $f=f_{*,j},g=f_{*,j-1}$，则 $f_i=\min\limits_{j=1}^i\{ g_{j-1}+(i-j+1)\max(a_{j\sim i})\}$。

用单调栈处理 $\max$：将序列分为若干段，每段 $\max$ 值相等。由于 $f_i=\underline{g_{j-1}+(-j+1)\cdot \max}_{\ b}+\underline{i}_{\ x}\cdot \underline{\max}_{\ k}$，只要能快速求出每段 $g_{j-1}+(-j+1)\max(a_{j\sim i})$ 的最小值，就能将直线 $kx+b$ 插入李超树，查询 $x=i$ 处的最小值。由于弹栈需支持撤销，可以可持久化李超树维护。

斜率优化：$\underline{g_{j-1}}_{\ y}=\underline{(j-1)}_{\ x}\cdot \underline{\max}_{\ k}+\underline{f_i-i\cdot \max}_{\ b}$，需要维护 $(j-1,g_{j-1})$ 的下凸包，在凸包上二分求出，用 $k=\max$ 的直线去截它使得 $b$ 最小时对应的 $j$。单调栈弹栈时会导致凸包的合并，由于凸包的 $x$ 坐标有序，可以一个个插入，双端队列 + 启发式合并。

时间复杂度 $\mathcal O(nk\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5,M=N<<5;
int n,k,a[N],f[N],g[N],top,s[N],tot,rt[N],lc[M],rc[M];
deque<int>q[N];
struct L{
	int k,b;
	int calc(int x){return k*x+b;}
}t[M];
double slope(int i,int j){return 1.0*(g[i-1]-g[j-1])/((i-1)-(j-1));}
void merge(deque<int>&x,deque<int>&y){
	if(x.size()<y.size()){
		for(int i:x){
			while(y.size()>1&&slope(y[y.size()-2],y.back())>=slope(y.back(),i)) y.pop_back();
			y.push_back(i);
		}
		x.clear(),swap(x,y);
	}
	else{
		reverse(y.begin(),y.end());
		for(int i:y){
			while(x.size()>1&&slope(i,x[0])>=slope(x[0],x[1])) x.pop_front();
			x.push_front(i);
		}
		y.clear();
	}
}
int modify(int p,int l,int r,L v){
	int x=++tot,mid=(l+r)/2;
	t[x]=t[p],lc[x]=lc[p],rc[x]=rc[p];
	if(v.calc(mid)<t[x].calc(mid)) swap(t[x],v);
	if(l==r) return x;
	if(v.calc(l)<t[x].calc(l)) lc[x]=modify(lc[p],l,mid,v);
	if(v.calc(r)<t[x].calc(r)) rc[x]=modify(rc[p],mid+1,r,v);
	return x;
}
int query(int p,int l,int r,int pos){
	if(l==r||!p) return t[p].calc(pos);
	int mid=(l+r)/2,ans=t[p].calc(pos);
	if(pos<=mid) ans=min(ans,query(lc[p],l,mid,pos));
	else ans=min(ans,query(rc[p],mid+1,r,pos));
	return ans;
}
int find(deque<int>&q,int v){
	int l=1,r=q.size()-1,p=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(slope(q[mid-1],q[mid])<v) p=mid,l=mid+1;
		else r=mid-1;
	}
	return q[p];
}
signed main(){
	scanf("%d%d",&n,&k),t[0]={0,(int)1e9};
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),f[i]=1e9;
	for(int j=1;j<=k;j++){
		swap(f,g),top=tot=0;
		for(int i=1;i<=n;i++){
			q[i].clear(),q[i].push_back(i);
			while(top&&a[i]>a[s[top]]) merge(q[i],q[s[top--]]);
			int j=find(q[i],a[i]);
			rt[i]=modify(rt[s[top]],1,n,{a[i],g[j-1]-(j-1)*a[i]});
			f[i]=query(rt[i],1,n,i),s[++top]=i; 
		}
	}
	printf("%d\n",f[n]);
	return 0;
}
```

#### 四、k,x 都不单调

##### P4027 [NOI2007] 货币兑换