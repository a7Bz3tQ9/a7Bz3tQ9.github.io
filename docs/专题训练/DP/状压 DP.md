[1](https://www.cnblogs.com/maoyiting/p/13368682.html)

## 状压 DP

##### P1879 [USACO06NOV]Corn Fields G

> $m$ 行 $n$ 列的网格，有几格不能种草，其余的相邻两个格子只有一个能种草，问合法的种草方案数。
>
> $1\leq n,m\leq 12$。

一个比较暴力的 DP 方式，将每个点的状态全部记录在 DP 状态里。

设 $f_{i,S}$ 表示考虑了前 $i$ 行，第 $i$ 行的种草状态为 $S$ 时的合法方案数。

转移时枚举第 $i+1$ 行的状态，判断合法则转移。时间复杂度 $\mathcal O(m2^{2n})$。

##### TopCoder14667 RainbowGraph

> 给出一张 $n$ 个点 $m$ 条边的无向图，点有颜色 $c_i$。
>
> 问有多少条路径，满足经过每个点恰好一次，且按顺序经过的点的颜色序列写下来同种颜色出现的位置连续。
>
> $2\leq n\leq 100$，$1\leq m\leq 2500$，$0\leq c_i\leq 9$，$\forall x,\sum_{i=1}^n[c_i=x]\leq 10$。

将同种颜色的点串起来：枚举每种颜色 $c$，设 $f_{i,j,S}$ 表示从颜色 $c$ 的第 $i$ 个点出发，走到颜色 $c$ 的第 $j$ 个点，经过的点的集合为 $S$ 的路径条数。

将所有颜色串起来：设 $g_{i,S}$ 表示以节点 $i$ 结尾，已经经过的颜色集合为 $S$ 的总方案数。转移枚举下一个点的颜色以及是哪个点。

##### 小练习

> $n$ 个物品，每个重量 $w_i$，问至少需要多少大小为 $S$ 的麻袋才能将他们都装进来。
>
> $n\leq 20$，$w_i\leq 10^9$。

$n\leq 20$：我们希望 DP 时每次只加一个元素。

考虑按某种顺序将物品排成一排，从左到右扫，当前麻袋还能装进去就装，否则新开一个麻袋。

状压，设 $f_i$ 表示装集合 $i$ 里的物品，最少要多少麻袋，以及当前最后一个麻袋装了多少重量。也就是记了一个 pair (mn,sum)。取 $\min$ 时，先让第一维尽可能小，再让第二维尽可能小。转移枚举一个不在 $i$ 中的物品，尝试将它装进最后一个麻袋，不行的话新开一个麻袋。这样就可以每次直接在末尾加一个数而不是枚举子集了。

最优方案已经会被算到。因为只要末尾加入数的顺序和上面所说的“某种顺序”一样，这个答案肯定会被统计。

##### P3959 [NOIP2017 提高组] 宝藏

> 给出一张 $n$ 个点 $m$ 条边的无向图，边有边权。你可以自己找一棵生成树，然后选定一个根，最小化每个点与其父亲的边权值 $\times$ 该点深度的总和。
>
> $1\leq n\leq 12$，$0\leq m\leq 10^3$。

一个朴素的 DP：设 $f_{S,S',d}$ 表示当前树选了集合 $S$ 里的点，树上最下面一层的点是集合 $S'$，最下面一层点的深度是 $d$，最小总和是多少。转移枚举再下一层的点（深度为 $d+1$）的集合 $T$。无法通过。

实际上不需要记录 $S'$，只需要让每个 $T$ 里的点与 $S$ 里的任意点有连边即可，而不是必须与最下面一层的 $S'$ 有连边。也就是说，无视 $S'$，每次枚举新的一层当第 $d+1$ 层，不管连到什么点都当深度 $d+1$。这样可能会把某些点的深度算大，但这样的方案不优，最优解一定会被我们统计。这样就能过了。

（技巧：放宽转移条件）

##### [ARC058E] Iroha and Haiku

去掉 DP 状态中的“是否存在”的小技巧 + 思考 DP 的形式

> 一个值域 $\in[1,10]$ 的序列 $a_{1\sim n}$ 是好的，当且仅当存在下标 $x,y,z,w\,(0\leq x<y<z<w\leq n)$ 满足：
>
> - $a_x+a_{x+1}+\cdots+a_{y-1}=X$。
> - $a_y+a_{y+1}+\cdots+a_{z-1}=Y$。
> - $a_z+a_{z+1}+\cdots+a_{w-1}=Z$。
>
> 给出 $n,X,Y,Z$，求好的序列的方案数 $\bmod 10^9+7$。
>
> $3\leq n\leq 40$，$1\leq X,Z\leq 5$，$1\leq Y\leq 7$。

暴力的状态设计：

- 由于 $a_x+\cdots+a_{w-1}=X+Y+Z\leq 17$，考虑值域 $[1,10]$ 且和 $\leq 17$ 的序列只有 $130624$ 个，DP 过程中每次只需保留最靠后的和 $\leq 17$ 的元素队列。

  设 $f_{i,S,0/1}$ 表示考虑了前 $i$ 个元素，队列的状态为 $S$，是否出现题中所述条件的方案数。

  优化 1：预处理每个状态是否满足题中所述条件。

  优化 2：预处理出每个状态遇上 $1\sim 10$ 后分别转移到什么状态。

  优化 3（小技巧）：通过求补集去掉状态中的第三维。即强制过程中必须不出现题中所述条件，用总方案数 $10^n$ 减去它。

优雅的状态设计：

- 换个形式表示“和 $\leq 17$”这个状态。

  把序列“展开”。将“$X+Y+Z$”展开成一条长度为 $X+Y+Z$ 的格子，一个数可以占领 $1\sim 10$ 个格子，只需考虑位置在 $X,X+Y,X+Y+Z$ 的三个格子是否是一个数所占领格子的末尾。

  将一个数的末尾标为 $1$，其他格子标为 $0$，状压。

##### *P4363 [九省联考 2018] 一双木棋 chess

[好评题解](https://www.cnblogs.com/LawrenceSivan/p/14918023.html)

> 一个 $n\times m$ 的棋盘，两人轮流下棋，一个位置可以落子当且仅当这个位置的左侧和上面都落了子。两个人落在对应的位置会收货各自的贡献值 $a_{i,j}$ / $b_{i,j}$，最大化自己的得分减去对方的得分。
>
> 求先手的这个最大值。
>
> $1\leq n,m\leq 10$，$0\leq a_{i,j},b_{i,j}\leq 10^5$。

状压，如何存状态？由于落子是合法的需要满足左边和上边都有棋子，所以每行的棋子数从上往下递减，这样的轮廓一定是连续的。

考虑存储轮廓线作为状态。轮廓线长度肯定是 $n+m$ 的。从右上角开始，向左下角延伸，我们用 $0$ 表示横边，$1$ 表示竖边。

<img src="https://img2022.cnblogs.com/blog/1859218/202207/1859218-20220724202618406-1341098821.png" alt="image" style="zoom: 33%;" /><img src="https://img2022.cnblogs.com/blog/1859218/202207/1859218-20220724202725030-1675224879.png" alt="image" style="zoom:33%;" />

比如上面那个这个，$000101010101010101$。

发现落子相当于将串中的 $01$ 变为 $10$。通过判 `((s>>i)&3)==1` 来判 $01$（$3$ 的二进制是 $11$），落子后状态为 `s^(3<<i)`。起始状态 $00\cdots 0011\cdots11$，终止状态 $11\cdots1100\cdots00$。

设 $f_S$ 表示状态 $S$ 的最大得分差。但博弈论 DP 的题不能这样做，由于两方都采取最优策略，我们不得不考虑将来的行动对现在的影响。正序 DP 可能会发生当前确实取到了最大值，但是其实并不是最优策略。

于是考虑倒过来 DP。假装我们可以一步看到结局，然后选择对自己最有利的状态。设 $f_S$ 表示从状态 $S$ 到结束还能获得的最大得分差。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=15;
int n,m,a[N][N],b[N][N],f[1<<20];
bool vis[1<<20];
int dfs(int s,int o){
	if(vis[s]) return f[s];
	vis[s]=1,f[s]=-1e9;
	for(int i=0,x=n+1,y=1;i<n+m-1;i++){
		if((s>>i&1)) x--;
		else y++;
		if(((s>>i)&3)==1) f[s]=max(f[s],(!o?a[x][y]:b[x][y])-dfs(s^(3<<i),o^1));
	}
	return f[s];
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) scanf("%d",&b[i][j]);
	vis[((1<<n)-1)<<m]=1,f[((1<<n)-1)<<m]=0;
	printf("%d\n",dfs((1<<n)-1,0));
	return 0;
}
```

##### CF743E Vladik and cards（\*2200）

优化子序列相关 DP 的技巧

> 给出 $a_{1\sim n}$，值域 $[1,8]$。求一个最长的子序列，满足：$1\sim 8$ 每种取值的出现次数相差 $\leq 1$，且每种取值出现在子序列中的位置连续。
>
> $1\leq n\leq 1000$。

DP 中处理“相差 $\leq 1$”不太现实，考虑枚举出现次数 $L$，表示每种数字的出现次数 $\in\{L,L+1\}$。

设 $f_{i,S}$ 表示考虑了前 $i$ 位，已经处理好颜色集合 $S$ 的最长子序列长度。枚举下一个出现的颜色 $c$ 及其出现次数 $l\in\{L,L+1\}$，肯定贪心取颜色 $c$ 最靠前的 $l$ 个，可以预处理 $nxt_{i,c,k}$ 表示 $i$ 后面第 $k$ 个颜色 $c$ 的位置。

优化 1：

- 最优性：$L$ 越大越好，因为 $\{L+1,L+2\}$ 即使全取 $L+1$ 也不劣于 $\{L,L+1\}$ 全取 $L+1$。我们只需找到最大的存在合法解的 $L$，再最大化取 $L+1$ 的颜色数。
- 合法性：$L$ 的取值的合法性是单调的，可以把枚举 $L$ 改为二分。

优化 2：

- 新增转移 $f_{i,S}\to f_{i+1,S}$ 表示 $i+1$ 不选入子序列，然后不需要枚举 $c$ 直接钦定下一种颜色是 $a_{i+1}$ 表示 $i+1$ 选入子序列。实际上是将状态中“以 $i$ 结尾”换成了“前 $i$ 位”。

  $nxt_{i,c,k}$ 的 $c$ 也可以去掉，直接 $nxt_{i,k}$ 表示 $i$ 后面第 $k$ 个颜色 $a_i$ 的位置。

##### *CF599E Sandy and Nuts（\*2600）

> 一棵 $n$ 个节点的树，根为 $1$，你知道 $m$ 条信息：
>
> - 某些树上的边。
> - 某两个点的 $\text{lca}$。
>
> 求满足条件的树的个数。
>
> $1\leq n\leq 13$，$0\leq m\leq 100$。

设 $f_{x,S}$ 表示以 $x$ 为根的子树中，点集为 $S$ 的合法方案数。

如果不考虑 $m$ 条限制 $f_{x,S}'\gets f_{x,S-T}\times f_{y,T}\,(x\notin T,y\in T)$。

考虑上限制就把那些不合法的中途舍掉（不转移）即可。

比如边 $(x,y)$ 的约束，要么 $y$ 是 $x$ 的儿子要么 $y$ 是 $x$ 的父亲，在 DP $x$ 时只处理前一种情况（若 $y\subseteq T$ 但 $y$ 不是根就舍掉），在 DP $fa_x$ 时处理后一种情况。

$\text{lca}(x,y)=z$ 的限制，在 DP $z$ 时处理，若 $x\in T\land y\in T$ 就舍掉，若最后 $x\not\in S\lor y\not\in S$ 就舍掉。

##### BZOJ 3864 Hero meet devil

DP 套 DP，状压 DP 状态

> 给出一个长度为 $n$ 的字符串 $s$，对于每个 $k\in[0,n]$，求有多少长度为 $m$ 的字符串 $t$ 满足 $\text{lcs}(s,t)=k$。
>
> $n\leq 15$，字符集大小为 $4$。

考虑求 LCS 的过程：设 $f_{i,j}$ 表示 $t$ 的前 $i$ 位和 $s$ 的前 $j$ 位的 LCS。

设 $g_{i,S}$ 表示考虑了 $t$ 的前 $i$ 位，DP 数组 $f_i$ 是 $S$ 的方案数。

注意到 $f_{i,j-1}\leq f_{i,j}\leq f_{i,j-1}+1$，即 $f_{i,j}-f_{i,j-1}\in\{0,1\}$，状压差分数组：$S$ 中只要记录相邻两项的差值，不是 $0$ 就是 $1$。

转移枚举字符是什么，可以预处理做到 $\mathcal O(1)$ 转移。时间复杂度 $\mathcal O(m2^n)$。

扩展：由于每一步转移都是一样的，可以矩阵快速幂优化。

##### HDU 4352 XHXJ's LIS

> 给出 $l,r$，其有多少 $x\in[l,r]$，使得将 $x$ 看成字符串，其 LIS 恰好为 $k$。
>
> $T\leq 10^4$，$0<l\leq r<2^{63}-1$，$1\leq k\leq 10$。

先按数位 DP 的套路：`calc(r)-calc(l-1)` 去掉下界，然后设 $f_{i,S,0/1}$ 表示处理到从高到低的第 $i$ 位，LIS 状态为 $S$，是否顶到上界的方案数。转移枚举第 $i+1$ 位的数字。

怎么定义 $S$？考虑二分求 LIS 的过程：设 $f_i$ 表示长度为 $i$ 的 LIS 中末位元素的最小值。二分出最大的 $f_j<a_i$，$f_{j+1}\gets a_i$。考虑压缩 $f$ 数组！

在本题中，$f_i\in[0,9]$，且元素个数至多为 $10$，但显然不能 $10^{10}$ 个状态。发现 $f_i$ 严格单调递增，爆搜出所有合法的状态？只需要记录 $0\sim 9$ 每个数字是否在 $f_i$ 出现即可，$2^{10}$。

##### *UOJ#549. 【UNR #4】序列妙妙值

> 给出一个长度为 $n$ 的序列 $a$，对 $a$ 的每个前缀，求将其划分为 $k$ 段，每段异或和之和的最小值是多少。
>
> $1\leq k\leq n\leq 6\times 10^4$，$k\leq 8$，$a_i<2^{16}$。

求出 $a_i$ 的前缀异或和 $s_i$。设 $f_{i,k}$ 表示前 $i$ 个数分成 $k$ 段的最小值，$f_{i,k}=\min\{f_{j,k-1}+s_i\oplus s_j\}$。时间复杂度 $\mathcal O(n^2k)$。

当值域较小时，记 $g_v$ 表示 $s_j=v$ 的最小的 $f_{j,k-1}$，复杂度 $\mathcal O(nkv)$。

值域较大时，查询枚举 $v$ 复杂度过大，考虑在修改时处理出。

固定 $k$。考虑 $j$ 对后面 $i$ 的贡献，设 $g_{x,y}$ 表示 $s_j$ 的前 $8$ 位是 $x$，$s_i$ 的后 $8$ 位是 $y$，$f_{j,k-1}+(s_i\oplus s_j)\bmod 2^8$ 的最小值。这样枚举 $y$ 预处理，枚举 $x$ 计算 DP 值。

即在确定 $s_j$ 时，枚举 $s_i$ 所有后 $8$ 位的情况，算出当 $s_i$ 后 $8$ 位确定时后 $8$ 位的最小值，同时在状态中记录 $s_j$ 的前 $8$ 位供询问时确定 $s_i$ 的前 $8$ 位确定时计算。看代码就懂了。

时间复杂度 $\mathcal O(nk\sqrt v)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e4+5,M=1<<8;
int n,m,a[N],f[N][9],g[M][M];
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),a[i]^=a[i-1];
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++) f[i][1]=a[i];
	for(int k=2;k<=m;k++){
		memset(g,0x3f,sizeof(g));
		for(int i=k;i<=n;i++){
			for(int s=0;s<(1<<8);s++)
				g[a[i-1]>>8][s]=min(g[a[i-1]>>8][s],f[i-1][k-1]+(a[i-1]^s)%(1<<8));	//i-1 即在 i 前面的 j	
			for(int s=0;s<(1<<8);s++)
				f[i][k]=min(f[i][k],g[s][a[i]%(1<<8)]+(((a[i]>>8)^s)<<8));
		}
	}
	for(int i=m;i<=n;i++) printf("%d ",f[i][m]);
	return 0;
}
```

##### *P6192 【模板】最小斯坦纳树

> 给出一张 $n$ 个点，$m$ 条有权边的无向连通图，其中有 $k$ 个点是关键点。求图的一个子图，满足包含了所有 $k$ 个关键点，使得所包含的边集的权值和最小，求这个最小值。
>
> $n\le 100$，$m\le500$，$k\le10$。

答案一定是一棵树，因为有环肯定不优。不妨钦定树根。设 $f_{x,S}$ 表示以 $x$ 为根的树，包含集合 $S$ 内的关键点的最小代价。

- 合并两棵树：$\min_{t\subseteq S}\{f_{x,t}+f_{x,s\backslash t}\}\to f_{i,s}$（由于权值在边上所以不会多算）。
- 换根：$f_{y,S}+w_{x,y}\to f_{x,S}$。

第一种转移 $3^k$ 枚举，第二种转移跑个最短路。

时间复杂度 $\mathcal O(n3^k+m\log m2^k)$。

##### *AT_apc001_f XOR Tree

边权化点权

> 给出一棵 $n$ 个节点的树，边有边权。
>
> 每次操作可以将一条路径上的边权异或上某个值。问最少操作多少次能使边权全为 $0$。
>
> $2\leq n\leq 10^5$，$0\leq w_i\leq 15$。

一条路径上的边太多不好考虑。

一个巧妙的转化：定义一个点的点权为与其相邻的所有边的边权异或和。容易证明边权全为 $0$ 等价于点权全为 $0$（必要性显然，充分性考虑从叶子往上推）。每次操作就是将任意两个点异或上同一个数。

操作 $a,b$ 时，若 $a=b$ 可以一次操作消去它们两个，若 $a\neq b$ 可以一次操作消去它们两个并留下 $a\oplus b$。可以证明不会同时异或一个 $\neq a$ 也 $\neq b$ 的数。

由于只有 $16$ 种取值，先将重复的直接消去，剩下的信息只有 $0\sim 15$ 每种数字是否出现过，可以状压。

转移枚举要操作 $a\neq b$，若 $a\oplus b\notin S$ 就 $f_S\gets f_{S-\{a,b\}+\{a\oplus b\}}+1$，否则 $f_S\gets f_{S-\{a,b\}}+2$ 表示新增一次操作消掉 $a\oplus b$。

注意转移顺序是按 $|S|$ 从小到大。
