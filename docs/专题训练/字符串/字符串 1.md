### 一、字符串

### KMP

若 $s$ 的一个前缀 $=$ 后缀 $\neq s$，则称这个前缀是 $s$ 的 border。设 $nxt_i$ 表示 $s[1:i]$ 的最长 border 长度。

求 $nxt$：

- 对于 $s$ 的任意两个 border，短的一定是长的那个的 border。

  <img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220805160450111-21199972.png" alt="image" style="zoom: 67%;" />

  遍历 $s$ 的所有 border：$s$，$x$（$s$ 的最长 border），$y$（$x$ 的最长 border），以此类推。

  那么从 $nxt_i$ 开始不断跳 $nxt$，能得到 $s[1:i]$ 的所有 border。

- 若 $nxt_i$ 是 $s[1:i]$ 的 border 且 $s_{nxt_i+1}=s_{i+1}$，则 $nxt_i+1$ 是 $s[1:i+1]$ 的 border。

  <img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220805161716759-116063403.png" alt="image" style="zoom:67%;" />

  那么只要从大到小枚举 $s[1:i]$ 的 border $x$，判是否满足 $s_{i+1}=s_{x+1}$，就能找到 $s[1:i+1]$ 的最长 border。

匹配，求 $t$ 在 $s$ 中的所有出现位置：

- 先对 $t$ 求出 $nxt$。维护 $s[1:i]$ 的最长后缀 $x$，使得 $x$ 是 $t$ 的前缀。当 $k=m$ 时找到匹配。

  $i\to i+1$ 时，从大到小枚举 $t[1:x]$ 的 border $k$，判是否满足 $s_{i+1}=t_{k+1}$。

  <img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220805162546931-1015680562.png" alt="image" style="zoom:67%;" />

```cpp
nxt[1]=0;
for(int i=1,k=0;i<m;i++){
	while(k&&t[i+1]!=t[k+1]) k=nxt[k];
	nxt[i+1]=(k+=(t[i+1]==t[k+1]));
}
for(int i=0,k=0;i<n;i++){	//注意从 i=0 开始
	while(k&&s[i+1]!=t[k+1]) k=nxt[k];
	k+=(s[i+1]==t[k+1]);
	if(k==m) printf("%d\n",(i+1)-m+1),k=nxt[k];
}
```

#### 循环节

> 求 $s$ 的所有循环节大小。

相同前后缀相交时，会出现循环节，border 与循环节一一对应。枚举 border $x$，$x\geq\frac n 2$，那么循环节长度就是 $n-x$，判 $(n-x)\mid n$（否则最后一段循环节可能不完整）。

实现时，可以判 $(n-x)\mid n$ 且 $\frac{n}{n-x}>1$。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220805163753919-1625908012.png" alt="image" style="zoom:67%;" />

#### KMP 与周期

称 $D$ 是 $S$ 的一个周期，当且仅当 $\forall i\leq |S|-D$，有 $S_i=S_{i+D}$。

对于一个长度为 $l$ 的 border：$S_i=S_{|S|-l+i}$。$|S|-l$ 是一个周期。每个 border 和某个周期一一对应。

判断一个串是否为 $S^k$：有长度为 $|S|$ 的周期，长度为 $(k-1)\times |S|$ 的 border。

判循环串：一定存在一个周期 $D$，使得 $D\mid n$，那么重复 $\frac n d$ 次，即存在一个长度为 $l$ 的 border，$n-l\mid n$。看下是否有 $(n-nxt_n)\mid n$ 即可判断。

#### border 树

$nxt_i\gets i$ 连边，得到一棵根为 $0$ 的树。

求两个前缀的最长公共 border：树上求 LCA 即可（P5829 【模板】失配树 1e6 要 Tarjan 求 LCA）。

对每个前缀求有多少 $\leq\frac n 2$ 的 border：对于每个前缀 $i$，在 $i$ 的祖先中二分出编号最大的 $\leq\frac n 2$ 的点的深度（P2375 [NOI2014] 动物园）。

#### 基础应用

- 求 $T$ 在 $S$ 中的出现次数，出现位置。

- 给出 $S$，问最少往后面加多少字符，使得它变成循环串。

  对于周期 $D=n-l$，补 $D-n\bmod D$。

- 求每个前缀在字符串中出现了几次。

  要求某个前缀作为多少个子串出现，由于子串 = 前缀的后缀，不妨枚举每个前缀 $i$，看它有多少后缀是某个前缀。实际上就是跳 border，给 border 的出现次数 $+1$。直接加会 T。

  建出 border 树，发现就是 $nxt_i$ 到根的路径全 $+1$。树上差分即可。

#### A1

> 给出一个字符串 $s$，求 $s$ 所有子串拆成 AABB 形式的方案数之和。$\mathcal O(n^2)$。

设 $pre_i$ 表示 $S[1:i]$ 有多少 AA 后缀，$suf_{i+1}$ 表示 $S[i+1:n]$ 有多少 BB 前缀，则 $ans=\sum_{i=1}^{n-1}pre_isuf_{i+1}$（注意 $i<n$）。

以 $suf$ 为例。$\mathcal O(n)$ 算每个 $suf_i$。把 $S[i:n]$ 拎出来作为 $T$。若 $T[1:i]$ 能写成 AA，那么 $\frac i 2$ 一定是 $T[1:i]$ 的一个 border。建出 border 树 dfs 一遍，记录到根的路径上有哪些点，看看 $\frac i 2$ 有没有即可。

#### A2

P3502 [POI2010]CHO-Hamsters

> 给出 $n$ 个字符串 $s_{1\sim n}$，求一个最短的字符串 $T$，使得这些串在 $T$ 中一共出现了 $m$ 次。
>
> $n\leq 200$，$m\leq 10^9$，$\sum|s_i|\leq 5000$。

设 $f_{i,j}$ 表示已经加了 $i$ 个串，末尾是第 $j$ 个串，最短长度是多少。

预处理 $dis_{i,j}$ 表示 $s_i$ 后最少添加多少字符使得当前字符串也含有 $s_j$。把 $s_i$ 去掉第一位和 $s_j$ 拎出来跑 KMP（$s_j$ 的最长前缀 = $s_i$ 去掉第一位的某后缀），$dis_{i,j}$ 就是 $|s_j|-$ 最后匹配到的位置。

$f_{i,j}=\min(f_{i-1,k}+dis_{k,j})$，矩阵快速幂优化，$ans=\min_{i=1}^n f_{m,i}$。



> 给出 $n$ 个互不包含的字符串 $s_i$，求一个最短的字符串 $S$，使得在 $S$ 中这 $n$ 个字符串总共至少出现 $m$ 次。求 $S$ 最短长度。
>
> $1\leq n\leq 200$，$1\leq m\leq 10^9$，$\sum |s_i|\leq 10^5$。

设 $f_{i,j}$ 表示在 $S$ 中总共出现了 $i$ 次，$S$ 中最后出现的是第 $j$ 个字符串 $s_j$ 时，$S$ 的最短长度。

预处理 $dis_{i,j}$ 表示 $s_i$ 后最少添加多少字符使得当前字符串也含有 $s_j$：把 $s_i$ 去掉第一位和 $s_j$ 拎出来跑 KMP，$dis_{i,j}$ 就是 $|s_j|-$ 最后匹配到的位置。

$f_{i,j}=\min(f_{i-1,k}+dis_{k,j})$，$ans=\min_{i=1}^n f_{m,i}$。注意到 $m$ 很大，矩乘优化即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=210,M=1e5+5;
int n,m,len[N],nxt[M],k;
ll res=1e18;	//!!! 1e9 不够
char s[N][M]; 
struct mat{
	ll x[N][N];
	mat(){memset(x,0x3f,sizeof(x));}
	friend mat operator*(mat a,mat b){
		mat c;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				for(int k=1;k<=n;k++) c.x[i][j]=min(c.x[i][j],a.x[i][k]+b.x[k][j]);
		return c;
	} 
}d,ans;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%s",s[i]+1),ans.x[1][i]=len[i]=strlen(s[i]+1);
	for(int x=1;x<=n;x++)
		for(int y=1;y<=n;y++){
			nxt[1]=k=0; 
			for(int i=1;i<len[y];i++){
				while(k&&s[y][k+1]!=s[y][i+1]) k=nxt[k];
				nxt[i+1]=(k+=s[y][k+1]==s[y][i+1]);
			}
			k=0;
			for(int i=1;i<len[x];i++){	//注意这里是 1 不是 0，因为 s[x] 是去掉第一位再来匹配的
				while(k&&s[y][k+1]!=s[x][i+1]) k=nxt[k];
				k+=s[y][k+1]==s[x][i+1];
			}
			d.x[x][y]=len[y]-k;
		}
	for(m--;m;m>>=1,d=d*d) if(m&1) ans=ans*d;
	for(int i=1;i<=n;i++) res=min(res,ans.x[1][i]);
	printf("%lld\n",res);
	return 0;
}
```

#### A3

Rank KMP

> 称两个等长序列 $a,b$ 相似，当且仅当 $\forall i,j$，$[a_i<a_j]=[b_i<b_j]$（离散化后相等）。
>
> 给出序列 $x,y$，问 $x$ 有多少子区间与 $y$ 相似。

普通 KMP 中用到的性质：

1. $nxt_i\to nxt_{i+1}$：两个相等的字符串，后面加一个相同的字符还是相等的。
2. 两个相等的字符串，它们等长的前缀也相等。
3. $A=B,B=C$，则 $A=C$。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829181037137-1501142424.png" alt="image" style="zoom:50%;" />

现在改成：

1. 两个相似的字符串，后面加一个在对应串中 rank 相同的字符还是相似的。
2. 两个相似的字符串，它们等长的前缀也相似。
3. 显然。

原来 KMP 是判断两个字符是否相等，这里改为判断两个字符在前面的 rank 是否相等。

主席树维护排名即可。时间复杂度 $\mathcal O(n\log n)$。



扩展时，KMP 是判断两个字符是否相等，这里改为判断两个字符在前面的排名是否相等。

主席树维护排名即可。时间复杂度 $\mathcal O(n\log n)$。

#### A4

动物园

> 给出一个长度为 $n$ 的字符串 $S$，对每个前缀求出它有多少 border 长度不超过它的一半。
>
> $n\leq 10^6$。

$\mathcal O(n\log n)$：建出 border 树，二分每个点到根路径上第一个编号 $\leq\frac i 2$ 的点。

$\mathcal O(n)$：若 $nxt_i\leq \frac i 2$ 则只要跳一步。否则 $S[1:i]$ 有周期，可以表示成 $AB^k$ 的形式，其中 $A$ 是 $B$ 的后缀（$B$ 是循环节，$A$ 是不完整的循环节）。每次跳 $nxt$ 相当于去掉一个 $B$，$AB^k\to AB^{k-1}\to AB\to ?$，可以直接算有多少 border $\leq \frac i 2$。

不管哪种长度都减半，最多跳 $2$ 次。复杂度 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,mod=1e9+7;
int t,n,nxt[N],dep[N],ans;
char s[N];
int calc(int i){
	int x=nxt[i];
	while(x>i/2){
		if(nxt[x]<=i/2) x=nxt[x];
		else{
			int b=x-nxt[x];	//a=x%b,k=x/b：AB^k
			x-=((x-i/2)+b-1)/b*b;	//跳到 AB^?
		}
	}
	return dep[x];
}
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%s",s+1),n=strlen(s+1),dep[1]=ans=1;
		for(int i=1,k=0;i<n;i++){
			while(k&&s[i+1]!=s[k+1]) k=nxt[k];
			nxt[i+1]=(k+=s[i+1]==s[k+1]),dep[i+1]=dep[k]+1;	//border 树上的 dep
		}
		for(int i=1;i<=n;i++) ans=1ll*ans*(calc(i)+1)%mod;
		printf("%d\n",ans);
	}
	return 0;
}
```

#### A5

树上 KMP

> 给出一棵 Trie，求每个点到根表示的字符串的最长 border。字符集很大。
>
> $n\leq 10^6$。

不能暴力跳 border：

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220829204450260-1434014009.png" alt="image" style="zoom:50%;" />

处理 $f(x,c)$ 表示节点 $x$ 表示的串末尾加上 $c$ 后，不断向上跳 border 能跳到匹配 $c$ 的点。$nxt_x=f(nxt_{fa_x},c_{(fa_x,x)})$。

若 $x$ 有出边 $(y,c)$，$f(x,c)=y$，否则 $f(x,c)=f(nxt_x,c)$。可以可持久化线段树维护 $f$（先 $f(x,*)\gets f(nxt_x,*)$，再枚举 $x\to (y,c)$，$f(x,c)=y$。直接 `map` 复制复杂度会炸）。

#### 树上 KMP

> 给一个 Trie，求每个点到根表示的字符串的最长 border。
>
> $n,|\sum|\leq 10^6$。

每次跳最长 border 复杂度是均摊的，复杂度是错的。栗子：

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220805170318674-918162038.png" alt="image" style="zoom: 33%;" />

对于 $s$，若 $nxt_{|s|}\geq \frac{|s|}{2}$，那么 $s$ 就可以写成 $AB^k$ 的形式（从后面开始，$B$ 是循环节，$A$ 是不完整的循环节，$A$ 是 $B$ 的 **后缀**，$|A|=|s|-nxt_{|s|}$）。

容易发现，$AB^k$ 最长 border 就是 $AB^{k-1}$，border 树链为 $AB^k,AB^{k-1},\cdots,A$，相当于每次跳一个 $B$。

正常来说，若 $fa_x$ 的串的 border $AB^k$，求 $x$ 的 border 要不断跳 border 并判 $B_1$ 与 $ch_x$ 是否相等。发现跳这么多次每次判断条件是一样的，所以若 $B_1\neq ch_x$，直接跳到 $A$ 即可。

若有循环节，$|A|<|B|$ 且只会跳一次；否则 $nxt_{|s|}<\frac{|s|}2$。不管怎样，每次 border 至少减半。

时间复杂度 $\mathcal O(n\log n)$。

暴力 KMP + 记忆化有时会起到不错的效果：CF1721E。

#### P3426 [POI2005]SZA-Template

> 给出一个字符串 $s$，求一个长度最小的字符串 $t$ 使得 $s$ 可以被 $t$ 印出来。
>
> 印的规则是：重叠部分的字符串要一样。
>
> $|s|\leq 5\times 10^5$。

设 $f_i$ 表示前缀 $i$ 的答案。那么 $f_i\in\{i,f_{nxt_i}\}$，因为要印出 $i$，得先印出 $i$ 的 border。而 $f_i=f_{nxt_i}$ 的条件是，$\exists j\geq i-nxt_i$，满足 $f_j=f_{nxt_i}$，否则中间那小段没法印。开个桶维护一下每个 $f$ 最后出现的位置即可。

时间复杂度 $\mathcal O(n)$。

### AC 自动机

多个串的 KMP。

与树上 KMP 的不同：$fail_x$ 不仅限于祖先，可以到树上任意一个节点。

$ch(x,c)$ 表示节点 $x$ 表示的字符串后面接上 $c$ 匹配到哪个点，$ch(x,*)\gets ch(fail_x,*)$。$fail_x=ch(fa_x,c_{fa_x,x})$。BFS 实现。

### 卡哈希

生日攻击、树攻击、多重树攻击、卡判回文串。

#### 生日攻击

生日悖论：在 $\geq 23$ 人中至少有两人生日相同的概率 $>\frac 1 2$。因为没有相同的概率 $\frac{\binom{365}{23}23!}{365^{23}}<\frac 1 2$。

对于模数 $p$，固定长度 $l$，令 $k=1+\sqrt{(2\ln 2)p}$，等概率随机生成 $k$ 个长度为 $l$ 的字符串。

若 $l$ 不是特别小，这 $k$ 个串的哈希值可以近似等概率分布，使用生日悖论，这 $k$ 个数全部两两不同的概率为 $\prod_{i=0}^{k-1}(1-\frac i p)<\prod_{i=0}^{k-1}e^{-\frac i p}<e^{-\ln 2}=\frac 1 2$。

重复这个过程，可以 $\mathcal O(\sqrt p)$ 找到等长冲突。

### Manacher

维护右端点最大的回文串。

因为 $r$ 是越来越大的，所以复杂度 $\mathcal O(n)$。

```cpp
n=strlen(s+1),t[0]='@';
for(int i=1;i<=n;i++) t[++len]='#',t[++len]=s[i];
t[++len]='#',t[len+1]='\0';
for(int i=1;i<=len;i++){
	if(i<=r) p[i]=min(p[2*mid-i],r-i+1);
	while(t[i-p[i]]==t[i+p[i]]) p[i]++;
	if(i+p[i]-1>r) r=i+p[i]-1,mid=i;
}
for(int i=1;i<=len;i++) ans=max(ans,p[i]-1);
```

#### CF30E Tricky and Clever Password（\*2800）

> 你要把一个字符串 $s$ 拆成 A+prefix+B+middle+C+suffix 的形式，使得：
>
> 1. prefix+middle+suffix 是一个奇回文串。
>
> 2. prefix 和 suffix 长度相等。
>
> 3. middle 不是空串，其他的部分都可以是空串。
>
> 最大化 prefix+middle+suffix 的长度。输出方案。$|s|\leq 10^5$。

由于 1,2 可知 middle 是一个奇回文串。

枚举 middle 的回文中心 $i$，让它越长越好，因为这不劣于划给 prefix,suffix。Manacher 预处理最长回文半径 $p_i$，那么 middle 对应 $[i-p_i+1,i+p_i-1]$。

考虑 prefix 的结束位置 $x$，长度 $t$，$x\leq i-p_i$，$s[1:x]$ 长度为 $t$ 的后缀 = $s[1:n]$ 长度为 $t$ 的后缀 = $s[1:n]$ 的反串长度为 $t$ 的前缀。发现这和 KMP 所求的是一样的，对 $s$ 和 $s$ 的反串跑一遍 KMP 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,p[N],nxt[N],mx[N],id[N],tmp,ans,a,x,b,y,c,z;
char s[N],t[N];
void manacher(){
	s[0]='@';
	for(int i=1,r=0,mid=0;i<=n;i++){
		if(i<=r) p[i]=min(p[2*mid-i],r-i+1);
		while(s[i-p[i]]==s[i+p[i]]) p[i]++;
		if(i+p[i]-1>r) r=i+p[i]-1,mid=i;
	}
} 
void kmp(){
	for(int i=1;i<=n;i++) t[i]=s[n-i+1];
	for(int i=1,k=0;i<n;i++){
		while(k&&t[k+1]!=t[i+1]) k=nxt[k];
		nxt[i+1]=k+=t[k+1]==t[i+1];
	}
	for(int i=0,k=0;i<n;i++){
		while(k&&t[k+1]!=s[i+1]) k=nxt[k];
		mx[i+1]=k+=t[k+1]==s[i+1];
	}
}
signed main(){
	scanf("%s",s+1),n=strlen(s+1),manacher(),kmp();
	for(int i=1;i<=n;i++){
		id[i]=id[i-1],mx[i]=max(mx[i],mx[i-1]);
		if(mx[i]>mx[i-1]) id[i]=i;
	}
	for(int i=1;i<=n;i++){
		int t=min(mx[i-p[i]],n-(i+p[i])+1);
		if((tmp=(p[i]*2-1)+t*2)>ans)
			ans=tmp,a=id[i-p[i]]-t+1,x=t,b=i-p[i]+1,y=p[i]*2-1,c=n-t+1,z=t; 
	}
	printf("%d\n",(!!x)+(!!y)+(!!z));
	if(x) printf("%d %d\n",a,x);
	if(y) printf("%d %d\n",b,y);
	if(z) printf("%d %d\n",c,z);
	return 0;
}
```

#### 类似题 ZR#1632. [20联赛集训day6]字符串

2022.8.10

> 给出一个长度为 $n$ 的字符串 $S$，将其分为五段 $A+B+C+D+E=S$（$A,B,C,D,E$ 中可以有空串）。求 $|A|+|C|+|E|$ 的最大值，要求 $A+C+E$ 是个回文串。
>
> $|S|\leq 5\times 10^6$，仅包含小写字母。

首先一对一对删掉首尾相同的字符，问题转化为拆成 $A+B+C+D$，最大化 $A+C$ 是个回文串的长度或 $B+D$ 是个回文串的长度。

以 $B+D$ 为例，枚举回文中心，manacher 求出以它为中心的最长回文回文串 $[l,r]$（注意回文串长度不一定是奇数，也可以是偶数）：

- 若这个中心在 $D$，那么 $l-1$ 前有一个子串 = $[r+1,n]$ 的反串 = 反串的 $[1,n-r]$，跑 KMP 看看 $l-1$ 前有没有能匹配反串 $[1,n-r]$ 的即可。
- 若这个中心在 $B$，KMP 看看以 $l-1$ 为结尾时能匹配反串 $[1,n-r]$ 的最长长度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
int n,len,p[N<<1],d1[N],d2[N],nxt[N],pos[N],mx[N],ans;
char s[N],t[N<<1];
void manacher(){
	t[0]='@',len=0;	//某 sb 没写 len=0
	for(int i=1;i<=n;i++) t[++len]='#',t[++len]=s[i];
	t[++len]='#',t[len+1]='\0';
	for(int i=1,r=0,mid=0;i<=len;i++){
		p[i]=i<=r?min(p[2*mid-i],r-i+1):0;
		while(t[i-p[i]]==t[i+p[i]]) p[i]++;
		if(i+p[i]-1>r) r=i+p[i]-1,mid=i;
	}
	for(int i=1;i<=n;i++) d1[i]=p[i*2]/2,d2[i]=p[i*2-1]/2;
}
void kmp(){
	for(int i=1;i<=n;i++) t[i]=s[n-i+1];
	for(int i=1,k=0;i<n;i++){
		while(k&&t[k+1]!=t[i+1]) k=nxt[k];
		nxt[i+1]=k+=t[k+1]==t[i+1];
	}
	for(int i=0,k=0;i<n;i++){
		while(k&&t[k+1]!=s[i+1]) k=nxt[k];
		pos[i+1]=k+=t[k+1]==s[i+1];
	}
}
int calc(){	//B+D 回文
	manacher(),kmp();
	for(int i=1;i<=n;i++) mx[i]=max(mx[i-1],pos[i]);
	int ans=0;
	for(int i=1;i<=n;i++){
		int l=i-d1[i]+1,r=i+d1[i]-1;	//奇回文
		if(mx[l-1]>=n-r) ans=max(ans,(r-l+1)+2*(n-r));	//回文中心在 D
		ans=max(ans,(r-l+1)+2*min(pos[l-1],n-r));	//回文中心在 B
		l=i-d2[i],r=i+d2[i]-1;	//偶回文
		if(l<=r){
			if(mx[l-1]>=n-r) ans=max(ans,(r-l+1)+2*(n-r));	//在 D
			ans=max(ans,(r-l+1)+2*min(pos[l-1],n-r));	//在 B
		}
	}
	return ans;
}
signed main(){
	scanf("%s",s+1),n=strlen(s+1);
	int l=1,r=n,c=0;
	while(l+1<=r-1&&s[l]==s[r]) l++,r--,c+=2;	//一对一对消掉首尾相同的字符
	for(int i=l;i<=r;i++) s[i-l+1]=s[i];
	n-=c;
	ans=calc(),reverse(s+1,s+1+n),ans=max(ans,calc());	//B+D 回文，翻转后 A+C 回文
	printf("%d\n",ans+c);
	return 0;
}
```

### Z 函数

维护右端点最大的 z-box。

```cpp
void getz(char* s){
	int n=strlen(s+1),l=0,r=0;
	fill(z+1,z+1+n,0),z[1]=n;
	for(int i=2;i<=n;i++){
		if(i<=r) z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n&&s[i+z[i]]==s[1+z[i]]) z[i]++;
		if(i+z[i]-1>r) l=i,r=i+z[i]-1;
	}
}
void exkmp(char* s,char* t){
	int n=strlen(s+1),l=0,r=0;
	getz(t),fill(p+1,p+1+n,0);
	for(int i=1;i<=n;i++){
		if(i<=r) p[i]=min(z[i-l+1],r-i+1);
		while(i+p[i]<=n&&s[i+p[i]]==t[1+p[i]]) p[i]++;
		if(i+p[i]-1>r) l=i,r=i+p[i]-1;
	}
}
```

#### CF1394E Boboniu and Banknote Collection（\*3500）

1. 有 Z 就折。

   可以证明每加一个字符最多新产生一个 Z（反证，多的 Z 在前面被折了。若 A 包含 B 的回文中心，B 包含 A 的回文中心，就会产生 Z）。

   找 Z 后缀？

2. 有回文前/后缀就折。