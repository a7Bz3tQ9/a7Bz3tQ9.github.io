### 一、整体二分

即对所有的操作或询问一起二分。

记 $[l,r]$ 为 **答案的值域**，$[L,R]$ 为答案的定义域（也就是说求答案时仅考虑下标在区间 $[L,R]$ 内的操作和询问，询问的答案在 $[l,r]$ 内）。

- 首先，把所有操作按时间顺序存下来，然后开始分治。
- 在每一层分治中，利用数据结构（常见的是树状数组）统计当前查询的答案和 $mid$ 之间的关系。
- 根据这个关系（$\leq mid$ 和 $>mid$），将当前处理的操作序列分为两部分，分别递归处理。
- 当 $l=r$ 时，找到答案，记录答案并返回即可。

在整体二分过程中，若当前处理的值域为 $[l,r]$，则此时最终答案范围不在 $[l,r]$ 的询问会在其他时候处理。

一个简单的实现方式是，将 $ans\in[l,r]$ 的操作压入一个 `vector`。举个最简单的栗子，多次查询全局第 $k$ 小值：

```cpp
void solve(int l,int r,vector<query>v){
	if(l==r){for(auto i:v) ans[i.id]=l; return ;}
	int mid=(l+r)/2;
	vector<query>L,R;
	for(auto &i:v){
		if(i.k<=calc(mid)) L.push_back(i);	//calc(x) 返回原序列中 <=x 的数的个数 
		else i.k-=calc(mid),R.push_back(i);
	}
	solve(l,mid,L),solve(mid+1,r,R);
}
```

### 二、区间第 k 小

#### 区间查询第 k 小（静态）

> 多次查询区间第 $k$ 小的数。

仍然考虑询问答案与 $mid$ 的关系：设询问区间内 $\leq mid$ 的数有 $t$ 个，那么当 $k\leq t$ 时，答案应 $\leq mid$；否则，答案应 $>mid$。

区间内 $\leq mid$ 的数的个数可以用树状数组维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,num,a[N],b[N],x,y,k,c[N],ans[N];
struct node{int x,y,k,id,op;};
vector<node>v; 
void modify(int x,int y){
	for(int i=x;i<=n;i+=i&(-i)) c[i]+=y;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) if(i.op) ans[i.id]=l; return ;}
	int mid=(l+r)/2,tmp;
	vector<node>L,R;
	for(auto &i:v){
		if(!i.op) i.x<=mid?(modify(i.id,1),L.push_back(i)):R.push_back(i);
		else{	//此时值 <=mid 的数都已经被插入树状数组中了
			if(i.k<=(tmp=query(i.y)-query(i.x-1))) L.push_back(i);
			else i.k-=tmp,R.push_back(i);
		}
	}
	for(auto i:L) if(!i.op) modify(i.id,-1);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+1+n),num=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+1+num,a[i])-b,v.push_back({a[i],0,0,i,0});	//数都放在询问之前
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&x,&y,&k),v.push_back({x,y,k,i,1});
	solve(1,num,v);
	for(int i=1;i<=m;i++) printf("%d\n",b[ans[i]]);
	return 0;
}
```

不过这样虽然好写，但是空间略劣，理论复杂度不变（实际上可能会慢一丢）。大众写法：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,num,t,a[N],b[N],x,y,k,c[N],ans[N];
struct node{int x,y,k,id,op;}q[N*2],L[N*2],R[N*2];
void modify(int x,int y){
	for(int i=x;i<=n;i+=i&(-i)) c[i]+=y;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,int ql,int qr){
	if(l==r){for(int i=ql;i<=qr;i++) if(q[i].op) ans[q[i].id]=l; return ;}
	int mid=(l+r)/2,tmp,t1=0,t2=0;
	for(int i=ql;i<=qr;i++){
		if(!q[i].op) q[i].x<=mid?(modify(q[i].id,1),L[++t1]=q[i]):R[++t2]=q[i];
		else{
			if(q[i].k<=(tmp=query(q[i].y)-query(q[i].x-1))) L[++t1]=q[i];
			else q[i].k-=tmp,R[++t2]=q[i];
		}
	}
	for(int i=1;i<=t1;i++) if(!L[i].op) modify(L[i].id,-1);
	for(int i=1;i<=t1;i++) q[ql+i-1]=L[i];
	for(int i=1;i<=t2;i++) q[ql+t1+i-1]=R[i];
	solve(l,mid,ql,ql+t1-1),solve(mid+1,r,ql+t1,qr);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+1+n),num=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+1+num,a[i])-b,q[++t]={a[i],0,0,i,0};
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&x,&y,&k),q[++t]={x,y,k,i,1};
	solve(1,num,1,t);
	for(int i=1;i<=m;i++) printf("%d\n",b[ans[i]]);
	return 0;
}
```

#### 带修区间第 k 小（动态）

> [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)：支持单点修改，区间查第 $k$ 小。

修改操作可以直接理解为从原序列中删去一个数再添加一个数。

为什么是对的？整体二分实际上是 对操作序列，**按时间顺序** 进行二分。能影响一个查询操作的仅有时间小于它的修改操作，保证了不会被之后的修改影响。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,q,num,a[N],b[N*2],x,y,k,c[N],ans[N];
char op;
struct node{int x,y,k,id,v;};
vector<node>v; 
void modify(int x,int y){
	for(int i=x;i<=n;i+=i&(-i)) c[i]+=y;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) if(!i.v) ans[i.id]=l; return ;}
	int mid=(l+r)/2,tmp;
	vector<node>L,R;
	for(auto &i:v){
		if(i.v) i.x<=mid?(modify(i.id,i.v),L.push_back(i)):R.push_back(i);
		else{
			if(i.k<=(tmp=query(i.y)-query(i.x-1))) L.push_back(i);
			else i.k-=tmp,R.push_back(i);
		}
	}
	for(auto i:L) if(i.v) modify(i.id,-i.v);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),b[++num]=a[i],v.push_back({a[i],0,0,i,1}); 
	for(int i=1;i<=m;i++){
		scanf(" %c%d%d",&op,&x,&y);
		if(op=='C') v.push_back({a[x],0,0,x,-1}),v.push_back({a[x]=y,0,0,x,1}),b[++num]=y;
		else scanf("%d",&k),v.push_back({x,y,k,++q,0});
	}
	sort(b+1,b+1+num),num=unique(b+1,b+1+num)-b-1;
	for(auto &i:v)
		if(i.v) i.x=lower_bound(b+1,b+1+num,i.x)-b;
	solve(1,num,v);
	for(int i=1;i<=q;i++) printf("%d\n",b[ans[i]]);
	return 0;
}
```

### 三、例题

练练手 qwq。

#### P3527 [POI2011]MET-Meteors

> 给出一个环形序列，被分为 $m$ 段，每段都属于 $n$ 个国家之一。$k$ 次操作，每次给环形序列上的一个区间加上 $x$ 的贡献。求每个国家第几次操作能得到 $p_i$ 贡献（或报告无解）。
>
> $1\le n,m,k\le 3\times 10^5$。

首先显然可以将环转化为序列。

然后答案显然也具有可二分性。单个二分复杂度爆炸，整体二分即可：进行 $[l,mid]$ 内的操作，把已经能得到 $p_i$ 贡献的国家放到左区间，否则将 $p_i$ 减去 $[l,mid]$ 内操作获得的贡献，然后放到右区间。

区间加、单点求值用树状数组维护。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=3e5+5;
int n,m,k,num,l,r,x,ans[N];
LL c[N*2];
struct node{int x,y,k,id;}q[N];
vector<node>v; 
vector<int>a[N];
void modify(int x,int y){
	for(int i=x;i<=2*m;i+=i&(-i)) c[i]+=y;
}
void upd(int l,int r,int v){modify(l,v),modify(r+1,-v);}
LL query(int x){
	LL ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) ans[i.id]=l; return ;}
	int mid=(l+r)/2;
	vector<node>L,R;
	for(int i=l;i<=mid;i++) upd(q[i].x,q[i].y,q[i].k);
	for(auto &i:v){
		LL tmp=0;
		for(int j:a[i.id]) if((tmp+=query(j)+query(j+m))>=i.x) break;
		if(tmp>=i.x) L.push_back(i);
		else i.x-=tmp,R.push_back(i);
	}
	for(int i=l;i<=mid;i++) upd(q[i].x,q[i].y,-q[i].k);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d",&x),a[x].push_back(i);
	for(int i=1;i<=n;i++) scanf("%d",&x),v.push_back({x,0,0,i});
	scanf("%d",&k);
	for(int i=1;i<=k;i++)
		scanf("%d%d%d",&l,&r,&x),q[i]={l,r<l?r+m:r,x,0};
	q[k+1]={1,2*m,(int)1e9,0},solve(1,k+1,v);
	for(int i=1;i<=n;i++){
		if(ans[i]>k) puts("NIE");
		else printf("%d\n",ans[i]);
	} 
	return 0;
}
```

#### P1527 [国家集训队]矩阵乘法

> 给出一个 $n\times n$ 的矩阵，$q$ 次询问，每次求一个子矩阵的第 $k$ 小值。
>
> $1\leq n\leq 500$，$1\leq q\leq 6\times 10^4$，$0\leq a_{i,j}\leq 10^9$。

将区间第 $k$ 小值中的树状数组改为二维树状数组即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,M=6e4+5;
int n,m,num,a[N][N],b[N*N],c[N][N],ans[M];
struct node{int x1,y1,x2,y2,k,id,op;};
vector<node>v; 
void modify(int x,int y,int k){
	for(int i=x;i<=n;i+=i&(-i))
		for(int j=y;j<=n;j+=j&(-j)) c[i][j]+=k;
}
int query(int x,int y){
	int ans=0;
	for(int i=x;i;i-=i&(-i))
		for(int j=y;j;j-=j&(-j)) ans+=c[i][j];
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) if(i.op) ans[i.id]=l; return ;}
	int mid=(l+r)/2,tmp;
	vector<node>L,R;
	for(auto &i:v){
		if(!i.op) i.k<=mid?(modify(i.x1,i.y1,1),L.push_back(i)):R.push_back(i);
		else{
			if(i.k<=(tmp=query(i.x2,i.y2)-query(i.x1-1,i.y2)-query(i.x2,i.y1-1)+query(i.x1-1,i.y1-1))) L.push_back(i);
			else i.k-=tmp,R.push_back(i);
		}
	}
	for(auto i:L) if(!i.op) modify(i.x1,i.y1,-1);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) scanf("%d",&a[i][j]),b[++num]=a[i][j];
	sort(b+1,b+1+num),num=unique(b+1,b+1+num)-b-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=lower_bound(b+1,b+1+num,a[i][j])-b,v.push_back({i,j,0,0,a[i][j],0,0});
	for(int i=1;i<=m;i++){ 
		int x1,y1,x2,y2,k;
		scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&k),v.push_back({x1,y1,x2,y2,k,i,1});
	} 
	solve(1,num,v);
	for(int i=1;i<=m;i++) printf("%d\n",b[ans[i]]);
	return 0;
}
```

#### P3332 [ZJOI2013]K大数查询

> 你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$，初始为空集。$m$ 次操作：
>
> - `1 l r c`：将 $c$ 加入编号在 $[l,r]$ 内的集合中。
> - `2 l r c`：查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数。
>
> $1\leq n,m\leq 5\times 10^4$，操作 1 中 $|c|\leq n$，操作 2 中 $1\leq c<2^{63}$。

用线段树维护区间内比 $mid$ 大的个数。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=5e4+5;
int n,m,op,x,y,k,q,tag[N<<2],ans[N];
LL sum[N<<2];
struct node{int l,r,k,id;};
vector<node>v;
void pushdown(int p,int l,int r,int mid){
	if(!tag[p]) return ;
	tag[p<<1]+=tag[p],sum[p<<1]+=tag[p]*(mid-l+1);
	tag[p<<1|1]+=tag[p],sum[p<<1|1]+=tag[p]*(r-mid),tag[p]=0;
}
void modify(int p,int l,int r,int lx,int rx,int v){
	if(l>=lx&&r<=rx){tag[p]+=v,sum[p]+=(r-l+1)*v;return ;}
	int mid=(l+r)/2;
	pushdown(p,l,r,mid);
	if(lx<=mid) modify(p<<1,l,mid,lx,rx,v);
	if(rx>mid) modify(p<<1|1,mid+1,r,lx,rx,v);
	sum[p]=sum[p<<1]+sum[p<<1|1]; 
}
LL query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return sum[p];
	int mid=(l+r)/2; LL ans=0;
	pushdown(p,l,r,mid);
	if(lx<=mid) ans+=query(p<<1,l,mid,lx,rx);
	if(rx>mid) ans+=query(p<<1|1,mid+1,r,lx,rx);
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) if(i.id) ans[i.id]=l; return ;}
	int mid=(l+r)>>1; LL tmp;	//l,r 可能为负，必须写 >>1 而不是 /2
	vector<node>L,R;
	for(auto &i:v){
		if(!i.id) i.k>mid?(modify(1,1,n,i.l,i.r,1),R.push_back(i)):L.push_back(i);
		else{
			if(i.k<=(tmp=query(1,1,n,i.l,i.r))) R.push_back(i);
			else i.k-=tmp,L.push_back(i);
		}
	}
	for(auto i:R) if(!i.id) modify(1,1,n,i.l,i.r,-1);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d%d",&op,&x,&y,&k),v.push_back({x,y,k,op==2?++q:0});
	solve(-n,n,v);
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
	return 0;
}
```

这题也可以用树套树做。线段树维护集合编号，树状数组维护集合中的数字，然后在树状数组上二分即可。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e5+5,M=N<<7;
int n,m,op,l,r,x,tot,rt[N],lc[M],rc[M],tag[M];
LL sum[M];
void pushdown(int p,int l,int r,int mid){
	if(!tag[p]) return ;
	if(!lc[p]) lc[p]=++tot;
	if(!rc[p]) rc[p]=++tot;
	tag[lc[p]]+=tag[p],sum[lc[p]]+=tag[p]*(mid-l+1),tag[rc[p]]+=tag[p],sum[rc[p]]+=tag[p]*(r-mid);
	tag[p]=0;
}
void modify(int &p,int l,int r,int lx,int rx){
	if(!p) p=++tot;
	if(l>=lx&&r<=rx){tag[p]++,sum[p]+=r-l+1;return ;}
	int mid=(l+r)/2;
	pushdown(p,l,r,mid);
	if(lx<=mid) modify(lc[p],l,mid,lx,rx);
	if(rx>mid) modify(rc[p],mid+1,r,lx,rx);
	sum[p]=sum[lc[p]]+sum[rc[p]]; 
}
LL query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return sum[p];
	int mid=(l+r)/2; LL ans=0;
	pushdown(p,l,r,mid);
	if(lx<=mid) ans+=query(lc[p],l,mid,lx,rx);
	if(rx>mid) ans+=query(rc[p],mid+1,r,lx,rx);
	return ans;
}
void add(int x,int l,int r){
	for(int i=x;i<=2*n+1;i+=i&(-i)) modify(rt[i],1,n,l,r);
} 
int find(int l,int r,int k){
	int x=0; LL tmp=0,s=0;
	for(int i=20;i>=0;i--)
		if(x+(1<<i)<=2*n+1&&s+(tmp=query(rt[x+(1<<i)],1,n,l,r))<k) s+=tmp,x+=(1<<i);
	return x+1;
}
signed main(){
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d%d%d",&op,&l,&r,&x);
		if(op==1) add(n-x+1,l,r);
		else printf("%d\n",-find(l,r,x)+n+1);
	}
	return 0;
}
```

#### P3250 [HNOI2016]网络

> 给出一棵 $n$ 个节点的树，$m$ 次操作：
>
> - `0 x y k`：在 $x,y$ 的路径上添加一个重要度为 $k$ 的请求。
> - `1 t`：结束第 $t$ 次操作的请求。
> - `2 x`：假设 $x$ 发生故障，未被影响的请求的最大重要度为多少，若没有请求输出 $-1$。
>
> $2\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$，$k,t\leq 10^9$。

考虑二分答案，如果 $\geq mid$ 的请求都经过 $x$，那么答案一定 $<mid$，否则答案 $\geq mid$。

问题转化为，如何判断 $\geq mid$ 的请求是否都经过 $x$。树状数组维护树上差分（或者直接上树链剖分）即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,num,a[N],op,x,y,k,c[N],dep[N],f[N][25],q,tot,dfn[N],ed[N],ans[N];
vector<int>g[N];
struct node{int x,y,lca,k,id,v;};
vector<node>v;
void dfs(int x,int fa){
	dep[x]=dep[fa]+1,dfn[x]=++tot;
	for(int i=0;i<=19;i++) f[x][i+1]=f[f[x][i]][i];
	for(int y:g[x])
		if(y!=fa) f[y][0]=x,dfs(y,x);
	ed[x]=tot;
} 
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void add(int x,int y){
	if(x) for(int i=x;i<=n;i+=i&(-i)) c[i]+=y;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void upd(int x,int y,int lca,int k){
	add(dfn[x],k),add(dfn[y],k),add(dfn[lca],-k),add(dfn[f[lca][0]],-k);
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) ans[i.id]=a[l];return ;}
	int mid=(l+r)/2,cur=0;	//cur 表示 >=mid 的请求的个数
	vector<node>L,R;
	for(auto i:v){
		if(!i.id) i.k>mid?(cur+=i.v,upd(i.x,i.y,i.lca,i.v),R.push_back(i)):L.push_back(i);
		else{
			if(query(ed[i.x])-query(dfn[i.x]-1)==cur) L.push_back(i);	//>=mid 的请求全都经过 x
			else R.push_back(i);
		}
	} 
	for(auto i:R) if(!i.id) upd(i.x,i.y,i.lca,-i.v);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
	dfs(1,0);
	while(m--){
		scanf("%d%d",&op,&x);
		if(!op) scanf("%d%d",&y,&k),v.push_back({x,y,lca(x,y),k,0,1}),a[++num]=k;
		else if(op==1) v.push_back(v[x-1]),v[v.size()-1].v=-1;
		else v.push_back({x,0,0,0,++q,0});
	}
	sort(a+1,a+1+num),num=unique(a+1,a+1+num)-a-1;
	for(auto &i:v)
		if(!i.id) i.k=lower_bound(a+1,a+1+num,i.k)-a; 
	a[0]=-1,solve(0,num,v);
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
	return 0;
} 
```

#### P4175 [CTSC2008]网络管理

> 给出一棵 $n$ 个节点的树，点有点权。$m$ 次操作：
>
> - `0 x y`：将节点 $x$ 的点权改为 $y$。
> - `1 x y k`：求 $x,y$ 路径上第 $k$ 大的点权（若不足 $k$ 个点输出 `invalid request!`）。
>
> $1\leq n,q\leq 8\times 10^4$，$0\leq k\leq n$，点权 $\leq 10^8$。

考虑二分答案 check 的条件：如果 $x,y$ 路径上点权 $>mid$ 的点 $\geq k$ 个，则答案 $>mid$，否则答案 $\leq mid$。

问题转化为求树链上点权 $\geq mid$ 的点的个数。需要实现的是，单点加，树链求和。考虑维护每个节点到根路径上点的个数，那么每次单点加影响子树（使子树内的点，到根路径上点的个数 $+1$），问题转化为子树加、单点求值，树状数组维护树上差分即可。或者直接上树链剖分也 ok。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e4+5;
int n,m,num,a[N],b[N*2],x,y,k,c[N],dep[N],f[N][25],q,tot,dfn[N],ed[N],ans[N];
vector<int>g[N];
struct node{int x,y,lca,k,id;};
vector<node>v;
void dfs(int x,int fa){
	dep[x]=dep[fa]+1,dfn[x]=++tot;
	for(int i=0;i<=19;i++) f[x][i+1]=f[f[x][i]][i];
	for(int y:g[x])
		if(y!=fa) f[y][0]=x,dfs(y,x);
	ed[x]=tot;
} 
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void add(int x,int y){
	for(int i=x;i<=n;i+=i&(-i)) c[i]+=y;
}
void upd(int x,int y,int k){add(x,k),add(y+1,-k);}
int query(int x){
	int ans=0;
	if(x) for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<node>v){
	if(l==r){for(auto i:v) ans[i.id]=b[l];return ;}
	int mid=(l+r)/2,tmp;
	vector<node>L,R;
	for(auto &i:v){
		if(!i.id) i.y>mid?(upd(dfn[i.x],ed[i.x],i.k),R.push_back(i)):L.push_back(i);
		else{
			if((tmp=query(dfn[i.x])+query(dfn[i.y])-query(dfn[i.lca])-query(dfn[f[i.lca][0]]))>=i.k) R.push_back(i);
			else i.k-=tmp,L.push_back(i);
		}
	} 
	for(auto i:R) if(!i.id) upd(dfn[i.x],ed[i.x],-i.k);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),b[++num]=a[i],v.push_back({i,a[i],0,1,0}); 
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
	dfs(1,0);
	while(m--){
		scanf("%d%d%d",&k,&x,&y);
		if(!k) v.push_back({x,a[x],0,-1,0}),v.push_back({x,a[x]=y,0,1,0}),b[++num]=y;
		else v.push_back({x,y,lca(x,y),k,++q});
	}
	sort(b+1,b+1+num),num=unique(b+1,b+1+num)-b-1;
	for(auto &i:v)
		if(!i.id) i.y=lower_bound(b+1,b+1+num,i.y)-b;
	b[0]=-1,solve(0,num,v);
	for(int i=1;i<=q;i++){
		if(~ans[i]) printf("%d\n",ans[i]);
		else puts("invalid request!");
	} 
	return 0;
} 
```

#### P7424 [THUPC2017] 天天爱射击

2022.7.23

把木板和子弹放一起，以时间为关键字二分。

枚举时间 $\in[l,mid]$ 的子弹，在树状数组上把它对应位置 $+1$。然后枚举木板，区间查询它所覆盖区间有多少子弹，若它的权值 $\leq$ 子弹个数，就扔到左区间，否则将它的权值减去子弹个数，然后扔到右区间。

注意二分上界为 $m+1$，因为可能有木板到最后都没有消失。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,x[N],y[N],a[N],p[N],c[N],ans[N];
vector<int>v;
void add(int x,int y){
	for(int i=x;i<=2e5;i+=i&(-i)) c[i]+=y;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<int>v){
	if(l==r){ans[l]+=v.size();return ;}
	int mid=(l+r)/2;
	for(int i=l;i<=mid;i++) add(p[i],1);
	vector<int>L,R;
	for(int i:v){
		int tmp=query(y[i])-query(x[i]-1);
		if(a[i]<=tmp) L.push_back(i);
		else a[i]-=tmp,R.push_back(i); 
	}
	for(int i=l;i<=mid;i++) add(p[i],-1);
	solve(l,mid,L),solve(mid+1,r,R);
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&x[i],&y[i],&a[i]),v.push_back(i);
	for(int i=1;i<=m;i++) scanf("%d",&p[i]);
	solve(1,m+1,v);
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

#### P3242 [HNOI2015] 接水果

2022.7.23

> 给出一棵 $n$ 个节点的树，有 $p$ 个盘子，每个盘子实际上是一条路径，有权值。有 $q$ 个水果，求水果包含的盘子中（盘子是水果的子路径），第 $k$ 小的权值。
>
> $1\leq n,p,q\leq 4\times 10^4$，$0\leq c\leq 10^9$。

考虑树上路径包含，可以转化为 DFS 序的大小关系。

考虑水果 $(x,y)\,(dfn_x<dfn_y)$ 包含的盘子 $(u,v)\,(dfn_u<dfn_v)$：

- $u,v$ 不互为祖先关系：则 $x$ 在 $u$ 的子树内，$y$ 在 $v$ 的子树内。$dfn_x\in[dfn_u,ed_u]$，$dfn_y\in[dfn_v,ed_v]$。
- $u$ 是 $v$ 的祖先：设 $w$ 为子树中包含 $v$ 的那个 $u$ 的子节点，则 $x,y$ 只要一个在 $w$ 子树外，一个在 $v$ 子树内即可。$dfn_x\in[1,dfn_w-1]$，$dfn_y\in[dfn_v,ed_v]$，或 $dfn_x\in[dfn_v,ed_v]$，$dfn_y\in[ed_w+1,n]$。

考虑整体二分，二分当前答案，则只要知道有多少 $\leq$ 当前答案的点即可。

考虑每个盘子贡献的水果是一/二个矩形，扫描线即可：把不等关系放在平面上，就是给出若干矩形和点，求每个点被覆盖的矩形中，权值第 $k$ 小的矩形。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,p,q,x,y,c[N],cnt,val[N],f[N][25],tim,dfn[N],ed[N],dep[N],ans[N];
vector<int>g[N];
struct A{int x,y,v;}a[N];
struct B{int x,y,k,id;}b[N];
vector<B>v;
struct seg{int x,l,r,v;}S[N<<2];
vector<seg>s;
void dfs(int x,int fa){
	dfn[x]=++tim;
	for(int i=0;i<=19;i++) f[x][i+1]=f[f[x][i]][i];
	for(int y:g[x])
		if(y!=fa) dep[y]=dep[x]+1,f[y][0]=x,dfs(y,x);
	ed[x]=tim;
}
void add(int x,int y){
	for(int i=x;i<=n+1;i+=i&(-i)) c[i]+=y;
}
void upd(int l,int r,int k){add(l,k),add(r+1,-k);}	//某 sb -k 打成 k 调半天
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&(-i)) ans+=c[i];
	return ans;
}
void solve(int l,int r,vector<seg>s,vector<B>v){
	if(l==r){for(B i:v) ans[i.id]=l;return ;}
	int mid=(l+r)/2,j=0;
	vector<seg>sl,sr;
	vector<B>vl,vr;
	for(B &i:v){
		while(j<s.size()&&s[j].x<=i.x){	//扫描线
			if(abs(s[j].v)<=mid) upd(s[j].l,s[j].r,s[j].v>0?1:-1),sl.push_back(s[j]);
			else sr.push_back(s[j]); j++;
		}
		if(query(i.y)>=i.k) vl.push_back(i);	//判断询问扔哪边
		else i.k-=query(i.y),vr.push_back(i);
	}
	while(j<s.size()){	//对剩余修改分组，完成所有修改也就完成了清空
		if(abs(s[j].v)<=mid) upd(s[j].l,s[j].r,s[j].v>0?1:-1),sl.push_back(s[j]);
		else sr.push_back(s[j]); j++;
	}
	solve(l,mid,sl,vl),solve(mid+1,r,sr,vr);
}
signed main(){
	scanf("%d%d%d",&n,&p,&q);
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
	dfs(1,0);
	for(int i=1;i<=p;i++)
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].v),val[++cnt]=a[i].v;
	sort(val+1,val+1+cnt),cnt=unique(val+1,val+1+cnt)-val-1;
	for(int i=1;i<=p;i++){
		int x=a[i].x,y=a[i].y,v=lower_bound(val+1,val+1+cnt,a[i].v)-val;
		if(dfn[x]>dfn[y]) swap(x,y);
		auto add=[&](int xl,int xr,int yl,int yr,int v){	//加一个矩阵
			if(yl<=yr) S[++m]={xl,yl,yr,v},S[++m]={xr+1,yl,yr,-v};
		};
		if(dfn[y]<dfn[x]||dfn[y]>ed[x]) add(dfn[x],ed[x],dfn[y],ed[y],v);	//不互为祖先关系
		else{	//互为祖先关系
			int w=y;
			for(int i=20;i>=0;i--) if(dep[f[w][i]]>dep[x]) w=f[w][i];
			add(1,dfn[w]-1,dfn[y],ed[y],v),add(dfn[y],ed[y],ed[w]+1,n,v);
		}
	}
	sort(S+1,S+1+m,[](seg x,seg y){return x.x<y.x;});	//记得排序
	for(int i=1;i<=m;i++) s.push_back(S[i]);
	for(int i=1;i<=q;i++){
		scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].k),b[i].id=i;
		if((b[i].x=dfn[b[i].x])>(b[i].y=dfn[b[i].y])) swap(b[i].x,b[i].y);
	}
	sort(b+1,b+1+q,[](B x,B y){return x.x<y.x;});	//记得排序
	for(int i=1;i<=q;i++) v.push_back(b[i]);
	solve(1,cnt,s,v);
	for(int i=1;i<=q;i++) printf("%d\n",val[ans[i]]);
	return 0;
}
```

