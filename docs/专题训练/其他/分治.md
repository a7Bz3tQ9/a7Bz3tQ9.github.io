### 二分 / 倍增

#### 01 分数规划

二分答案，移项。

有一个优化二分的技巧，比如：

> 给出一张带权有向图，求一条 $S\to T$ 的路径，使得该路径上的权值平均数最小。

二分答案 $mid$，判是否存在平均数 $\leq mid$ 的路径，$\sum_{i\in S} w_i\cdot mid\leq |S|\Leftrightarrow\sum(w_i-mid)\leq 0$。将所有权值 $-mid$ 跑最短路。

本来 $[l,r]\to [l,mid]$，现在求出这条 $\sum(w_i-mid)\leq 0$ 的路径的平均值 $avg$，直接 $[l,r]\to [l,avg]$，这样二分次数会大大减少。 

#### 倍增 + 二分

一个套路 / 技巧：先倍增定个界，再这个界里二分

> 有 $n$ 个点，给出 $m$ 条边，你需要将这些边划分成尽量多的区间，使得对于每个区间，只连这个区间里的边后，$n$ 个点都连通且最小生成树边权和 $\leq W$。
>
> $n,m\leq 10^5$。

一个显然的贪心：不断加边，若当前区间已经连通且 MST $\leq W$，就去分下一个区间。但每次都要将当前区间的边按边权排序做 Kruskal。时间复杂度 $\mathcal O(n^2\log n)$（假设 $n,m$ 同阶）。

对于当前左端点 $l$，二分找最小的右端点 $r$ 使得满足条件。如果每段都很小，比暴力还慢。时间复杂度 $\mathcal O(n^2\log^2 n)$。

考虑先大致地判断区间长度，在这个范围内二分：用倍增，不断尝试区间长度为 $2^1,2^2,\cdots,2^k$，若 $2^k$ 时不满足 $\leq W$，在 $[2^{k-1},2^k)$ 中二分。因为倍增后二分的上下界控制在 $len_i\sim 2len_i$ 中，于是倍增和二分的复杂度是 $\mathcal O(len_i\log len_i)$。共 $\mathcal O(\sum_i len_i\log len_i)=\mathcal O(n\log n)$，实际应该是跑不满的。

时间复杂度 $\mathcal O(n\log^2 n)$。

这个技巧在 [ZR#2543. 23省选10连测day9-分割](http://zhengruioi.com/problem/2543) 中考到了。大概是贪心分段、check 复杂度与段长有关、利用段总长 $\mathcal O(n)$ 来做的二分套路。

#### 倍增优化二分

二分是 $[l,r]\to [l,mid],[mid,r]$。

也可以倍增，每次让下界 $+2^k$。典型应用：树状数组倍增求第 $k$ 小。

#### HDU 4343

HDU 4343 Interval query

> 给出 $n$ 个区间 $[l_i,r_i]$，$m$ 次询问，每次给出 $L,R$，询问值域 $[L,R]$ 中最多选出多少不相交的区间。
>
> $n,m\leq 10^5$，$0\leq l_i\leq r_i\leq 10^9$。

若一个大区间包含一个小区间，显然选小区间更优。把包含情况去除，将剩下的区间按 $l$ 排序，那么 $r$ 递增。

贪心：每次在右边找左端点最小的与它不相交的区间。

预处理 $jump_i$ 表示区间 $i$ 往右找第一个与它不相交的区间是哪个。复杂度还是不优。倍增，$f_{i,j}$ 表示 $jump$ 了 $2^j$ 次。每次从大到小枚举 $2^k$ 看看能不能跳。

#### HDU 6031

HDU 6031 Innumerable Ancestors

> 给出一棵 $n$ 个点的树，根为 $1$。$m$ 次询问，每次给出点集 $A,B$，你需要从 $A,B$ 中分别选一个数 $x,y$，求 $dep_{\text{lca}(x,y)}$ 的最大值。
>
> $1\leq n,m\leq 10^5$，$\sum|A|+|B|\leq 10^5$。

二分答案 $dep$。设 $fa_{x,dep}$ 表示 $x$ 深度为 $dep$ 的祖先，则 $\exists x\in A,y\in A$，$fa_{x,dep}=fa_{y,dep}$。判 $\{fa_{x,dep}\mid x\in A\}$ 与 $\{fa_{x,dep}\mid x\in B\}$ 是否有交即可。

### 分治

整体二分是对权值分治。

`nth_element`：找一个 $x$，比它小的放左边，比它大的放右边，若左边有 $\geq k$ 个就递归左边，否则递归右边。

**二维平面上最近点对：**

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220831094950418-842264740.png" alt="image" style="zoom:50%;" />

对 $x$ 坐标分治，设递归两边算出的最小距离是 $d$，那么这次只需考虑这些点：

<img src="https://img2023.cnblogs.com/blog/1859218/202301/1859218-20230131182936019-1068696744.png" alt="image" style="zoom: 60%;" />

可以证明这个范围内的点很少。

若直接 sort 对 $y$ 坐标排序，时间复杂度 $\mathcal O(n\log^2 n)$。

**分治多项式乘法：**

$A(x)=C(x)x^{n/2}+D(x)$，$B(x)=E(x)x^{n/2}+F(x)$，则 $AB=CEx^n+(CF+DE)x^{n/2}+DF$。

若递归算 $CE,CF,DE,DF$，$T(n)=4T(\frac n 2)+\mathcal O(n)=\mathcal O(n^2)$。

我们只需要求 $CF+DE$ 而不关心 $CF,DE$ 具体是什么。考虑递归算 $CE,DF,(C+D)(E+F)$，$CF+DE=(C+D)(E+F)-CE-DF$。$T(n)=3T(\frac n 2)+\mathcal O(n)=\mathcal O(n^{\log_2 3})=\mathcal O(n^{1.58})$。

#### A1

> 给出 $a_{1\sim n}$，求有多少区间 $[l,r]$，满足 $a_l\lor a_{l+1}\lor\cdots\lor a_r>\max(a_{l\sim r})$。
>
> $n\leq 3\times 10^5$。

注意到一定有 $a_l\lor a_{l+1}\or\cdots\lor a_r\geq \max(a_{l\sim r})$，只要排除掉 $=$ 的情况。

分治，设当前分治区间 $[l,r]$ 最大值为 $a_x$，那么 $[l,r]$ 中跨过 $x$ 的区间最大值都是 $a_x$。或起来 $>a_x$，说明 $a_x$ 中至少有一个为 $0$ 的位变成 $1$ 了。

预处理 $right_{x,i}$ 表示 $x$ 右边第一个第 $i$ 位为 $1$ 的数，则从 $x$ 往右走第一个能使 $0\to 1$ 的位置就是 $pr=\min_{2^i\notin a_x}(right_{x,i})$，只要 $R\geq pr$ 就满足 $>$ 的条件了，方案数 $(x-l+1)(r-pr+1)$。

往左走也能找到第一个 $pl$，方案数 $(pl-l+1)(r-x+1)$。

$L\leq pl\land R\geq pr$ 的区间算重了。减掉 $(pl-l+1)(r-pr+1)$。

（实际上是在算 $L\leq pl$ 或 $R\geq pr$ 的方案数）

#### A2

BZOJ 3897 Power

> 有一个人在打工，每天可以恢复 $a_i$ 的体力，第 $i$ 天每点体力可以换取 $b_i$ 的收益。体力有上限 $S$，求获得收益的最大值。
>
> $n\leq 5\times 10^5$，$S\leq 10^6$。

设 $b_i$ 最大的是第 $x$ 天，我们希望这天能消耗尽量多的体力。

1. $\sum_{i=1}^x a_i\leq S$：前 $x$ 天一直休息，第 $x$ 天换收益。
2. 否则：只要前 $x$ 天还剩 $S-a_x$ 的体力即可。

$solve(l,r,st,ed)$ 表示第 $l\sim r$ 天，初始有 $st$ 的体力，要求最后留下 $ed$ 的体力。$solve(1,n,0,0)\to ans$。

找到 $[l,r]$ 中 $b_i$ 最大的第 $x$ 天。

1. $st+\sum_{i=l}^x a_i\leq S$：$\sum_{i=x+1}^r a_i\geq ed$，则第 $x$ 天可以把体力用完，$solve(x+1,n,0,ed)$，否则 $solve(x+1,n,ed-\sum_{i=x+1}^r a_i,ed)$。
2. 否则：$solve(l,x-1,st,S-a_x)$，$[x+1,n]$ 同上。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220831102322478-170948552.png" alt="image" style="zoom:50%;" />

#### A3

CF888G Xor-MST（\*2300）

> 给出 $a_{1\sim n}$，定义 $(i,j)$ 的边权为 $a_i\oplus a_j$，求最小生成树。

最高位分成为 $0$ 和为 $1$ 的两部分，两部分连一条边怎么连：枚举小的那部分 + 区间 trie。

### 处理”缺一“

分治处理除去每个位置的信息。

- **妙处：**若两个区间合并的复杂度较高，利用分治就 **只有插入没有合并** 了。

经典题 CF1442D。

#### [Baekjoon 19520 Point Pairs](https://vjudge.net/problem/Baekjoon-19520)

> 给出平面上 $2n+1$ 个点 $(x_i,y_i)$。点 $i,j$ 能匹配当且仅当 $x_i=x_j$ 或 $y_i=y_j$。
>
> 对每个 $i$，求去掉点 $i$，剩下的 $2n$ 个点能否两两匹配。
>
> $1\leq n\leq 10^5$，$1\leq x_i,y_i\leq 2n+1$，保证 $(x_i,y_i)$ 互不相同。

妙妙转化：建立二分图，左边是对每种 $x$ 坐标建的点，右边是对 $y$。对于一个点 $(x_i,y_i)$，在左边 $x_i$ 表示的点和右边 $y_i$ 表示的点之间连边。那么每次配对相当于删去一个长度为 $2$ 的链。

问题转化为，有一张 $2n+1$ 条边的图，对每条边求去掉它剩下的图能否删完。

每个连通块独立。

- 性质：一个连通块存在合法的两两配对当且仅当边数为偶数。

  证明：必要性显然。充分性就是找长度为 $2$ 的链覆盖，这个在 ZR#1905 出现过（回顾：求出 DFS 树，回溯 $x$ 时尝试两两匹配以 $x$ 为祖先的返祖边、未匹配的 $x$ 与儿子的边，最多剩下一条，若剩下就将它与 $x$ 的父边匹配。由于边数为偶数所以回溯根时一定能两两匹配完）。

用并查集维护连通块。合并并查集是很难的，但插入是简单的，分治处理“缺一”即可。

### 处理决策单调性



### CDQ 分治

分治时考虑左边对右边的贡献。

三维偏序：分治去掉一维，两边排序产生的偏序去掉一维，树状数组去掉一维。

### 整体二分

思想：一起做这 $q$ 次二分。

> 对一个长度为 $n$ 的序列 $a_1,\cdots,a_n$，有 $q$ 次操作：
>
> - `1 l r k`：求区间 $[l,r]$ 中第 $k$ 小的数。
>
> $n,q\leq 10^5$。

`solve(A,l,r)`，将 $A$ 中答案在 $[l,mid]$ 的丢到 $L$，剩下的丢掉 $R$，递归 `solve(L,l,mid),solve(R,mid+1,r)`。递归到叶子就找到了答案。

若一个询问区间中在值域 $[1,mid]$ 的数的个数 $\geq k$，意味着这个询问的答案在 $[mid+1,r]$。单点加，区间修改，可以树状数组维护。但复杂度是错误的，比如 $[1,1]$ 会在 $[1,1],[1,2],[1,4],[1,8],\cdots$ 算，$[1,2]$ 也会算很多次，类似一个前缀和一样的东西，那这样值域区间总长度就是 $\mathcal O(n^2)$ 的，会做 $\mathcal O(n^2)$ 次树状数组的加点操作。

考虑优化，将 $[1,mid]$ 改为 $[l,mid]$。设区间中有 $t$ 个数 $\in[l,mid]$，若 $t\geq k$，$ans\in[l,mid]$，若 $t<k$，$ans\in[mid+1,r]$，然后让 $k\gets k-t$，这样后续就不需要管在值域 $[l,mid]$ 中的数了。

总结：和 cdq 一样，无论是修改还是清空树状数组，分治时复杂度要和区间长度有关，复杂度才是对的。

#### [AGC002D] Stamp Rally

判断答案 $\leq mid$：连上编号 $\leq mid$ 的边，若 $x,y$ 所在连通块的点集大小 $\geq k$ 则合法。

整体二分优化，通过加一些边从 $\leq l$ 的并查集得到 $\leq mid$ 的并查集，然后撤销。

### 最值分治

以区间最大值/最小值作为 $mid$。递归层数没有保证，如果处理复杂度 $\mathcal O(r-l+1)$ 能被卡到 $\mathcal O(n^2)$，但如果处理复杂度是 $\mathcal O(\min(mid-l,r-mid))$，复杂度就是 $\mathcal O(n\log n)$，因为倒着看分治的过程就是启发式合并。

当然 $mid$ 也不一定取最值，可以是根据题意满足某种条件具有特殊性质的值。一个找 $mid$ 的 trick：从小到大枚举 $\min(mid-l,r-mid)$，这样找 $mid$ 的复杂度就是 $\mathcal O(\min(mid-l,r-mid))$ 了。

<img src="https://img2023.cnblogs.com/blog/1859218/202301/1859218-20230131195810603-1886725697.png" alt="image" style="zoom:50%;" />

维护 $[l,r]$ 元素集合 $S$：如果每次直接加，复杂度与区间长度有关，就寄了。一个 trick 是，我们钦定调用 `solve(l,r)` 时一个全局的 $S$ 已经恰好包含了 $[l,r]$，退出 `solve(l,r)` 时保证 $S$ 是清空的（初始 $S$ 为 $[1,n]$ 调用 `solve(1,n)`，在 $l=r$ 时删掉 $l$ 即可实现）。`solve(l,r)` 时，比如 $[mid+1,r]$ 更短，先从 $S$ 中删除 $[mid+1,r]$，这样 $S$ 就是 $[l,mid]$ 了，递归 `solve(l,mid)`；退出 `solve(l,mid)` 后 $S$ 为空，再从 $S$ 中加入 $[mid+1,r]$ 递归 `solve(mid+1,r)`，退出后 $S$ 为空，实现了处理复杂度 $\mathcal O(\min(mid-l,r-mid))$！$S$ 需要支持插入和删除。

#### Gym101623F Factor-Free Tree

> 有一棵 $n$ 个节点的树，点有点权 $a_i$，树上任意有祖先关系的两点 $x\neq y$ 有 $\gcd(a_x,a_y)=1$。现在给出这棵树的中序遍历的 $a_i$，要求还原这棵树，无解输出 `impossible`。
>
> $1\leq n\leq 10^6$，$1\leq a_i\leq 10^7$，6s。

分治，`solve(l,r)` 表示构造中序遍历中 $[l,r]$ 区间内的点的子树。根节点一定要与子树中的其他数互质，发现可以任取一个符合条件的根。按照上面所说从两边开始找 $mid$、钦定调用时维护好 $S$ 且退出时 $S$ 清空，做到 $\mathcal O(\min(mid-l,r-mid))$ 找到 $mid$ 并维护好 $S$ 表示 $a_{l\sim r}$。

维护 $S$，支持：加入一个数，删除一个数，询问一个数与其他数互质。直接质因数分解维护每个质因子在多少个数中出现，查询时 check 被查询数的每个质因子出现次数是否都为 $1$ 即可。

[code by lqs2015](https://codeforces.com/gym/101623/submission/87395032)

方法 2：对于每个 $a_i$，维护前面第一个不与它互质的数 $pre_i$，后面第一个不与它互质的数 $suf_i$。`solve(l,r)` 时，按照上面所说从两边往中间找 $pre_{mid}<l\land suf_{mid}>r$ 的 $mid$。但这样就不需要维护 $S$ 了。
