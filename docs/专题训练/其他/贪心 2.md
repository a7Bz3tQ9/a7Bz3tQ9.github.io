### 一、简介

提出假设：直觉。

先猜想后证明。

- 反证法：假设存在更优解，证明该解不合法；或者调整不能使答案更优。
- 归纳法：归纳证明前 $i$ 步是最优解，证到全局解最优。

### A. 二分贪心

#### A1

P5021 [NOIP2018 提高组] 赛道修建

> 给出一棵 $n$ 个节点的树，边有边权。选出 $m$ 条边不相交的路径（点可以相交），最大化最小的路径边权和。
>
> $2\leq n\leq 5\times 10^4$，$1\leq m\leq n-1$，$1\leq w_i\leq 10^4$。

二分答案，看能否放 $m$ 条边权和 $\geq mid$ 的。

考虑一些顶端为 $x$ 的路径，至多只有一条往上覆盖 $x$ 的父边延伸到 $fa_x$。去掉其中 $\geq mid$ 的，剩下的都 $<mid$。只有一条能延伸上去，其余的两两拼出尽量多 $\geq mid$ 的路径。

在最大化匹配数目的前提下最大化延伸上去的路径长度，这样肯定是不劣的。所以从小到大考虑每条路径，和 `it=s.lower_bound(mid-len[i])` 拼然后删掉 `it`。

（补充：如果边也可以相交，那么最小路径数就是 $\lceil\frac{leaves}{2}\rceil$）

#### A2

[AGC032E] Modulo Pairing

> 给出 $a_{1\sim 2n}$，$0\leq a_i<m$，找出一组大小为 $n$ 的匹配，使得最大权值最小。一组匹配 $(x,y)$ 的权值为 $(x+y)\bmod m$。
>
> $1\leq n\leq 10^5$，$1\leq m\leq 10^9$。

将 $a$ 从小到大排序。将 $a_x+a_y<m$ 的匹配 $(x,y)$ 看作蓝线，否则是红线。

同种颜色的只有包含关系最优：（原来最大的和调整完的两条线比）

<img src="https://img2023.cnblogs.com/blog/1859218/202212/1859218-20221203172045571-1452585336.png" alt="image" style="zoom:50%;" />

不同颜色的只有相离关系最优：（蓝线变小了；红线代价必然 $<$ 左端点，故不超过原来蓝线）

<img src="https://img2023.cnblogs.com/blog/1859218/202212/1859218-20221203172137106-1507099659.png" alt="image" style="zoom:50%;" />

所以最后一定是这样的形式：

<img src="https://img2023.cnblogs.com/blog/1859218/202212/1859218-20221203172520868-637487253.png" alt="image" style="zoom:50%;" />

将分界线往左调，每条线的代价都会变小，但若分界线太左了，右侧的红线可能会变成蓝线，所以二分找到最靠左的合法分界线即可，合法指右边都是红线。

key：混合贪心可以先让局部最优，再考虑怎么拓展到整体最优。

### B. 字典序贪心

#### B1

[AGC037E] Reversing and Concatenating

> 给出一个长度为 $n$ 的字符串 $s$，执行 $k$ 次操作，每次从 $s+s^R$ 中（其中 $s^R$ 表示 $s$ 的反串）截取一个长度为 $n$ 的字符串作为新的 $s$。求最终能得到字典序最小的 $s$。
>
> $1\leq n\leq 5000$，$1\leq k\leq 10^9$。

降智题。想到了把最小的字符放开头，然后不会了。

考虑 $s+s^R$ 中，若存在一个长度为 $len\,(len\leq n)$ 的子串只包含字符 $c$，则可以使最终的串开头 $len\times 2^{k-1}$ 个字符全部为 $c$，剩下的字符为这个子串前面长度为 $n-len\times 2^{k-1}$ 的子串的翻转。

具体操作就是，先截取以这 $len$ 个字符 $c$ 为结尾的长度为 $n$ 的串，翻转后以中间 $2\cdot len$ 个字符 $c$ 为结尾继续翻转，以此类推，最终能得到 $len\times 2^{k-1}$ 个字符 $c$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int n,k,p,len,x;
char s[N];
bool ok(int x,int y){
	for(int i=1;i<=n;i++)
		if(s[x-i+1]!=s[y-i+1]) return s[x-i+1]<s[y-i+1];
	return 0;
}
signed main(){
	scanf("%d%d%s",&n,&k,s+1);
	for(int i=1;i<=n;i++) s[i+n]=s[n-i+1];
	for(int i=n;i<=2*n;i++)
		if(!p||ok(i,p)) p=i;
	while(s[p]==s[p-x]) x++;
	len=x;
	for(int i=1;i<k;i++) x=min(x*2,n);
	for(int i=1;i<=x;i++) putchar(s[p]);
	for(int i=1;i<=n-x;i++) putchar(s[p-len-i+1]);
	return 0;
}
```

#### B2

P5659 [CSP-S2019] 树上的数

> 给出一棵 $n$ 个节点的树，每个点上有一个数，这些数形成 $1\sim n$ 的排列。
>
> 你需要进行恰好 $n-1$ 次删边操作，每次删掉一条未删的边，并交换这条边两端的点上的数。$n-1$ 次操作后，设 $p_i$ 表示数 $i$ 所在的点的编号，最小化排列 $p_{1\sim n}$ 的字典序。输出 $p$。
>
> $1\leq T\leq 10$，$n\leq 2000$。

从小到大考虑每个数，求出能换到的点的最小编号，使得不与前面的数冲突。

考虑边 $(x,y)$ 断掉后所在连通块裂开，点 $x$ 上的数换到点 $y$ 后就再也回不来了。

考虑一个数从起点 $u_1$ 移到终点 $u_m$，依次经过 $u_m$，需要满足什么条件：

1. $u_1$ 所有临边中 $(u_1,u_2)$ 第一个被删。
2. 对于 $i\in[2,m-1]$，$u_i$ 所有临边中 $(u_i,u_{i+1})$ 在 $(u_{i-1},u_i)$ 后面第一个被删。
3. $u_m$ 所有临边中 $(u_{m-1},u_m)$ 最后一个被删。

所以对于某个点的所有临边，根据它们被删的顺序，会形成一条有始有终的偏序链。若一条边在另一条边后第一个被删，就在它们之间连一条边，冲突就是会连出环，同时若首尾连通而有些边不在偏序链中也是不合法的（最终所有边都要在偏序链中，因为每条边都要被删）。

从小到大枚举 $i$，从 $i$ 所在的点为起点开始 dfs，求出合法时终点的最小编号。

```cpp
//O2
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int t,n,x,y,id[N][N],pos[N],in[N],out[N],pre[N],mn;
vector<int>v[N];
struct F{
	int m,f[N],sz[N],pre[N],nxt[N];
	void init(){
		for(int i=0;i<=m+1;i++)
			f[i]=i,sz[i]=i>=1&&i<=m,pre[i]=nxt[i]=-1;
	}
	int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
	bool ok(int x,int y){
		if(nxt[x]==y&&pre[y]==x) return 1;
		if(~nxt[x]||~pre[y]||find(x)==find(y)) return 0;
		if(find(x)==find(0)&&find(y)==find(m+1)&&sz[find(x)]+sz[find(y)]<m) return 0;
		return 1;
	}
	void add(int x,int y){
		nxt[x]=y,pre[y]=x;
		if((x=find(x))^(y=find(y))) f[y]=x,sz[x]+=sz[y];
	}
}T[N];
void dfs(int x,int fa){
	pre[x]=fa;
	for(int y:v[x])
		if(y!=fa&&T[x].ok(id[x][fa],id[x][y])){
			if(T[y].ok(id[y][x],T[y].m+1)) mn=min(mn,y);
			dfs(y,x);
		}
}
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d",&pos[i]),v[i].clear(),T[i].m=0;
		for(int i=1;i<n;i++)
			scanf("%d%d",&x,&y),id[x][y]=++T[x].m,id[y][x]=++T[y].m,
			v[x].push_back(y),v[y].push_back(x);
		for(int i=1;i<=n;i++) T[i].init();
		if(n==1){puts("1");continue;}
		for(int i=1;i<=n;i++){
			mn=1e9,dfs(pos[i],0),printf("%d ",mn);
			T[mn].add(id[mn][pre[mn]],T[mn].m+1);
			for(int x=mn;x!=pos[i];x=pre[x])
				T[pre[x]].add(id[pre[x]][pre[pre[x]]],id[pre[x]][x]);
		}
		puts("");
	}
	return 0;
}
```

### C. 不同数字匹配

#### C1

[AGC010C] Cleaning

> 给出一棵 $n$ 个节点的无根树，第 $i$ 个点上有 $a_i$ 个石头，每次选择两个叶子，将它们路径上的所有点都取走一个石头，要求路径上所有点上都有石头。问能否取完所有石头。
>
> $2\leq n\leq 10^5$，$0\leq a_i\leq 10^9$。

先任选一个非叶子为根。

设 $f_x$ 表示 $x$ 子树内会向上延伸出多少路径。叶子 $f_x=a_x$ 是固定的。

从延伸上来的路径，有一部分会继续向上延伸，其余两两合并。发现若两条不合并，会使 $a_x$ 减 $2$，而合并了只会使 $a_x$ 减 $1$。所以已知 $f_y$，$f_x$ 是固定的。

算出 $f_x$ 后，要满足：1. $f_x\in[0,a_x]$，2. 其余路径能两两匹配完。

一个经典问题：每次匹配两个不同类型的元素，问最多匹配多少对。设类型为 $i$ 的元素有 $c_i$ 个，$sum=\sum c_i$，$c_i$ 最大的是 $c_x$，则答案为 $\min(\lfloor\frac {sum} 2\rfloor,sum-c_x)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,x,y,a[N],rt,f[N];
vector<int>v[N];
void dfs(int x,int fa){
	if(v[x].size()==1){f[x]=a[x];return ;}
	int s=0,mx=0;
	for(int y:v[x])
		if(y!=fa) dfs(y,x),s+=f[y],mx=max(mx,f[y]); 
	f[x]=2*a[x]-s;
	if(f[x]<0||f[x]>a[x]||2*min(s/2,s-mx)<s-f[x]) puts("NO"),exit(0);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		v[x].push_back(y),v[y].push_back(x);
	}
	if(n==2) puts(a[1]==a[2]?"YES":"NO"),exit(0);
	for(int i=1;i<=n;i++)
		if(v[i].size()>1){rt=i;break;}
	dfs(rt,0),puts(!f[rt]?"YES":"NO");
	return 0; 
}
```

#### C2

CF1381C Mastermind（\*2500）

> 给出值域 $[1,n+1]$ 的序列 $b_{1\sim n}$，构造一个值域 $[1,n+1]$ 的序列 $a_{1\sim n}$，使得恰好有 $x$ 个 $i$ 满足 $a_i=b_i$，且若将 $a,b$ 看作可重集，交的大小恰好为 $y$。无解输出 `NO`。
>
> $1\leq T\leq 10^3$，$1\leq n\leq 10^5$，$0\leq x\leq y\leq n$，$\sum n\leq 10^5$。

$n+1$ 的用意：构造 $a$ 中有 $y$ 个元素来自 $b$，剩下的就填 $b$ 中没有出现的元素 $emp$ 即可。

考虑一个长度为 $n$ 的序列 $t$ 重排为 $t'$，设出现次数最多的数出现了 $mx$ 次，则 $\sum_{i=1}^{n}[t_i=t'_i]$（重叠位置数）最小为 $\max(2mx-n,0)$。因为 $mx>\frac n 2$ 时会有它与它自己会重叠，否则不会，构造就是将相同的数排在一起，第 $i$ 个数挪到模意义下的后面第 $\frac n 2$ 个（假设 $n$ 是偶数）。

那么除了 $x$ 个钦定重叠的位置，其余元素重排，$b$ 与 $b'$ 重叠的元素只能是 $emp$，所以有解要满足 $\max(2mx-(n-x),0)\leq n-y$。$mx$ 越小越容易有解，所以 $x$ 个钦定的位置：每次选出现次数最多的数的某个位置。

### D. 弦图与区间图上贪心

- **弦：**连接一个环上两个不相邻点的边。

- **弦图：**一个无向图上任意一个长度 $>3$ 的简单环都有弦。

  弦图的导出子图也一定是弦图。

- **完美消除序列：**一个完美消除序列是一个无向图点的序列，每个点恰好出现一次。其中，每个点与后面与它有连边的点集形成一个团。换句话说，对于排列 $a_{1\sim n}$，在 $a_{i\sim n}$ 的导出子图中，$\{a_i\}\cup N(a_i)$ 是团。

  完美消除序列可以是不唯一的。 

  可以证明，存在完美消除序列与图是弦图等价。

- 一种特殊的弦图：区间图。

  **区间图：**每个点代表一个数轴上闭区间，两个点有边当且仅当它们代表的区间有交。容易发现，区间图的一个完美消除序列就是将它的点代表区间按右端点升序排序得到的序列（$a_{i\sim n}$ 右端点都在 $a_i$ 后面，若与 $[l_{a_i},r_{a_i}]$ 有交肯定经过了 $r_{a_i}$，$N(a_i)$ 中的点都经过了 $r_{a_i}$，它们之间都有交，所以是个团），因此它是一种弦图。

一般图上，我们有团数 $\leq$ 色数（因为团上每个点都要染不同的颜色。其中团数是最大团点数，色数是最小染色数使得相邻两点颜色不同），最大独立集 $\leq$ 最小团覆盖。但弦图是一类完美图，满足团数 = 色数，最大独立集 = 最小团覆盖，因为利用完美消除序列可以构造出取到上界的方案。

- 对于前者，按完美消除序列从后往前依次给每个点染上能染的最小颜色即可，根据完美消除序列它与它后面邻点形成团的性质，用的色数 = 团数。
- 对于后者，按完美消除序列从前往后看能否加入当前独立集，能加就加。而每将一个点加入独立集，就将它与后面的邻点加入团覆盖。设该方案的独立集数和团覆盖数为 $t$，则显然最小团覆盖 $\leq t\leq$ 最大独立集。根据最大独立集 $\leq$ 最小团覆盖可知该方案最大独立集 = 最小团覆盖。

区间贪心问题：利用了区间图的完美消除序列很好求。

#### D1

> 给出 $n$ 个区间，问最多有多少个区间两两有交。

等价于找一个点使得被覆盖次数最多。在区间图上就是问团数。

#### D2

> 给出 $n$ 个区间，问最少需要分成多少组，使得每组内区间两两无交。

发现在区间图上就是问色数：因为给每组一种颜色，每种颜色都是独立集，最少用多少独立集显然是最小色数。

#### D3

> 给出 $n$ 个区间，选出最多的不相交区间。

区间图的最大独立集。

#### D4

> 给出 $n$ 个区间，划分为最少的组，使得每组内区间两两有交。

区间图的最小团覆盖。

### E. 凸函数卷积

#### E1

硬币游戏

> 有 $n$ 堆硬币，每堆恰好有 $3$ 个，且最上面和最下面的价值相等，即每堆硬币价值从上往下形如 $(a_i,b_i,a_i)$。对于每堆硬币，只能从上往下取。
>
> 对 $\forall k\in[1,3n]$，求取出 $k$ 枚硬币的最大价值和。
>
> $n\leq 5\times 10^6$，$a_i,b_i\leq 10^7$。

四种情况 $0,a_i,a_i+b_i,2a_i+b_i$，相当于有一个体积为 $1$、价值 $a_i$ 的物品，和一个体积为 $2$、价值 $a_i+b_i$ 的物品。问题转化为，有 $n$ 个体积为 $1$ 的物品，和 $n$ 个体积为 $2$ 的物品，取出体积和为 $k$ 的一些物品，最大化价值，这样就去掉“只能从上往下取”的限制了。

考虑对 $k$ 是奇数和 $k$ 是偶数分别算。若 $k$ 是偶数，体积为 $1$ 的会取偶数个，将体积为 $1$ 的价值第 $1,2$ 大、第 $3,4$ 大、第 $5,6$ 大...合并成体积为 $2$ 的，此时体积都是 $2$ 就可以按价值从大到小排序算了。若 $k$ 是奇数肯定会选体积为 $1$ 的价值最大的，其余同理。

#### E2

ZR#1350. 【20省选集训day3】划分

> 给出 $a_{1\sim n}$，对 $\forall k\in[1,n]$，求将 $a_{1\sim n}$ 划分为非空的 $k$ 个组（是子集，即不要求连续），每个组中数字 $\gcd$ 之和的最大值。
>
> $n\leq 5\times 10^5$，$1\leq a_i\leq 10^{12}$。

先考虑 $a_i$ 互不相同的情况。找性质：

1. 至多只有一个大小 $>1$ 的组。

   证明：若有两个组 $S_1,S_2$ 大小 $>1$，设 $a=\max S_1,b=S_1\backslash\{a\}$，$c=\max S_2,d=S_2\backslash\{c\}$，且 $a\geq c$。那么将 $b$ 丢进 $d$ 一定更优，因为数互不相同，所以原先 $\gcd(a,b)+\gcd(c,d)\leq \frac a 2+\frac c 2\leq a$，调整后 $a+\gcd(c,d,b)\geq a+1$。

2. 进一步，将所有数从大到小排序，前 $k$ 个数所属的组互不相同。换句话说，前 $k$ 个数先自己一个组，然后后面的数会一起插入到这 $k$ 组中的某个中。

   证明：若前 $k$ 个数中的 $a,b$ 分在一组，后面有一个数 $c$，根据 1 其余组大小为 $1$，$c$ 会自己一组。那么将 $b$ 丢到 $c$ 的组一定更优，因为 $a>b>c$，设 $g=\gcd(a,b),a=a'd,b=b'd$，原先 $g+c<g+b=g(1+b')\leq ga'=a$，调整后 $a+\gcd(b,c)\geq a+1$。

因此，设前 $k$ 大为 $b_{1\sim k}$，其余数的 $\gcd$ 是 $g$，则 $ans_k=\max_i\{\gcd(b_i,g)+\sum_{j\neq i}b_j\}$。注意到 $g$ 只会变化 $\mathcal O(\log V)$ 次，每段分别做，可以 $\mathcal O(n\log V)$ 求出所有 $ans_k$。

现在，存在 $a_i$ 相同：

- 先将每种 $a_i$ 拎出来其中一个，按 $a_i$ 互不相同做。注意到，多出来相同的 $a_i$，要么和拎出来的那个 $a_i$ 在同一组，要么单独成为一个大小为 $1$ 的组。

  设每种 $a_i$ 拎出来一个得到的是 $c_{1\sim t}$，用它算出来得到 $ans_k$；其余多出来相同的 $a_i$ 是 $d_{1\sim p}$，$d_{1\sim p}$ 的前 $j$ 大是 $sum_j$。则 $ans_k'=\max_{i+j=k}\{ans_i+sum_j\}$，表示 $d_{1\sim p}$ 的前 $j$ 大单独成组。

  注意到 $sum$ 是凸的，决策单调性即可。

  进一步，发现相同段的 $ans$ 是凸的，每段分别闵可夫斯基和也可以。

```cpp
#include <bits/stdc++.h>
#define gcd std::__gcd
using std::cin;
using std::cout;

typedef long long ll;
const int N = 500054;

int n, n_same = 0;
int seg[N];
ll a[N], A[N], pre[N], co[N];
ll v_gcd[N], v_same[N];
ll sum = 0, ans[N];

inline void down(ll &x, const ll y) {x > y ? x = y : 0;}

void construct(ll g, int begin) {
	int i;
	for (i = begin; i < n; ++i) co[i] = a[i] - gcd(g, a[i]);
	for (i = n - 1; i > begin; --i) down(co[i - 1], co[i]);
}

void convex_convolution(int L, int R) { // [L, R)
	int i, j, m = 0; ll cur = v_gcd[L];
	static ll g[N];
	for (i = L + 1; i < R; ++i) g[m++] = v_gcd[i] - v_gcd[i - 1];
	assert(std::is_sorted(g, g + m));
	memcpy(g + m, v_same, n_same << 3);
	std::inplace_merge(g, g + m, g + (m + n_same)), m += n_same;
	for (i = 0, j = L; i <= m; ++i, ++j) down(ans[j], cur), cur += g[i];
}

int main() {
	int i, j, c = 1, real_n;
	std::ios::sync_with_stdio(false), cin.tie(NULL);
	cin >> real_n;
	for (i = 0; i < real_n; ++i) cin >> a[i], sum += a[i];
	std::sort(a, a + real_n);
	for (n = i = 1; i < real_n; ++i) (a[i] == a[i - 1] ? v_same[n_same++] : a[n++]) = a[i];
	assert(n + n_same == real_n);
	for (i = 0; i < n; ++i) A[i + 1] = A[i] + a[i], pre[i + 1] = gcd(pre[i], a[i]);
	for (i = 1, j = 0; i < n; ++i) {
		if (pre[i] != pre[i - 1]) construct(pre[i], seg[c++] = i);
		v_gcd[i] = A[i] + co[i];
	}
	seg[c] = n, memset(ans, 63, real_n << 3);
	for (i = 0; i < c; ++i) convex_convolution(seg[i], seg[i + 1]);
	for (i = real_n - 1; i >= 0; --i) cout << sum - ans[i] << '\n';
	return 0;
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 5e5;
const ll inf = 1e18;
int n, m, k;
ll a[maxn + 3], b[maxn + 3], c[maxn + 3], d[maxn + 3], g[maxn + 3], res[maxn + 3];

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	sort(a + 1, a + n + 1);
	reverse(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++) {
		if (a[i] == a[i - 1]) b[++m] = a[i];
		else c[++k] = a[i];
	}
	for (int i = 1; i <= m; i++) b[i] += b[i - 1];
	fill(res + 1, res + n + 1, -inf);
	g[k + 1] = -1;
	for (int i = k - 1; i >= 1; i--) g[i] = gcd(g[i + 1], c[i + 1]);
	for (int i = 1, l = 1; i <= k; i++) {
		if (g[i] == g[i + 1]) continue;
		ll x = g[i], mx = -inf, sum = 0;
		for (int j = 1; j < l; j++) mx = max(mx, gcd(c[j], x) - c[j]), sum += c[j];
		for (int j = l; j <= i; j++) {
			mx = max(mx, gcd(c[j], x) - c[j]), sum += c[j], d[j] = sum + mx;
			if (j >= l + 2) assert(d[j - 1] * 2 >= d[j - 2] + d[j]);
		}
		for (int j = l; j < i; j++) assert(g[j] == g[j + 1]);
		int p = 0, q = l;
		res[l] = max(res[l], d[l]);
		while (p < m || q < i) {
			if (q == i || (p < m && b[p + 1] - b[p] >= d[q + 1] - d[q])) p++;
			else q++;
			res[p + q] = max(res[p + q], b[p] + d[q]);
		}
		l = i + 1;
	}
	for (int i = 1; i <= n; i++) printf("%lld\n", res[i]);
	return 0;
}
```