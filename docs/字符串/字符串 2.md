### Trie

#### A2

Gym102331B Bitwise Xor（300iq Contest2），类似的题有 P10200 [湖北省选模拟 2024] 花神诞日 / sabzeruz

> 给出一个长度为 $n$ 的序列和一个数 $x$，求有多少非空子序列，使得其中任意两个数异或都 $\geq x$。对 $998244353$ 取模。
>
> $1\leq n\leq 3\times 10^5$，$0\leq x,a_i\leq 2^{60}-1$。

考虑给出一个子序列怎么判断。求出任意两个异或的最小值，判断是否 $\geq x$。把子序列塞进 Trie 树，从根节点开始走，为了让两个数异或起来尽量小，我们肯定是希望两个数每次都在同个子树里，所以走到子树继续搜，直到子树 size 只有 $2$，只能选这两个数。

根据 Trie 树的构建，把子序列从小到大排序，那么这两个数只能是子序列中相邻的两个数。所以一个子序列合法，等价于任意相邻的两项异或都 $\geq x$。

（技巧：一个序列两两异或的最小值，一定是这个序列从小到大排序后相邻两项异或的最小值）

因此，将 $a$ 排序后，设 $f_i$ 表示以 $i$ 结尾的合法子序列个数，转移枚举 $a_i\oplus a_j\geq x$ 的 $j$，从 $f_j$ 转移。可以用 Trie 树优化。

时间复杂度 $\mathcal O(n\log n+n\log V)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e5+5,M=N*60,mod=998244353;
int n,tot=1,ch[M][2],sum[M],ans;
ll m,a[N],f[N];
void insert(ll x,ll v){
	for(int i=60,p=1;i>=0;i--){
		int k=x>>i&1;
		if(!ch[p][k]) ch[p][k]=++tot;
		p=ch[p][k],sum[p]=(sum[p]+v)%mod; 
	}
}
int query(ll x){
	int ans=0,p=1;
	for(int i=60;i>=0;i--){
		int k=x>>i&1;
		if(m>>i&1) p=ch[p][k^1];
		else ans=(ans+sum[ch[p][k^1]])%mod,p=ch[p][k];
	}
	return (ans+sum[p])%mod;	//!!!
}
signed main(){
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		f[i]=query(a[i])+1,insert(a[i],f[i]),ans=(ans+f[i])%mod;
	printf("%d\n",ans);
	return 0;		
}
```

#### A3

XOR

> 给出两个序列 $a_{1\sim n},b_{1\sim n}$，找到 $x$ 最小化 $\sum_{i=1}^n|a_i-(b_i\oplus x)|$，并求出符合条件的 $x$ 的个数。
>
> $n\leq 4\times 10^4$，$a_i,b_i\leq 10^{14}$。

类似 ARC127D，比较 $a_i$ 和 $b_i\oplus x$ 的大小关系，**只需比较它们异或起来最高位的 $1$**。$a_i\oplus(b_i\oplus x)=(a_i\oplus b_i)\oplus x$，设 $c_i=a_i\oplus b_i$，把 $c_i$ 塞进 Trie。

从高到低考虑，若 $x$ 这位是 $0$，那么对于 $c_i$ 这位是 $1$ 的那些 $i$，$a_i$ 和 $b_i\oplus x$ 的大小关系就确定了，贡献也就好算了。具体地，对于更低位，每位存一下 $x$ 这位取 $0/1$ 分别有多少贡献。子树直接爆搜。$x$ 这位是 $1$ 同理。

由于每个点深度是 $\log V$ 的，所以每个数只会被爆搜 $\log V$ 次。

时间复杂度 $\mathcal O(n\log^2 V)$。

#### A4

AGC044C Strange Dance

> 有 $3^n$ 个人，分别在位置 $0\sim 3^n-1$。给出操作序列 $T$：
>
> - `S`：把每个人的位置 $i$ 用三进制写出来，每位 $1$ 变成 $2$、$2$ 变成 $1$，得到新的位置。
> - `R`：将每个人的位置循环右移 $1$。
>
> 问操作完每个人的位置。
>
> $1\leq n\leq 12$，$1\leq |t|\leq 2\times 10^5$。

Trie 树经典操作：全局 $+1$。

由于加法从低位进到高位，所以从低位到高位建 Trie，每个点三个儿子表示下一个数位是 $0,1,2$：

- `S`：交换所有点的 $1,2$ 儿子。可以打标记。
- `R`：相当于 $+1$ 取模。先考虑最低位，$0\to 1,1\to 2,2\to 0$，并且要进位。所以直接交换根节点的子树，然后再往 $0$ 子树搜下去继续修改即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n,m,pw[N],ch[N][3],tot=1,tg[N],id[N],ans[N];
char s[N];
void upd(int p){tg[p]^=1,swap(ch[p][1],ch[p][2]);}
void down(int p){
	if(tg[p]) upd(ch[p][0]),upd(ch[p][1]),upd(ch[p][2]),tg[p]=0;
}
void insert(int v){
	int p=1,x=v,k;
	for(int i=1;i<=n;i++){
		if(!ch[p][k=x%3]) ch[p][k]=++tot;
		p=ch[p][k],x/=3;
	}
	id[p]=v;
}
void dfs(int x,int d,int cur){
	if(d==n){ans[id[x]]=cur;return ;}
	down(x);
	for(int i=0;i<3;i++) dfs(ch[x][i],d+1,cur+i*pw[d]);
}
signed main(){
	scanf("%d%s",&n,s+1),m=strlen(s+1),pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=pw[i-1]*3;
	for(int i=0;i<pw[n];i++) insert(i);
	for(int i=1;i<=m;i++){
		if(s[i]=='S') upd(1);
		else{
			for(int i=1,x=1;i<=n;i++){
				down(x);
				int t[3]={ch[x][0],ch[x][1],ch[x][2]};
				ch[x][0]=t[2],ch[x][1]=t[0],ch[x][2]=t[1],x=ch[x][0];
			}
		}
	}
	dfs(1,0,0);
	for(int i=0;i<pw[n];i++) printf("%d ",ans[i]);
	return 0; 
}
```

#### A5

CF888G Xor-MST（\*2300）

> 有一个 $n$ 个点的无向完全图 $G$，每个点有权值 $a_i$，边 $(i,j)$ 的边权为 $a_i\oplus a_j$。求 $G$ 的最小生成树。
>
> $1\leq n\leq 2\times 10^5$，$0\leq a_i<2^{30}$。

这种“任意两点都有连边，边权可以用比较简单的函数计算”的 MST 都可以用 Boruvka 解决。

考虑 Boruvka 进行到某一轮，所有点已经分成若干集合，要求每个点连到不同集合的最小的边。每次走到 Trie 树上一个点，看是否存在“不在某个集合中”的点。

Trie 树上每个点维护一个 pair，表示任意两种子树内出现过的集合种类。

### Manacher

> 求以每个位置为中心的最长回文串长度。

能对称就对称，否则暴力扩展。

注意考虑长度为偶的回文串！

```cpp
n=strlen(s+1),t[0]='@';
for(int i=1;i<=n;i++) t[++len]='#',t[++len]=s[i];
t[++len]='#',t[len+1]='\0';
for(int i=1;i<=len;i++){
	if(i<=r) p[i]=min(p[2*mid-i],r-i+1);
	while(t[i-p[i]]==t[i+p[i]]) p[i]++;
	if(i+p[i]-1>r) r=i+p[i]-1,mid=i;
}
for(int i=1;i<=len;i++) ans=max(ans,p[i]-1);
```

#### B1

回文串

> 给出一个长度为 $n$ 的字符串 $s$，$q$ 次询问区间 $[l,r]$ 的回文子串个数（不要求本质不同）。
>
> $n,q\leq 5\times 10^5$。

先 Manacher 求出以每个点为中心的最长回文半径 $p_i$。

对于一个询问 $[l,r]$，记 $mid=\lfloor\frac{l+r}{2}\rfloor$，类似 P7125：

- 若回文串中心在 $[l,mid]$，那么只需考虑回文串左端点 $\geq l$ 的限制，不需要考虑右端点：$l\leq i-p_i+1$。
- 若回文串中心在 $[mid+1,r]$，只需考虑右端点 $\leq r$ 的限制，不需要考虑左端点：$i+p_i-1\leq r$。

每种情况都是一个二维偏序。可以将询问按 $mid$ 排序，扫描线 $mid$，用两个树状数组维护，分别用 $l,r$ 询问。

形如 $[x-i,x+i]$ 合法，问 $[l,r]$ 有多少合法区间的问题都可以这样解决。

时间复杂度 $\mathcal O((n+m)\log n)$。

### 回文自动机（回文树）

有两个根节点，长度分别为 $0,-1$，分别维护长度为偶数/奇数的回文串。

每个节点 $x$ 有：

- 转移 $ch_{x,c}$，表示 $x$ 代表字符串两端各加上字符 $c$ 形成的回文串。
- $fail_x$，表示 $x$ 的最长回文后缀（没有就默认跳到 $0$）。

所有状态都是接受状态，代表了一个原串中的回文串。增量法构建，在原串后面加一个字符 $c$：通过跳 $fail$ 找到原串的最长回文后缀，使得这个回文后缀的前一个字符为 $c$。

PAM 告诉我们一个串的本质不同回文串只有 $\mathcal O(n)$ 个。

#### C1

> 两侧同时插入。

因为回文，所以自动机中串的最长回文前缀同时也是最长回文后缀。两端都维护 $lst$ 即可。注意当插入后整个串变成回文串时也要更新另一端的 $lst$。

这告诉我们 PAM 两端都能插入。

#### C2

LOJ#6070. 「2017 山东一轮集训 Day4」基因

> 多次询问区间本质不同回文子串个数。
>
> $n\leq 10^5$，$q\leq 2\times 10^5$，强制在线。

从左到右扫描线 $r$，线段树第 $l$ 个位置维护 $[l,r]$ 的答案（改成主席树就能强制在线了）。

设当前 $r$ 扫到了 $i$，那么 PAM 上 $lst(i)$ 的祖先代表的串都新出现了一次。对于 $lst(i)$ 到根链上的某个点 $x$，它的影响是：

- 找到它所代表的串上一次出现的右端点 $j$，线段树上 $[j-len_x+2,i-len_x+1]$ 都要 $+1$。

- 怎么找这个 $j$？在 $r$ 从 $1$ 扫到 $i$ 的过程中，每次 $lst(r)$ 的祖先对应的 $j$ 会更新为 $r$。

  维护：相当于每次在 $lst(r)$ 处打一个 $r$ 的标记。$x$ 对应的 $j$ 就是 $x$ 子树内标记的最大值。开另一棵线段树，以 dfs 序为下标，支持单点修改，区间求 $\max$ 即可。

考虑优化。

一个重要性质：以 $i$ 结尾的回文串长度可以分为 $\log$ 段等差数列。

然后考虑以 $i$ 结尾的一个最短为 $L$、最长为 $R$、公差为 $d$ 的等差数列，发现以 $i-d$ 结尾一定出现了其中长度为 $L,L+d,L+2d,\cdots,R-d$ 的回文串（将 $R-d$ 通过 $R$ 对称可以得到以 $i-d$ 结尾的 $R-d$，将 $R-2d$ 通过 $R-d$ 对称可以得到以 $i-d$ 结尾的 $R-2d$，以此类推）。

<img src="https://img2024.cnblogs.com/blog/1859218/202404/1859218-20240417183912142-331805269.png" style="zoom:40%;" />

根据 border 那套理论，$d$ 是 $L+d,\cdots,R$ 的最短周期，所以可以证明 $L,L+d,L+2d,\cdots,R-d$ 上一次出现的右端点一定是 $i-d$。

设串 $R$ 上一次出现的右端点是 $pos$，发现 $l\in(pos-R+1,i-R+1]$ 时会多且仅多出现串 $R$，$l\in(i-R+1,i-(R-d)+1]$ 时会多且仅多出现 $R-d$，$l\in(i-(R-d)+1,i-(R-2d)]$ 时会多且仅多出现 $R-2d$，依次类推……发现这个等差数列的贡献就是线段树上 $(pos-R+1,i-L+1]$ 都 $+1$。

时间复杂度 $\mathcal O(n\log^2 n+q\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=N<<7;	//!!! <<7 not <<6
int op,n,q,l,r,tot=1,lst,len[N],fa[N],ch[N][27],dif[N],top[N],id[N],rt[N],tim,dfn[N],ed[N],mx[N<<2],ans;
char s[N];
vector<int>v[N];
int get(int p,int i){
	while(s[i-1-len[p]]!=s[i]) p=fa[p];
	return p;
}
void insert(int i,int c){
	int p=get(lst,i);
	if(!ch[p][c])
		len[++tot]=len[p]+2,fa[tot]=ch[get(fa[p],i)][c],ch[p][c]=tot,
		dif[tot]=len[tot]-len[fa[tot]],
		top[tot]=dif[tot]==dif[fa[tot]]?top[fa[tot]]:tot;
	lst=ch[p][c];
}
namespace res{
	int tot,tg[M],lc[M],rc[M];
	int modify(int p,int l,int r,int lx,int rx){
		int x=++tot,mid=(l+r)/2;
		tg[x]=tg[p],lc[x]=lc[p],rc[x]=rc[p];
		if(l>=lx&&r<=rx) return tg[x]++,x;
		if(lx<=mid) lc[x]=modify(lc[p],l,mid,lx,rx);
		if(rx>mid) rc[x]=modify(rc[p],mid+1,r,lx,rx);
		return x;
	}
	int query(int p,int l,int r,int pos){
		if(l==r) return tg[p];
		int mid=(l+r)/2,ans=tg[p];
		if(pos<=mid) ans+=query(lc[p],l,mid,pos);
		else ans+=query(rc[p],mid+1,r,pos);
		return ans;
	}
}
void dfs(int x){
	dfn[x]=++tim;
	for(int y:v[x]) dfs(y);
	ed[x]=tim;
}
void modify(int p,int l,int r,int pos,int v){
	mx[p]=max(mx[p],v);
	if(l==r) return ;
	int mid=(l+r)/2;
	if(pos<=mid) modify(p<<1,l,mid,pos,v);
	else modify(p<<1|1,mid+1,r,pos,v);
}
int query(int p,int l,int r,int lx,int rx){
	if(l>=lx&&r<=rx) return mx[p];
	int mid=(l+r)/2,ans=0;
	if(lx<=mid) ans=query(p<<1,l,mid,lx,rx);
	if(rx>mid) ans=max(ans,query(p<<1|1,mid+1,r,lx,rx));
	return ans;
}
signed main(){
	scanf("%d%d%d%s",&op,&n,&q,s+1),len[1]=-1,fa[0]=1;
	for(int i=1;i<=n;i++)
		insert(i,s[i]-'a'),id[i]=lst;
	for(int i=0;i<=tot;i++)
		if(i!=1) v[fa[i]].push_back(i);
	dfs(1);
	for(int i=1;i<=n;i++){
		rt[i]=rt[i-1];
		for(int x=id[i];x;x=fa[top[x]]){
			int pos=query(1,1,tim,dfn[x],ed[x]);
			rt[i]=res::modify(rt[i],1,n,max(1,pos-len[x]+2),i-len[top[x]]+1);
		}
		modify(1,1,tim,dfn[id[i]],i);
	}
	while(q--){
		scanf("%d%d",&l,&r),l^=op*ans,r^=op*ans;
		printf("%d\n",ans=res::query(rt[r],1,n,l));
	}
	return 0;
}
```

### 扩展 KMP

给出 $s,t$，对 $s$ 的每个后缀求出与 $t$ 的最长公共前缀。

先考虑对 $s$ 的每个后缀 $i$ 求出 $z_i$，表示这个后缀与 $s$ 本身的最长公共前缀。类似 Manacher，先继承，后暴力。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220804140129713-2046756132.png" alt="image" style="zoom:67%;" />

每暴力扩展一次就意味着 $r$ 增大 $1$。复杂度均摊 $\mathcal O(n)$。

```cpp
void getz(char* s){
	int n=strlen(s+1),l=0,r=0;
	fill(z+1,z+1+n,0),z[1]=n;
	for(int i=2;i<=n;i++){
		if(i<=r) z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n&&s[i+z[i]]==s[1+z[i]]) z[i]++;
		if(i+z[i]-1>r) l=i,r=i+z[i]-1;
	}
}
```

那么对 $t$ 求出 $z$，还是类似地做即可。

<img src="https://img2022.cnblogs.com/blog/1859218/202208/1859218-20220804141544334-693742916.png" alt="image" style="zoom:67%;" />

```cpp
void exkmp(char* s,char* t){
	int n=strlen(s+1),l=0,r=0;
	getz(t),fill(p+1,p+1+n,0);
	for(int i=1;i<=n;i++){
		if(i<=r) p[i]=min(z[i-l+1],r-i+1);
		while(i+p[i]<=n&&s[i+p[i]]==t[1+p[i]]) p[i]++;
		if(i+p[i]-1>r) l=i,r=i+p[i]-1;
	}
}
```

### AC 自动机

#### [鸽] D1

BZOJ 4231 回忆树

> 给出一棵 $n$ 个节点的树，每条边上有一个字符。
>
> $m$ 次询问，每次给出 $x,y,s$，问 $x\to y$ 的路径上字符串 $s$ 出现了几次。
>
> $n,m\leq 10^5$，$\sum |s|\leq 3\times 10^5$。

#### D2

练习题

> 给出一个字符串 $s$。多次询问，每次给出一个询问串 $t$，问 $t$ 在 $s$ 中出现了多少次，这里的出现可以有至多一个字符不同。
>
> $|s|,\sum |t|\leq 10^5$。

对所有 $t$ 的正串和反串分别建立一个 AC 自动机。

枚举 $t$ 的第 $i$ 位可以不同。假设把 $i$ 放在 $s$ 里的第 $j$ 位可以匹配上。那么：

- $t[1:i-1]$ 是 $s[1:j-1]$ 的后缀，$s[1:j-1]$ 的对应点在 $t[1:i-1]$ 的 $fail$ 树子树内。
- $t[i+1:|t|]$ 的反串是 $s[j+1:n]$ 反串的后缀，同理。

两个 DFS 序，$s$ 中每个 $j$ 对应 $(dfn_1(id_1(j-1)),dfn_2(id_2(j+1)))$，$j$ 代表的点在矩形 $[in_1(tid_1(i-1)),out_1(tid_1(i-1))][in_2(tid_2(i+1)),out_2(tid_2(i+1))]$ 内，二维数点即可。

二维数点的总次数是 $\sum |t|$。

这样恰好一位不同时计算是正确的，若完全相同会计算 $|t|$ 次，所以要特判一下减掉。

#### D3

BZOJ 4502 串

> 给出一个字符串集合，求有多少个串（任意）使得这个串可以被断成两部分，每部分都是字符串集合中某个串的前缀。
>
> 串长和 $\leq 10^6$。

建出 trie 树，设初始答案为节点个数的平方，然后再去重。

考虑重复的字符串，**在右边字符串最短时计算**，即右边的字符串不能再剪一段移到左边。这样每个串只会被算一次。我们要减掉那些，右边字符串能剪一段给左边的。

枚举右边的串，设在 trie 树中对应节点为 $x$，那么它的最长后缀对应节点为 $fail_x$。如果右边剪成 $fail_x$，把多的给左边，左边不在 trie 树里，那么右边剪的更短，左边也不在。所以只要判断右边能否剪成 $fail_x$。

考虑 $x$ 剪掉 $fail_x$ 剩下的那段，就是 trie 树上 $x$ 往上跳 $len(fail_x)$ 步得到的点，设为 $y$。那么若左边的串接上 $y$  **存在，则左边的串接上 $y$ 后在 $y$ 的 $fail$ 树子树内**，所以只要减掉 $sz_y-1$ 即可（$-1$：左边的串非空）。

倍增即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,tot=1,ch[N][27],tmp[N][27],sz[N],f[N][25],fail[N],len[N];
long long ans;
char s[N];
vector<int>v[N];
void insert(char* s){
	int n=strlen(s+1),p=1,k;
	for(int i=1;i<=n;i++){
		if(!ch[p][k=s[i]-'a']) ch[p][k]=++tot;
		p=ch[p][k];
	}
}
void getfail(){
	queue<int>q;
	for(int i=0;i<26;i++) ch[0][i]=1;
	q.push(1),fail[1]=0;
	while(q.size()){
		int x=q.front(),y;q.pop();
		for(int i=0;i<26;i++){
			if((y=ch[x][i])) fail[y]=ch[fail[x]][i],q.push(y);
			else ch[x][i]=ch[fail[x]][i];
		}
	}
}
void dfs(int x){	//子树大小是在 fail 树上
	sz[x]=1;
	for(int y:v[x]) dfs(y),sz[x]+=sz[y];
}
void dfs2(int x){	//倍增是在 trie 树上
	for(int i=0;i<=19;i++) f[x][i+1]=f[f[x][i]][i];
	for(int i=0,y;i<26;i++)
		if((y=tmp[x][i])) len[y]=len[x]+1,f[y][0]=x,dfs2(y);
}
int jump(int x,int k){
	for(int i=20;i>=0;i--) if(k>>i&1) x=f[x][i];
	return x;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%s",s+1),insert(s);
	memcpy(tmp,ch,sizeof(ch)),getfail(),ans=1ll*(tot-1)*(tot-1);	//由于第一个点是空节点，所以这里是 tot-1
	for(int i=2;i<=tot;i++) v[fail[i]].push_back(i);
	dfs(1),dfs2(1);
	for(int i=1;i<=tot;i++)
		if(len[fail[i]]) ans-=sz[jump(i,len[fail[i]])]-1;
	printf("%lld\n",ans);
	return 0;
}
```

#### [鸽] D4

#### [鸽] D5

#### 一个技巧

P1117 [NOI2016] 优秀的拆分


### 后缀数组

### 后缀自动机

### 广义 SAM

