
???+ abstract "情况分析"
	
	??? info "原话"
		J 100+100+100+100
		
	    S 100+8+10+8
	    
	    J组两个小时AK
	    
	    S组一小时过T1，然后想了半个小时的T2，然后写了一个小时的假做法，写完一看假了，全删了去看T3，写了半个小时T3，大样例RE没管，有写了半个小时T2 16分，然后10分钟把T4暴力打了，最后又在最后十分钟想出2^n\*n\*n的状压做法，没敢写，最后十分钟看了眼freopen就走了
	    
	    整体失误集中在T2，磕太久了，否则能多T4的8分，T3的20到40分，T2最小生成树还写错了，又挂了24分
	
	分数：$100+8+10+8$。
	
	- T1：1h
	
	- T2：想 0.5h，写 1h 假算（写完发现假了，全删了。心态崩？），转 t3，然后写完 t3 写 0.5h T2 16 分。MST 写错挂 24 分。
	
	- T3：写 0.5h 暴力（大样例 RE 没管？）。若 T2 未磕太久，能多 20~40 分
	
	- T4：写 10min 暴力。若 T2 未磕太久，能多 8 分
	
	最后十分钟想出 $2^nn^2$ 的状压做法，没敢写？
	
	整体失误集中在 T2。

## T2

没有拿到 $56$ 以上的暴力分要好好反思一下。

事实上 $[80,100]$ 也不是很难。或许对 MST 的性质缺乏了解。

- $\mathcal O(2^k)$ 枚举改造的乡镇，每次 $\mathcal O((m+nk)\log (m+nk))$ 对新图暴力 MST。
	
	??? note "32 分"
		```cpp
		#include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5,K=20;
        int n,m,k,f[N],c[K],w[K][N];
        long long sum,ans=1e18;
        struct E{
            int x,y,z;
        }e[M],a[M+N*K];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]);
                for(int j=1;j<=n;j++) scanf("%d",&w[i][j]);
            }
            for(int s=0;s<(1<<k);s++){
                int cnt=m;
                copy(e+1,e+1+m,a+1);
                iota(f+1,f+1+n+k,1),sum=0;
                for(int i=1;i<=k;i++) if(s>>(i-1)&1){
                    sum+=c[i];
                    for(int j=1;j<=n;j++) a[++cnt]={n+i,j,w[i][j]};
                }
                sort(a+1,a+1+cnt,[](E x,E y){return x.z<y.z;});
                for(int i=1;i<=cnt;i++){
                    int x=find(a[i].x),y=find(a[i].y);
                    if(x!=y) f[y]=x,sum+=a[i].z;
                }
                ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
  
      ```
	
	      ```
	
- 特殊性质 A：所有乡镇都改造，跑 MST。

	??? note "56 分（特殊性质 A 拼上 32 分暴力）"
		```cpp
		#include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5,K=20;
        int n,m,k,f[N],c[K],w[K][N];
        long long sum,ans=1e18;
        struct E{
            int x,y,z;
        }e[M],a[M+N*K];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            bool flg=1; 
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]),flg&=!c[i];
                for(int j=1;j<=n;j++) scanf("%d",&w[i][j]);
            }
            for(int s=flg?(1<<k)-1:0;s<(1<<k);s++){
                int cnt=m;
                copy(e+1,e+1+m,a+1);
                iota(f+1,f+1+n+k,1),sum=0;
                for(int i=1;i<=k;i++) if(s>>(i-1)&1){
                    sum+=c[i];
                    for(int j=1;j<=n;j++) a[++cnt]={n+i,j,w[i][j]};
                }
                sort(a+1,a+1+cnt,[](E x,E y){return x.z<y.z;});
                for(int i=1;i<=cnt;i++){
                    int x=find(a[i].x),y=find(a[i].y);
                    if(x!=y) f[y]=x,sum+=a[i].z;
                }
                ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
        ```

- 先 $\mathcal O(m\log m)$ 对原图跑一遍 MST，不属于原图 MST 的边必然也不属于新图 MST。这样原图的 $m$ 条边只需保留 $n-1$ 条。

	然后 $\mathcal O(2^k)$ 枚举改造的乡镇，每次 $\mathcal O(nk\log nk)$ 对新图暴力 MST。
	
	??? note "80 分"
		```cpp
		#include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5,K=20;
        int n,m,k,t,f[N],c[K],w[K][N];
        long long sum,ans=1e18;
        struct E{
            int x,y,z;
        }e[M],a[M];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
            iota(f+1,f+1+n,1);
            for(int i=1;i<=m;i++){
                int x=find(e[i].x),y=find(e[i].y);
                if(x!=y) f[y]=x,e[++t]=e[i];
            }
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]);
                for(int j=1;j<=n;j++) scanf("%d",&w[i][j]);
            }
            sort(e+1,e+1+t,[](E x,E y){return x.z<y.z;});
            for(int s=0;s<(1<<k);s++){
                int cnt=t;
                copy(e+1,e+1+t,a+1);
                iota(f+1,f+1+n+k,1),sum=0;
                for(int i=1;i<=k;i++) if(s>>(i-1)&1){
                    sum+=c[i];
                    for(int j=1;j<=n;j++) a[++cnt]={n+i,j,w[i][j]};
                }
                sort(a+1,a+1+cnt,[](E x,E y){return x.z<y.z;});
                for(int i=1;i<=cnt;i++){
                    int x=find(a[i].x),y=find(a[i].y);
                    if(x!=y) f[y]=x,sum+=a[i].z;
                }
                ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
        ```

- 改进重复的排序。

	??? note "100 分"
  		```cpp
        #include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5;
        int n,m,k,t,f[N],c[20];
        long long sum,ans=1e18;
        struct E{
            int x,y,z;
        }e[M];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
            iota(f+1,f+1+n,1);
            for(int i=1;i<=m;i++){
                int x=find(e[i].x),y=find(e[i].y);
                if(x!=y) f[y]=x,e[++t]=e[i];
            }
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]);
                for(int j=1,x;j<=n;j++)
                    scanf("%d",&x),e[++t]={i+n,j,x};
            }
            sort(e+1,e+1+t,[](E x,E y){return x.z<y.z;});
            for(int s=0;s<(1<<k);s++){
                iota(f+1,f+1+n+k,1),sum=0;
                for(int i=1;i<=k;i++)
                    if(s>>(i-1)&1) sum+=c[i];
                for(int i=1;i<=t;i++){
                    if(e[i].x>n&&!(s>>(e[i].x-n-1)&1)) continue;
                    int x=find(e[i].x),y=find(e[i].y);
                    if(x!=y) f[y]=x,sum+=e[i].z;
                }
                ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
        ```

- 事实上 $\mathcal O(2^knk\log)$ 或 $\mathcal O(2^k nk\alpha)$ 的部分可以进一步优化成 $\mathcal O(2^kn\log)$ 或 $\mathcal O(2^k n\alpha)$。

	设改造 $S$ 中的城镇。对每个 $S$，记录 $S$ 对应新图的 MST 的边 $\text{MST}(S)$。
	
	$\text{MST}(S)$ 可以由【$\text{MST}(S-\text{lowbit}(S))$ 的 $\mathcal O(n)$ 条边】和【$\text{lowbit}(S)$ 这个城镇连出去的 $n$ 条边】排序/归并得到。
	
	??? note "100 分（直接排序）"
		```cpp
        #include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5,K=20,S=1<<10;
        int n,m,k,t,f[N],c[K],w[K][N],num[S];
        long long sum,ans;
        struct E{
            int x,y,z;
        }e[M],b[N<<1],a[S][N];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
            iota(f+1,f+1+n,1);
            for(int i=1;i<=m;i++){
                int x=find(e[i].x),y=find(e[i].y);
                if(x!=y) f[y]=x,a[0][++t]=e[i],sum+=e[i].z;
            }
            num[0]=t,ans=sum;
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]);
                for(int j=1;j<=n;j++) scanf("%d",&w[i][j]);
            }
            for(int s=1;s<(1<<k);s++){
                int x=__lg(s&(-s))+1,s1=s^(s&(-s)),cnt=num[s1];
                copy(a[s1]+1,a[s1]+1+cnt,b+1);
                for(int i=1;i<=n;i++) b[++cnt]={x+n,i,w[x][i]};
                sort(b+1,b+1+cnt,[](E x,E y){return x.z<y.z;});
                iota(f+1,f+1+n+k,1),sum=0;
                for(int i=1;i<=k;i++)
                    if(s>>(i-1)&1) sum+=c[i];
                t=0;
                for(int i=1;i<=cnt;i++){
                    int x=find(b[i].x),y=find(b[i].y);
                    if(x!=y) f[y]=x,sum+=b[i].z,a[s][++t]=b[i];
                }
                num[s]=t,ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
		```
  
    ??? note "100 分（归并排序+按秩合并）"
		```cpp
        #include<bits/stdc++.h>
        using namespace std;
        const int N=1e4+15,M=1e6+5,K=20,S=1<<10;
        int n,m,k,t,f[N],c[K],num[S],sz[N];
        long long sum,ans;
        struct E{
            int x,y,z;
        }e[M],b[N<<1],w[K][N],a[S][N];
        int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
        void merge(int x,int y){
            if(sz[x]<sz[y]) swap(x,y);
            f[y]=x,sz[x]+=sz[y];
        }
        signed main(){
            scanf("%d%d%d",&n,&m,&k);
            for(int i=1;i<=m;i++)
                scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
            sort(e+1,e+1+m,[](E x,E y){return x.z<y.z;});
            for(int i=1;i<=n;i++) f[i]=i,sz[i]=1;
            for(int i=1;i<=m;i++){
                int x=find(e[i].x),y=find(e[i].y);
                if(x!=y) merge(x,y),a[0][++t]=e[i],sum+=e[i].z;
            }
            num[0]=t,ans=sum;
            for(int i=1;i<=k;i++){
                scanf("%d",&c[i]);
                for(int j=1,x;j<=n;j++) scanf("%d",&x),w[i][j]={i+n,j,x};
                sort(w[i]+1,w[i]+1+n,[](E x,E y){return x.z<y.z;});
            }
            for(int s=1;s<(1<<k);s++){
                int x=__lg(s&(-s))+1,s1=s^(s&(-s)),cnt=num[s1]+n;
                for(int i=1,j=1,p=1;p<=cnt;p++){
                    if((i<=num[s1]&&a[s1][i].z<=w[x][j].z)||j>n) b[p]=a[s1][i++];
                    else b[p]=w[x][j++];
                }
                sort(b+1,b+1+cnt,[](E x,E y){return x.z<y.z;}); 
                for(int i=1;i<=n+k;i++) f[i]=i,sz[i]=1;
                sum=0;
                for(int i=1;i<=k;i++)
                    if(s>>(i-1)&1) sum+=c[i];
                t=0;
                for(int i=1;i<=cnt;i++){
                    int x=find(b[i].x),y=find(b[i].y);
                    if(x!=y) merge(x,y),sum+=b[i].z,a[s][++t]=b[i];
                }
                num[s]=t,ans=min(ans,sum);
            }
            printf("%lld\n",ans);
            return 0;
        }
        ```

## T3

特殊性质 A：trie / AC 自动机

特殊性质 B：二维数点

100 分：trie + 二维数点，也有 AC 自动机做法

## T4

## T4

$n\leq 18$ 状压，特殊性质 A


$m=1$

??? note "36 分（暴力状压拼上 m=1，再拼上否则输出 0）"

    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int N=510,mod=998244353;
    int n,m,c[N],f[1<<18][20],cnt[N],fac[N],ans;
    char a[N]; 
    signed main(){
        scanf("%d%d%s",&n,&m,a+1),fac[0]=1;
        for(int i=1;i<=n;i++)
            scanf("%d",&c[i]),fac[i]=1ll*fac[i-1]*i%mod,cnt[c[i]]++;
        if(m==1){
            for(int i=1;i<=n;i++) cnt[i]+=cnt[i-1];
            ans=1;
            int x=0,y=0;
            for(int i=1;i<=n;i++){
                if(a[i]=='0') x++;
                else y++,ans=1ll*ans*(cnt[x+y-1]-(y-1)+mod)%mod;
            }
            printf("%lld\n",(fac[n]-1ll*ans*fac[x]%mod+mod)%mod);
            return 0;
        }
        if(n<=18){
            f[0][0]=1;
            for(int s=0;s<(1<<n);s++)
                for(int i=0;i<n;i++) if(f[s][i]){
                    for(int x=1;x<=n;x++)
                        if(!(s>>(x-1)&1))
                            (f[s|(1<<(x-1))][i+(i>=c[x]||a[__builtin_popcount(s)+1]=='0')]+=f[s][i])%=mod;
                }
            for(int i=m;i<=n;i++) (ans+=f[(1<<n)-1][n-i])%=mod;
            printf("%d\n",ans);
            return 0;
        }
        puts("0");
        return 0;
    }
    ```

DP
