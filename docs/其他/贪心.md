### 一、区间覆盖问题

#### A1

> 给出 $n$ 个互不相交的区间，画 $m$ 条线段覆盖所有区间，最小化线段的长度之和。

线段必互不相交。答案 = 区间左右边界 - 前 $m-1$ 大的相邻区间缝隙长度。

#### A2

> 给出 $n$ 个区间，在坐标轴上撒若干个点，使得每个区间至少包含一个点，最小化点数。

当区间有包含关系时只保留较小的区间。这样，将区间按 $l$ 排序后，$r$ 也有序。

- 从左往右依次考虑每个区间，若当前区间内没有点则贪心在右端点撒点。

依据：所有后面与其有交的区间都必然包含其右端点。

#### A2-2

ZR#2562. 23noi-day2 来自金星的外星旅人 Sub4。

> 给出一棵 $n$ 个节点的树 以及 $m$ 条 祖先-后代 链，在边上撒若干个点，使得第 $i$ 条链至少包含 $c_i$ 个点，最小化点数。

自下而上撒点，将链按上端点的深度从大到小排序。

- 依次考虑每条链，若这条链上的点不够就在这条链上深度最浅的边上撒够。

依据：所有与其有交的“上端点比它浅的链”都必然包含其深度最浅的边，因为上端点更浅所有有交部分不可能未到达深度最浅的边就拐走（每个点往上只有一种选择）。

注意，不一定所有与其有交的“下端点比它深的链”都包含其深度最深的边，因为下端点更深可以是有交部分在未到达深度最深的边时就拐到别的子树去（每个点往下有多种选择），所以将链按下端点的深度从小到大排序、自上而下撒点是错的。

（技巧：树相关贪心，自上而下、自下而上都要想想）

#### A3

> 给出 $n$ 个区间，问最多能从中取出多少个区间使得这些区间互不相交。

当区间有包含关系时只保留较小的区间。这样，将区间 $l$ 排序后，$r$ 也有序。

- 从左往右依次考虑每个区间，若当前区间与前面选的区间互不相交就选。

看起来有点假，但仔细想想是其实对的。

依据：所有后面与其有交的区间都必然包含其右端点。也就是说，我们要最小化前面选的区间的右端点。

#### A4

> 给出 $n$ 个区间和 $[L,R]$，问最少能从中取出多少个区间使得这些区间能覆盖 $[L,R]$。

当区间有包含关系时只保留较大的区间。这样，将区间 $l$ 排序后，$r$ 也有序。

- 从左往右贪心，每次找到所有区间中左端点 $\leq L$ 且右端点最大的区间选上，并将新的 $L$ 修改为该区间的右端点，直到覆盖完 $R$。用堆维护。

#### A5

> 有 $p_{1\sim n},l_{1\sim m},r_{1\sim m}$，构造一张左部 $n$ 个点右部 $m$ 个点的二分图，左部第 $i$ 个点与右部第 $j$ 个点有边当且仅当 $p_i\in[l_j,r_j]$，求这张二分图的最大匹配数。
>
> （有 $m$ 个区间和 $n$ 个点，求区间与包含的点的最大匹配数）
>
> $n,m\leq 4\times 10^5$。

区间之间的容纳能力非常复杂，因此考虑点。

- 从左往右依次考虑所有点，维护包含当前点且未匹配的区间集合 $S$，从中选取其中右端点最小的来匹配（把数轴看成时间轴，就相当于选最早过期的）。set 维护 $S$。

（这是个经典问题，有多种表述形式。比如：给出若干区间 $I_1,I_2,\cdots,I_k$，要给每个 $I_i$ 分配一个 $x_i$，使得 $x_i$ 互不相同且 $x_i\in I_i$）

#### A6

CF913D Too Easy Problems（\*1800）

> 给出 $n$ 个点，每个点有点权 $w_i$ 和限制 $p_i$。要求选一个点权和 $\leq T$ 的点集 $S$，最大化 $\sum_{i\in S}[p_i\geq |S|]$。
>
> $n\leq 2\times 10^5$。

发现扔掉 $S$ 中 $p_i<|S|$ 的点一定不劣，因为扔掉之后 $|S|$ 变小了。也就是说，最优情况肯定 $|S|=\sum_{i\in S}[p_i\geq |S|]$。

- 方法 1：二分 $|S|$，从 $p_i\geq |S|$ 里的取点权前 $|S|$ 小的，check 点权和是否 $\leq T$。
- 方法 2：从大到小扫 $|S|$，每移动一次，可取的点数会增多，而需要保留的点数又在减少，于是用堆维护可取的点，每次弹出点权最大的点直到堆中点权和 $\leq T$。

### 二、微扰法

先直观感受，再微扰法确定具体顺序。

#### B1

> 排队接水问题：每个人有一个时间 $t_i$，最小化总时间。

直观感受：$t_i$ 从小到大最优。

微扰法：假设 $i$ 排在 $j$ 前面更优。
$$
(T+t_i)+(T+t_i+t_j)\leq (T+t_j)+(T+t_j+t_i)\\
t_i\leq t_j
$$

#### B2

> 国王游戏：每个人有左右数字 $l_i,r_i$，个人收益为排在前面的人的左手数字乘积 / 自己的右手数字。最大化最小收益。

直观感受：$l_i$ 从小到大，$r_i$ 从小到大。

微扰法：假设 $i$ 排在 $j$ 前面更优。
$$
\max(\frac{m}{r_i},\frac{m\cdot l_i}{r_j})\leq \max(\frac{m}{r_j},\frac{m\cdot l_j}{r_i})\\
\max(r_j,l_i\cdot r_i)\leq \max(r_i,l_j\cdot r_j)\\
$$
由于 $r_j\leq l_j\cdot r_j\leq \max(r_i,l_j\cdot r_j)$，所以条件等价于 $l_i\cdot r_i\leq \max(r_i,l_j\cdot r_j)$，而由于 $r_i\leq l_i\cdot r_i$，所以条件等价于 $l_i\cdot r_i\leq l_j\cdot r_j$。

按 $l_i\cdot r_i$ 从小到大排。

#### 自己补的

> 给出 $v_{1\sim n},c_{1\sim n}$，$v_i\geq 0,c_i\geq 0$，求排列 $p_{1\sim n}$ 最大化 $\min\limits_{i\in[1,n]}\{v_{p_i}-\sum_{j=1}^i c_{p_j}\}$。

直观感受：$c$ 从小到大，$v$ 从小到大。

微扰法：假设 $p_i$ 排在 $p_{i+1}$ 前面更优。
$$
\begin{aligned}
&\min(v_{p_i}-c_{p_i},v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}})\geq \min(v_{p_{i+1}}-c_{p_{i+1}},v_{p_i}-c_{p_i}-c_{p_{i+1}})
\\

\Leftrightarrow &\min(v_{p_i}-c_{p_i},v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}})\geq v_{p_{i+1}}-c_{p_{i+1}}&\\
\lor &\min(v_{p_i}-c_{p_i},v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}})\geq v_{p_i}-c_{p_i}-c_{p_{i+1}}
\end{aligned}
$$
由于 $\min(v_{p_i}-c_{p_i},v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}})\leq v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}}\leq v_{p_{i+1}}-c_{p_{i+1}}$，所以条件等价于 $\min(v_{p_i}-c_{p_i},v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}})\geq v_{p_i}-c_{p_i}-c_{p_{i+1}}$，而由于 $v_{p_i}-c_{p_i}\geq v_{p_i}-c_{p_i}-c_{p_{i+1}}$，所以条件等价于 $v_{p_{i+1}}-c_{p_i}-c_{p_{i+1}}\geq v_{p_i}-c_{p_i}-c_{p_{i+1}}$。

按 $v_i$ 从小到大排。

#### B3-1

P3619 魔法

> 有一个初始血量 $T$ 和 $n$ 个任务。任务 $i$ 只有血量 $T>t_i$ 时才可完成，一旦完成血量即刻加上 $b_i$（可能为负）。同时你需要保证 $T$ 始终 $>0$。
>
> 问是否存在一个完成所有任务的顺序。
>
> $n,T,t_i,|b_i|\leq 10^5$。

先做 $b_i$ 为正的任务，再做 $b_i$ 为负的任务：因为把 $b_i$ 为负的任务放到 $b_i$ 为正的任务后做一定不劣。

- 对于 $b_i$ 为正的任务，按 $t_i$ 从小到大的顺序做，某个时刻做不了就无解。

  - 微扰法：假设 $i$ 排在 $j$ 前面更优。
    $$
    T>t_i,T+b_i>t_j\\
    T\leq t_j\\
    \Rightarrow t_i<t_j
    $$
    （由于 $T>t_i$ 故一定有 $T+b_j>t_i$，所以不可能 $T>t_j,T+b_i\leq t_i$，只能是 $T\leq t_j$）

- 对于 $b_i$ 为负的任务：
  - 直观感受：$t_i$ 较大的比较紧急，$t_i$ 从大到小；$b_i$ 太小的应该放后面，$b_i$ 从大到小。

  - 微扰法：假设 $i$ 排在 $j$ 前面更优。
    $$
    T>t_i,T+b_i>t_j\Rightarrow T>t_j-b_i\\
    T>t_j,T+b_j\leq t_i\Rightarrow T\leq t_i-b_j\\
    t_i+b_i>t_j+b_j
    $$
    （由于 $T+b_i>t_j$ 故一定有 $T>t_j$）

  按 $t_i+b_i$ 从大到小的顺序做，某个时刻做不了就无解。

#### B3-1 Ex

Gym104813E Revenge on My Boss

> 给出 $n$ 个二元组 $(x_i,lim_i)$，问是否存在一种重排 $(x_i,lim_i)$ 的方案，使得 $\forall m,\sum_{i=1}^{m-1} x_i\leq lim_m$。

类似。

```cpp
bool operator<(P a){
	if((x<0)^(a.x<0)) return x<0;
	return x<0?lim>a.lim:lim+x<a.lim+a.x;
}
```

#### B3-2

CF1203F2 Complete the Projects (hard version)（\*2300），DP 套贪心

> 求最多做多少任务。
>
> $n\leq 100$，$T,a_i\leq 3\times 10^4$，$|b_i|\leq 300$。

B3-1 解决的是，假设已知要做哪些任务，应该按什么顺序做。

现在要规划做哪些任务。

按优先级从前往后 DP 来规划要做哪些任务，DP 状态记录当前血量。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=6e4+5;
int n,t,f[N][M],ans;
struct P{
	int a,b;
	bool operator<(P x){
		if((b>=0)^(x.b>=0)) return b>=0;
		return b>=0?a<x.a:a+b>x.a+x.b;
	}
}a[N];
signed main(){
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].a,&a[i].b);
	sort(a+1,a+1+n);
	memset(f,-0x3f,sizeof(f)),f[0][t]=0;
	for(int i=1;i<=n;i++){
		copy(f[i-1],f[i-1]+M,f[i]);
		for(int j=M-1;j>=0;j--)
			if(j>=a[i].a&&j+a[i].b>=0&&j+a[i].b<M) f[i][j+a[i].b]=max(f[i][j+a[i].b],f[i-1][j]+1);
	}
	for(int i=0;i<M;i++) ans=max(ans,f[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

#### B3-3

> 求能完成所有任务的最少初始血量。

方法 1：二分答案。

方法 2：合并的思想。假如已知选了 $(t_i,b_i)$ 后下一个就会选 $(t_j,b_j)$，那么它们可以合并成 $(\max(t_i,t_j-b_i),b_i+b_j)$。将 $n$ 个任务合并成 $(T,B)$ 后，最少初始血量就是 $T$。

#### B3-4

HDU6326 Problem H. Monster Hunter，合并二元组

> 在树上选，只有选完了父亲才能选儿子。求能完成所有任务的最少初始血量。

考虑当前优先级最高的任务，如果它的父亲已经做过了，直接做掉；否则将它与父亲合并，因为已知选完它的父亲后下一个就会立刻选它，构成了依赖关系。

可删堆维护。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int t,n,x,y,fa[N],f[N];
vector<int>v[N];
struct P{
	ll a,b;
	int id;
	bool operator<(P x)const{
		if((b>=0)^(x.b>=0)) return !(b>=0);
		return !(b>=0?a<x.a:a+b>x.a+x.b);
	}
	P operator+(P x){return {max(a,x.a-b),b+x.b,id};}
}a[N];
priority_queue<P>q;	//set 会 T 飞
void dfs(int x){
	for(int y:v[x])
		if(y!=fa[x]) fa[y]=x,dfs(y);
}
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n),a[1]={0,0,1};
		for(int i=1;i<=n;i++) f[i]=i,v[i].clear();
		for(int i=2;i<=n;i++)
			scanf("%lld%lld",&a[i].a,&a[i].b),a[i].b-=a[i].a,a[i].id=i,q.push(a[i]);
		for(int i=1;i<n;i++)
			scanf("%d%d",&x,&y),v[x].push_back(y),v[y].push_back(x);
		dfs(1);
		while(q.size()){
			auto p=q.top();q.pop();
			int x=p.id;
			if(x==1||f[x]!=x||p.a!=a[x].a||p.b!=a[x].b) continue;
			int y=find(fa[x]);
			f[x]=y,q.push(a[y]=a[y]+a[x]);
		}
		printf("%lld\n",a[1].a);
	}
	return 0;
}
```

#### B3-5

UOJ#418. 【集训队作业2018】三角形，转化二元组 + 时光倒流 + 合并二元组

> 一棵 $n$ 个节点的有根树，点有权值 $w_i$，初始每个节点上都没有石子。
>
> 初始你可以准备一些石子拿在手中。可以进行以下两种操作任意次：
>
> 1. 若节点 $i$ 的所有儿子 $j$ 上都有 $w_j$ 个石子，那么可以从手中取 $w_i$ 个石子放在节点 $i$。
> 2. 将节点 $i$ 上的所有石子都收回手中。
>
> 对于每个 $i$ 求，为了在节点 $i$ 上放 $w_i$ 个石子，初始最少需要准备多少石子。
>
> $n\leq 2\times 10^5$，$1\leq w_i\leq 10^9$。

考虑一个点上的石子会在它的父亲被选后立刻收回。选 $x$ 相当于选二元组 $(w_x,-w_x+\sum_{y\in son_x}w_y)$，其中二元组 $(a,b)$ 表示选它时需要手中石子数 $\geq a$，选完后手中石子数会立刻 $+b$。并且要选完 $x$ 的所有儿子才能选 $x$。

考虑时光倒流，“先选儿子才能选父亲”变成了“先选父亲才能选儿子”，倒过来后”$-b_i$，判是否 $\geq a_i$“相当于是二元组 $(a_i+b_i,-b_i)$。用 B3-4 的方法做，时间复杂度 $\mathcal O(n^2\log n)$。

考虑“一棵子树选二元组的顺序”是“整棵树选二元组的顺序”的子序列，自底向上线段树合并即可，空的位置设为 $(0,0)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5,M=N<<6;
int n,w[N],fa[N],f[N],nxt[N],lst[N],rk[N],tot,rt[N],lc[M],rc[M];
ll sum[N],ans[N];
vector<int>v[N];
struct P{
	ll a,b;
	int id;
	bool operator<(P x)const{
		if((b>=0)^(x.b>=0)) return !(b>=0);
		return !(b>=0?a<x.a:a+b>x.a+x.b);
	}
	P operator+(P x){return {max(a,x.a-b),b+x.b,id};}
}a[N],tmp[N],s[M];
priority_queue<P>q;
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
void modify(int &p,int l,int r,int pos,P v){
	if(!p) p=++tot;
	if(l==r){s[p]=v;return ;}
	int mid=(l+r)/2;
	if(pos<=mid) modify(lc[p],l,mid,pos,v);
	else modify(rc[p],mid+1,r,pos,v);
	s[p]=s[lc[p]]+s[rc[p]];
}
void merge(int &x,int y){
	if(!x||!y){x|=y;return ;}
	merge(lc[x],lc[y]),merge(rc[x],rc[y]);
	s[x]=s[lc[x]]+s[rc[x]]; 
}
void dfs(int x){
	modify(rt[x],1,n,rk[x],tmp[x]);
	for(int y:v[x]) dfs(y),merge(rt[x],rt[y]);
	ans[x]=s[rt[x]].a+w[x];
}
signed main(){
	scanf("%*d%d",&n);
	for(int i=2;i<=n;i++)
		scanf("%d",&fa[i]),v[fa[i]].push_back(i);
	for(int i=1;i<=n;i++)
		scanf("%d",&w[i]),sum[fa[i]]+=w[i];
	for(int i=1;i<=n;i++)
		q.push(tmp[i]=a[i]={sum[i],w[i]-sum[i],i}),f[i]=lst[i]=i;
	while(q.size()){
		auto p=q.top();q.pop();
		int x=p.id;
		if(x==1||f[x]!=x||p.a!=a[x].a||p.b!=a[x].b) continue;	//!!! f[x]!=x
		int y=find(fa[x]);
		nxt[lst[y]]=x,lst[y]=lst[x];
		f[x]=y,q.push(a[y]=a[y]+a[x]);
	}
	for(int i=1,x=1;i<=n;i++,x=nxt[x]) rk[x]=i;
	dfs(1);
	for(int i=1;i<=n;i++) printf("%lld ",ans[i]);
	return 0;
}
```

### 三、哈夫曼树

哈夫曼树：给出 $n$ 个权值作为 $n$ 个叶子，构造一棵二叉树，使得该树的带权路径长度最小。点权非负。

构造方法：每次拿出点权最小的两点合并。

$k$ 叉哈夫曼树：手动添加虚拟节点，每次选点权最小的 $k$ 个合并。堆维护，$\mathcal O(n\log n)$。

$\mathcal O(n)$ 构造方法：维护两个队列，一个是原来节点按顺序，另一个是合并产生的节点按顺序。

#### C1

HDU5884 Sort

> 有 $n$ 个点，每个点有点权 $a_i$。一次能合并 $\leq k$ 个点，合并后点的点权为合并的所有点点权之和，花费的代价也是点权之和。
>
> 要求花费的总和 $\leq Q$，求 $k$ 最小是多少。

二分答案。

依据：$k$ 叉哈夫曼树优于 $k-1$ 叉哈夫曼树。

证明：“$k$ 叉”优于“$k-1$ 叉的基础上每个叉额外挂一个 $0$”等于“$k-1$ 叉”。

#### C2

> 哈夫曼树深度尽可能小。

元素第二关键字为节点深度。

### 四、拟阵

![image](https://img2023.cnblogs.com/blog/1859218/202304/1859218-20230423191804468-1906618967.png)

即，对于拟阵 $M=(U,I)$，求 $\max_{S\in I}f(S)$ 的方法是贪心每次尝试加入 $f$ 最大的元素。

证明：

1. 拟阵的贪心选择性质：对于第一个求出的 $f(x)$ 最大的且 $\{x\}\in I$ 的 $x$，存在一个最优子集包含 $x$。

   证明：

   - 若 $x$ 后来能被选，那么在刚开始就一定能被选：根据遗传性，若 $A\cup\{x\}\in I$，则 $\{x\}\in I$。
   - 假设 $B$ 最优且 $x\not\in B$。初始令 $A=\{x\}$，然后不断利用交换性将 $B$ 中其他元素扩充到 $A$ 使得 $|A|=|B|$，此时 $A\in I$ 且显然 $f(A)\geq f(B)$。

2. 最优子结构性质：拟阵 $M=(U,I)$ 选完 $x$ 转化成 $M'=(U',I')$，其中 $U'=\{y\in U\mid \{x,y\}\in I\}$，$I'=\{B\mid B\cup\{x\}\in I\land x\notin B\}$，设 $M$ 的答案为 $\text{opt}$，$M'$ 的答案为 $\text{opt}'$，则 $\text{opt}=\text{opt}'+f(x)$。

   证明：

   - 对于 $B\in I'$，有 $B\cup\{x\}\in I$，由于 $I$ 中任意解 $\leq$ $I$ 中最优解，故 $\text{opt}'+f(x)\leq \text{opt}$。
   - 对于 $A\in I$，有 $A-\{x\}\in I'$，由于 $I'$ 中任意解 $\leq$ $I'$ 中最优解，故 $\text{opt}-f(x)\leq \text{opt}'\Rightarrow \text{opt}'+f(x)\geq \text{opt}$。

技巧：问“要求选一个合法子集”，先考虑给定一个子集怎么快速判断是否合法。一般只有一个量与答案有关，其余量与合法有关，按与答案有关的量贪心尝试加入判是否合法。

#### D1

> 最小生成树 Kruskal 算法。

做法：按边权从小到大尝试加入边，若加入后无环就加入。

拟阵 $M=(U,I)$，其中 $U$ 为边集，$I$ 为所有无环的边集。一条边的权值 $f(e)=\infty-w_e$，这样能保证 $\max_{S\in I}f(S)$ 取满 $n-1$ 条边且边权和最小。

遗传性显然。

交换性：对于 $A\in I,B\in I,|A|<|B|$，$\exists x\in B\backslash A$ 使得 $A\cup\{x\}\in I$。

证明：由于 $|A|<|B|$，故 $A$ 的连通块数量 $>$ $B$ 的连通块数量，那么一定 $\exists i,j$ 使得 $i,j$ 在 $B$ 中连通、在 $A$ 中不连通。拎出 $B$ 中 $i\leadsto j$ 路径上的边加入 $A$ 中，由于 $A$ 中 $i,j$ 不连通所以一定不会有环。

#### D2

> 给出 $n$ 个物品，每个物品有属性 $x$ 和价值 $y$，要求从中选出一些物品使得物品集合中没有子集属性 xor 和为 $0$ 且价值和最大。

做法：按价值从大到小尝试加入物品，若加入后模 $2$ 意义下仍线性无关就加入。

拟阵 $M=(U,I)$，其中 $U$ 为物品，$I$ 为模 $2$ 意义下线性无关的物品集合。$f$ 为价值。

遗传性显然。

交换性：对于线性无关的 $A,B$，$|A|<|B|$，$\exists x\in B\backslash A$ 使得 $A\cup\{x\}$ 仍然线性无关。

证明：反证法，假如加入 $B$ 中任意一个元素都是线性相关的，说明 $B$ 中每个元素都可以表示成 $A$ 中元素的线性组合。考虑一个 $01$ 矩阵，第 $i$ 行第 $j$ 列表示 $B$ 中第 $i$ 个元素使用了多少 $a_j$，那么由于 $B$ 线性无关，将 $B$ 前 $|A|$ 行构成的 $|A|\times |A|$ 的矩阵高斯消元，对角线肯定都是 $1$。那么 $B$ 第 $|A|+1$ 个元素及之后的元素，都可以表示成 $B$ 中前 $|A|$ 个元素的线性组合，也就是 $B$ 线性相关，矛盾。

#### D3

> 给出 $n$ 个任务，每个任务有一个单位的完成时间、截止时间 $d_i$ 和超时惩罚 $p_i$。你在同一时间只能做至多一个任务，你的目标是最小化超时惩罚之和（一个任务只会贡献一次超时惩罚）。

子问题：对于任务集合 $S$，判断能否全都完成。肯定先做 $d_i$ 小的，微扰法。

做法：按 $p_i$ 从大到小的顺序尝试加入任务，若加入后仍都能全完成就加入。

拟阵 $M=(U,I)$，其中 $U$ 为任务，$I$ 为能够都完成的任务集合，$f$ 为 $p_i$。

遗传性显然。

交换性证明：

- 设 $N_t(A)$ 表示集合 $A$ 中 $d_i\leq t$ 的任务个数。$A\in I$ 等价于 $\forall t,N_t(A)\leq t$（必要性和充分性都不难证）。

  对于 $A\in I,B\in I,|A|<|B|$，令 $k$ 为满足 $N_t(B)\leq N_t(A)$ 的最大的 $t$（由于 $N_0(B)=N_0(A)=0$，$N_n(B)=|B|>N_n(A)=|A|$ 故必然有这样一个 $t$），那么 $\forall j>k,N_j(B)>N_j(A)$。

  由于 $N_k(B)\leq N_k(A)$ 而 $N_{k+1}(B)>N_{k+1}(A)$，那么 $B$ 中必然有个任务截止时间为 $k+1$ 而 $A$ 中没有，把这个任务加入 $A$ 中得到 $A'$。

  由于 $\forall t\leq k$，$N_t(A')=N_t(A)\leq t$（因为 $A\in I$），$\forall t>k$，$N_t(A')\leq N_t(B)\leq t$（因为 $B\in I$，且原来 $N_t(A)<N_t(B)$），故 $\forall t,N_t(A')\leq t$，所以 $A'\in I$。
