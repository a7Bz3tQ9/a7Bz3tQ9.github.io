### 一、结合贪心

#### A1

CF460C Present（\*1700）

> 给出 $a_{1\sim n}$，你有 $m$ 次操作机会，每次将其中连续 $w$ 个元素 $+1$。最大化最终序列的最小值。
>
> $1\leq w\leq n\leq 10^5$，$1\leq m\leq 10^5$。

二分答案，从左往右贪心，必须要操作时才进行操作，差分维护连续 $w$ 个元素的区间加。将使所有元素都 $\geq mid$ 的最少操作次数与 $mid$ 比较。

#### A2

P8384 [POI2004] SZN

> 给出一棵 $n$ 个节点的树，你需要用一些路径去覆盖这棵树上的所有边，使得每条边都被 **恰好** 一条路径覆盖。
>
> 求最少路径条数，以及最少路径条数的前提下最小化最长的路径长度。
>
> $2\leq n\leq 10^4$。

第一问：自底向上考虑，由于覆盖的是边而不是点，所以每个非根节点都 **一定** 会往上延伸出一条路径（即使子树内路径两两匹配完了，子树的根也要延伸到父亲），其他延伸上来的路径“原地匹配”，考虑在每条链的最高点统计，答案为 $\sum_{i\neq 1}\lfloor\frac{|son_i|}{2}\rfloor+\lceil\frac{|son_1|}{2}\rceil=\sum_{i\neq 1}\lfloor\frac{deg_i-1}{2}\rfloor+\lceil\frac{deg_i}{2}\rceil=\sum_{i=1}^n\lfloor\frac{deg_i-1}{2}\rfloor+1$。

第二问：二分答案，自底向上维护 $f_x$ 表示从 $x$ 延伸上去的那条链从 $x$ 下方到 $x$ 的最短长度。将所有 $f_y+1$ 排序，两个和 $\leq mid$ 的元素可以配对。

注意当儿子个数为偶数时需要补一个 $0$ 变成奇数。因为全部在 $x$ 处首尾配对不一定对，即使全匹配了也要从 $x$ 往上延伸，还不如某条链不配对直接截止、某条链延伸上去，比如：

<img src="https://img2023.cnblogs.com/blog/1859218/202304/1859218-20230424131005685-1311428825.png" alt="image" style="zoom:50%;" />

接下来要选一条长度最短的链，使得剩下的链都能两两匹配。暴力：枚举要选的那条链的长度，剩下的链贪心最小的与最大的配对。优化：

- 方法 1：选出的元素越大，剩下的越容易能两两配对，有单调性。二分选的元素。
- 方法 2：从左往右枚举选的元素，发现选出的元素右移一位只会改变一对数的配对方式——选出的元素 $i\to i+1$ 时，原来与 $i+1$ 配对的元素改为与 $i$ 配对。用可删堆维护当前时刻的每对的权值和，每次会删一对、加一对，然后判堆顶是否 $\leq mid$。
- 方法 3：从右往左枚举选的元素，配对的最大权值和会越来越大，加的那对的权值和一定 $\geq$ 删的那对的权值和，所以不需要维护堆，直接维护一个变量 $mx$ 表示最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int n,x,y,lim,ok,f[N],cnt,len[N],ans;
vector<int>v[N];
void dfs(int x,int fa){
	if(!ok) return ;
	for(int y:v[x]) if(y!=fa) dfs(y,x);
	cnt=0;
	for(int y:v[x])
		if(y!=fa) len[++cnt]=f[y]+1;
	if(x==1){
		if(cnt&1) len[++cnt]=0;
		sort(len+1,len+1+cnt);
		for(int i=1;i<=cnt/2;i++) if(len[i]+len[cnt-i+1]>lim) ok=0; 
		return ;
	}
	if(!(cnt&1)) len[++cnt]=0;
	sort(len+1,len+1+cnt);
	int mx=0,flg=0;
	for(int i=1;i<=cnt/2;i++) mx=max(mx,len[i]+len[cnt-1-i+1]);
	if(max(mx,len[cnt]+1)<=lim) flg=1,f[x]=len[cnt];
	for(int i=cnt-1;i>=1;i--){
		mx=max(mx,len[i+1]+len[cnt-(i+1)+1+(i==1)]);	//!!! 某 sb 没仔细想写成 cnt-(i+1)+1。然而当 i=1 时是错的
		if(max(mx,len[i]+1)<=lim) flg=1,f[x]=len[i];
	}
	ok&=flg;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),v[x].push_back(y),v[y].push_back(x);
	for(int i=1;i<=n;i++) ans+=(v[i].size()-1)/2;
	ans++;
	int l=1,r=n,p=0;
	while(l<=r){
		int mid=(l+r)/2;
		lim=mid,ok=1,dfs(1,0);
		if(ok) p=mid,r=mid-1;
		else l=mid+1;
	}
	printf("%d %d\n",ans,p);
	return 0;
}
```

#### A3

[AGC006D] Median Pyramid Hard，同 ZR#833. 金字塔

> 给出一个 $n$ 层金字塔的底层数字——一个 $1\sim n$ 的排列。上面的每个数字都是它下面三个数的中位数。求第一层的数。
>
> $2\leq n\leq 10^5$。

二分答案，$\geq mid$ 的数看作 $1$，$<mid$ 的数看作 $0$，转化成只有 $01$。

相邻两个相同的数可以一直延伸上去，比如：

```
 00
x00x
```

所以如果底层最中间两个是一样的，答案就确定了。

进一步，最靠近中间的两个相邻相同的数就决定了答案：因为 $01$ 交替的层每往上推一步就相当于 $01$ 反转，所以相邻相同的数往上一层就相当于向中间移动了一步，最先抢占中心的就决定了答案。

```
 01010101
0101010101
```

```
   010000
  010100000
 01010100001
0101010100101
```

### 二、结合 DP

#### B1

BZOJ4985 评分

> $n$ 个评委站成一排打分，最终得分的计算规则为：每次取出队首前三个评委，弹掉最高分和最低分，剩下的那个评委再排回队尾。最终只剩下的一个评委的打分就是最终得分。
>
> 已知每个评委的打分，但是有 $m$ 位评委不记得自己当时的位置了，求最大可能的最终得分。
>
> $n\leq 10^5$，$a_i<10^9$，$n$ 是奇数。

二分答案，$\geq mid$ 的看作 $1$，$<mid$ 的看作 $0$，转化为只有 $01$。

这 $m$ 位评委中 $1$ 的个数是已知的（设为 $A$），相当于要在不确定的位置上填 $0$ 或 $1$，求出最少填多少个 $1$ 能使得最终得分是 $1$，将其与 $A$ 比较来判断 $mid$ 是否合法。

对每个点存一个 DP 只表示最少填多少个 $1$ 能使得这个数为 $1$。初始 $f_i=\begin{cases}+\infty&(a_i=0)\\0&(a_i=1)\\1&(a_i=?)\end{cases}$。每次取出前三个点 $x,y,z$，$f_{new}=\min\{f_x+f_y,f_x+f_z,f_y+f_z\}$，用队列模拟这个过程。

感觉挺有技巧性的。

时间复杂度 $\mathcal O(n\log A)$。

#### B2

CF360B Levko and Array（\*2000）

> 给出 $a_{1\sim n}$，可以修改 $\leq k$ 个元素的值，最小化 $\max_i|a_i-a_{i+1}|$。
>
> $n\leq 2000$，$-10^9\leq a_i\leq 10^9$。

二分答案后，DP 状态中怎么不记录修改后的 $a_i$？

修改的元素非常难考虑，于是改为去 DP 不修改的元素，最大化不修改的元素数量。

设 $f_i$ 表示 $a_i$ 不改的情况下前 $i$ 个数最多有多少个不用修改。
$$
f_j+1\to f_i\,(mid\times (i-j)\geq |a_i-a_j|)
$$
$(j,i)$ 修改成什么不重要，重要的是只要满足这个条件一定是能修改成合法的。这个 DP 还是挺有技巧的。

时间复杂度 $\mathcal O(n^2\log A)$。

### 三、分数规划

选出一个集合 $S$，求 $\large\frac{\sum_{i\in S}a_i}{\sum_{i\in S}b_i}$ 的最大值（或最小值）。

二分这个值，check $\large\frac{\sum_{i\in S}a_i}{\sum_{i\in S}b_i}\normalsize\geq mid$，$\sum_{i\in S}a_i\geq mid\cdot \sum_{i\in S}b_i$，$\sum_{i\in S}(a_i-mid\cdot b_i)\geq 0$，转化为求 $\sum_{i\in S}(a_i-mid\cdot b_i)$ 的最大值。

#### P4322 [JSOI2016]最佳团体

> $n$ 个点构成一个森林，每个点有属性 $p_i,s_i$，从中选 $k$ 个点，若选某个点则必选其父节点，求 $\large\frac{\sum p_i}{\sum s_i}$ 的最大值。
>
> $1\leq k\leq n\leq 2500$，$0<s_i,p_i\leq 10^4$。

二分最大值 $mid$。设 $f_{x,i}$ 表示 $x$ 子树中选 $i$ 个点，$\sum(p_i-mid\cdot s_i)$ 的最大值，树上背包转移，check $f_{0,k+1}\geq 0$ 即可。如果不选 $x$，$f_{x,0}=0$；否则强制 $x$ 取，转移时 $f_{x,i},f_{y,j}\to f_{x,i+j}$ 要求 $i\neq 0$。

时间复杂度 $\mathcal O(n^2\log v)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2510;
int k,n,s[N],p[N],x,sz[N];
double a[N],f[N][N],g[N];
vector<int>v[N];
void dfs(int x,int fa){
	f[x][0]=0,f[x][1]=a[x],sz[x]=1;
	for(int y:v[x]) if(y!=fa){
		dfs(y,x),fill(g+1,g+1+sz[x]+sz[y],-1e9);
		for(int i=1;i<=sz[x];i++)
			for(int j=0;j<=sz[y];j++) g[i+j]=max(g[i+j],f[x][i]+f[y][j]);
		sz[x]+=sz[y]; 
		for(int i=1;i<=sz[x];i++) f[x][i]=g[i];
	}
}
signed main(){
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&s[i],&p[i],&x),v[x].push_back(i);
	double l=0,r=1e4,ans=0;
	while(l+1e-5<r){
		double mid=(l+r)/2;
		for(int i=1;i<=n;i++) a[i]=p[i]-mid*s[i];
		memset(f,-0x3f,sizeof(f)),dfs(0,-1);
		if(f[0][k+1]>=0) ans=l=mid;
		else r=mid;
	} 
	printf("%.3lf\n",ans);
	return 0;
}
```

#### P3199 [HNOI2009]最小圈

> 给出一张 $n$ 个点 $m$ 条边的有向图，求所有环的边权平均值中的最小值。
>
> $n\leq 3000$，$m\leq 10000$，$|w_{i,j}|\leq 10^7$。

二分 $mid$，$\large\frac{\sum_{i\in S} w}{|S|}\normalsize\leq mid$，$\sum_{i\in S}(w_i-mid)\leq 0$。

将所有边边权 $-mid$ 看是否存在负环即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+5;
int n,m,x,y;
bool v[N];
double z,d[N],l=1e7,r=-1e7,ans;
vector<pair<int,double> >g[N];
bool spfa(int x,double tg){
	v[x]=1;
	for(auto p:g[x]){
		int y=p.first; double z=p.second-tg;
		if(d[y]>d[x]+z){
			d[y]=d[x]+z;
			if(v[y]||spfa(y,tg)) return 1;
		}
	}
	return v[x]=0;
}
bool ok(double x){
	for(int i=1;i<=n;i++) d[i]=1e7,v[i]=0;
	for(int i=1;i<=n;i++)
		if(spfa(i,x)) return 1;
	return 0;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%lf",&x,&y,&z),g[x].push_back({y,z}),l=min(l,z),r=max(r,z);
	while(l+1e-9<r){
		double mid=(l+r)/2;
		if(ok(mid)) ans=r=mid;
		else l=mid;
	}
	printf("%.8lf\n",ans);
	return 0;
}
```

#### 
